ID,Comment,Contract,cognitive_complexity,cyclomatic_complexity,ast,CognitiveComplexity,CyclomaticComplexity,CodeLLamaGenerated,Time,target_function,CodeLLamaCognitiveComplexity,CodeLLamaCyclomaticComplexity,TED,SemanticSimilarity,BLEU,contract_with_constructor
3024,Announce that a particular future Ethereum fork will the one taken by the contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), ""Caller is not a role"");
        _;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATOR_REPRESENTATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'announceFork', 'complexity': 2}]",3.0,{},"[{'function': 'announceFork', 'complexity': 2}]",3.0,"
contract FutureEthereumFork {
    // Version of Solidity to use
    ^0.8.0;

    // Function to announce the future Ethereum fork
    function announceFutureFork(string memory _futureFork) public pure returns (string memory) {
        return _futureFork;
    }
}",1.5506422519683838,announceFutureFork,"[{'function': 'announceFutureFork', 'complexity': 0}]",1.0,40.0,0.7215522840244917,0.0152001577582745,"contract FutureEthereumFork is Ownable {
    // Version of Solidity to use
    ^0.8.0;

    // Function to announce the future Ethereum fork
    function announceFutureFork(string memory _futureFork) public pure returns (string memory) {
        return _futureFork;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
2295,"Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed seller, uint256 quantity, uint256 price, uint256 expiry);

    constructor(address _tokenContract, uint256 _sellFloor, uint256 _sellCeiling) {
        tokenContract = ERC20Interface(_tokenContract);
        sellFloor = _sellFloor;
        sellCeiling = _sellCeiling;
    }

    function sell(uint256 quantity, uint256 price, uint256 expiry) public {
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'sell', 'complexity': 8}]",11.0,"{""type"": ""FunctionDefinition"", ""name"": ""offerTokensForSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenContractAddress""}}, {""type"": ""stringLiteral"", ""value"": ""Only the token contract can call this function""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenContractAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""ether""}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""buyer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""buyer""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""buyer""}, {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalPrice"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""price""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalPrice""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient ETH provided""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'sell', 'complexity': 8}]",11.0,"
pragma solidity ^0.8.0;

import ""./ERC20.sol"";
import ""./SafeMath.sol"";

contract TokenSale {
    using SafeMath for uint256;

    address public tokenContractAddress;
    mapping(address => uint256) public balances;

    function offerTokensForSale() external {
        require(msg.sender == tokenContractAddress, ""Only the token contract can call this function"");

        ERC20 token = ERC20(tokenContractAddress);
        uint256 amount = token.balanceOf(address(this));
        uint256 price = 1 ether; // assuming 1 ETH per token

        for (uint256 i = 0; i < amount; i++) {
            address buyer = msg.sender;
            balances[buyer] += 1;
            token.transferFrom(address(this), buyer, 1);
        }

        uint256 totalPrice = price.mul(amount);
        require(msg.value >= totalPrice, ""Insufficient ETH provided"");
    }
}",5.20585298538208,offerTokensForSale,"[{'function': 'offerTokensForSale', 'complexity': 3}]",4.0,81.0,0.7006188964610687,0.0664427999979085,"pragma solidity ^0.8.0;

import ""./ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    address public tokenContractAddress;
    mapping(address => uint256) public balances;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function offerTokensForSale() external {
        require(msg.sender == tokenContractAddress, ""Only the token contract can call this function"");

        ERC20 token = ERC20(tokenContractAddress);
        uint256 amount = token.balanceOf(address(this));
        uint256 price = 1 ether; // assuming 1 ETH per token

        for (uint256 i = 0; i < amount; i++) {
            address buyer = msg.sender;
            balances[buyer] += 1;
            token.transferFrom(address(this), buyer, 1);
        }

        uint256 totalPrice = price.mul(amount);
        require(msg.value >= totalPrice, ""Insufficient ETH provided"");
    }
}"
1386,Set the minimum deposit amount required to depoist sUSD into the FIFO queue,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol""; // Assuming this import is correct, adjust if necessary

abstract contract YourContract {
    using SafeMath for uint256;
    uint public minimumDepositAmount;

    event MinimumDepositAmountUpdated(uint indexed newAmount);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setMinimumDepositAmount(uint _amount) external onlyOwner {
        require(_amount > SafeDecimalMath.unit(), ""Minimum deposit amount must be greater than UNIT"");
        minimumDepositAmount = _amount;
        emit MinimumDepositAmountUpdated(minimumDepositAmount);
    }
}","[{'function': 'setMinimumDepositAmount', 'complexity': 1}]",2.0,{},"[{'function': 'setMinimumDepositAmount', 'complexity': 1}]",2.0,"
contract DepositQueue {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public deposits;
    uint256 public minimumDepositAmount;

    constructor() public {
        owner = msg.sender;
        minimumDepositAmount = 1000000000000000000; // 1 ETH
    }

    function deposit(uint256 amount) external {
        require(amount >= minimumDepositAmount, ""Insufficient deposit amount"");

        uint256 currentBalance = address(this).balance;
        uint256 newBalance = SafeMath.add(currentBalance, amount);

        deposits[msg.sender] = SafeMath.add(deposits[msg.sender], amount);
    }
}",4.046470880508423,deposit,"[{'function': 'deposit', 'complexity': 1}]",2.0,23.0,0.786553891338243,0.048660054438007,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DepositQueue is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => uint256) public deposits;
    uint256 public minimumDepositAmount = 1000000000000000000; // 1 ETH

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        minimumDepositAmount = 1000000000000000000; // 1 ETH
    }

    function deposit(uint256 amount) external {
        require(amount >= minimumDepositAmount, ""Insufficient deposit amount"");

        uint256 currentBalance = address(this).balance;
        uint256 newBalance = SafeMath.add(currentBalance, amount);

        deposits[msg.sender] = SafeMath.add(deposits[msg.sender], amount);
    }
}"
6236,Helper function that checks for ERC777TokensSender on the sender and calls it .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensSender {
    function tokensToSend(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function callSender(address _operator, address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) private whenNotPaused {
        address senderImplementation = interfaceAddr(_from, ""ERC777TokensSender"");
        if (senderImplementation != 0) {
            ERC777TokensSender(senderImplementation).tokensToSend(_operator, _from, _to, _amount, _userData, _operatorData);
        }
    }

    function interfaceAddr(address contractAddress, string memory interfaceName) internal view returns (address) {
        // Implementation of the logic to retrieve the interface address
        return contractAddress;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","[{'function': 'tokensToSend', 'complexity': 0}, {'function': 'callSender', 'complexity': 1}, {'function': 'interfaceAddr', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkERC777TokensSender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC777Sender""}, ""name"": ""sender"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC777Sender""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sender""}, ""memberName"": ""isERC777Token""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'tokensToSend', 'complexity': 0}, {'function': 'callSender', 'complexity': 1}, {'function': 'interfaceAddr', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC777/IERC777Sender.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function checkERC777TokensSender(address sender) public view returns (bool) {
        IERC777Sender sender = IERC777Sender(sender);
        return sender.isERC777Token();
    }
}",3.290126323699951,checkERC777TokensSender,"[{'function': 'checkERC777TokensSender', 'complexity': 0}]",1.0,17.0,0.5899839290176453,0.01650056955733,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC777/IERC777Sender.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is IERC777Sender {
    using SafeMath for uint256;

    address public constant DEFAULT_SENDER = 0x1111111111111111111111111111111111111111; // Replace with actual value
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function checkERC777TokensSender(address sender) public view returns (bool) {
        IERC777Sender sender_ = IERC777Sender(sender);
        return sender_.isERC777Token();
    }
}"
1700,This method will can be called by the controller after the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Tier {
        bool initialized;
        uint256 startTime;
        uint256 endTime;
        uint256 finalizedTime;
        bool finalized;
    }

    mapping(uint256 => Tier) public tiers;
    uint256 public tierCount;

    event FinalizedTier(uint256 indexed tierIndex, uint256 time);

    function finalize() public initialized {
        Tier storage tier = tiers[tierCount];
        require(!tier.finalized, ""Tier is already finalized"");
        require(block.timestamp >= tier.startTime, ""Start time has not been reached"");
        require(msg.sender == owner() || block.timestamp > tier.endTime || isCurrentTierCapReached(), ""Not authorized to finalize this tier"");
        tier.finalized = true;
        tier.finalizedTime = block.timestamp;
        emit FinalizedTier(tierCount, block.timestamp);
        tierCount++;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }

    // State variables for fork announcement
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string indexed name, string indexed url, uint256 indexed blockNumber);
}","[{'function': 'finalize', 'complexity': 5}, {'function': 'announceFork', 'complexity': 2}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""contribute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid contribution""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Contribution""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'finalize', 'complexity': 5}, {'function': 'announceFork', 'complexity': 2}]",6.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    event Contribution(address indexed contributor, uint256 amount);

    mapping (address => uint256) public contributions;

    function contribute(uint256 amount) external {
        require(amount > 0, ""Invalid contribution"");
        contributions[msg.sender] = contributions[msg.sender].add(amount);
        emit Contribution(msg.sender, amount);
    }
}",2.647928476333618,contribute,"[{'function': 'contribute', 'complexity': 1}]",2.0,47.0,0.2629703857390125,0.0090612846539343,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    event Contribution(address indexed contributor, uint256 amount);

    mapping (address => uint256) public contributions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function contribute(uint256 amount) external {
        require(amount > 0, ""Invalid contribution"");
        contributions[msg.sender] = contributions[msg.sender].add(amount);
        emit Contribution(msg.sender, amount);
    }
}"
250,` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public constant absoluteMinTimeLock = 1 days; // Example value, adjust as needed

    function setTimelock(uint _newTimeLock) external onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock);
        timeLock = _newTimeLock;
    }
}","[{'function': 'setTimelock', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTimeLock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}, {""type"": ""stringLiteral"", ""value"": ""New time lock must be greater than or equal to the minimum""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""newTimeLock""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setTimelock', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

contract TimeLock {
    using SafeMath for uint256;

    address public owner;
    uint256 public timeLock;
    uint256 public absoluteMinTimeLock = 1 hours;

    constructor() public {
        owner = msg.sender;
        timeLock = 0;
    }

    function setTimeLock(uint256 newTimeLock) onlyOwner external {
        require(newTimeLock >= absoluteMinTimeLock, ""New time lock must be greater than or equal to the minimum"");
        timeLock = newTimeLock;
    }
}",5.21742582321167,setTimeLock,"[{'function': 'setTimeLock', 'complexity': 1}]",2.0,1.0,0.8667327970893055,0.1287668952436992,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TimeLock is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    uint256 public timeLock = 1 hours;
    uint256 public absoluteMinTimeLock = 1 hours;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done in the constructor, no need to explicitly initialize them here.
    }

    function setTimeLock(uint256 newTimeLock) onlyOwner external {
        require(newTimeLock >= absoluteMinTimeLock, ""New time lock must be greater than or equal to the minimum"");
        timeLock = newTimeLock;
    }
}"
5791,Give melon tokens to receive shares of this fund,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceFeed {
    function getLastUpdateId() external view returns (uint);
}

interface ComplianceModule {
    function isInvestmentPermitted(address participant, uint giveQuantity, uint shareQuantity) external view returns (bool);
}

abstract contract InvestmentRequestManager is Ownable {
    using SafeMath for uint;

    enum RequestStatus { inactive, active, completed }

    struct Request {
        address participant;
        RequestStatus status;
        address requestAsset;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
    }

    Request[] public requests;
    mapping(address => bool) public isInvestAllowed;
    bool public isShutDown = false;
    PriceFeed public modules;

    event RequestUpdated(uint requestId);

    constructor(PriceFeed _modules) {
        modules = _modules;
    }

    function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external pre_cond(!isShutDown) pre_cond(isInvestAllowed[investmentAsset]) pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity)) {
        requests.push(Request({
            participant: msg.sender,
            status: RequestStatus.active,
            requestAsset: investmentAsset,
            shareQuantity: shareQuantity,
            giveQuantity: giveQuantity,
            receiveQuantity: shareQuantity,
            timestamp: block.timestamp,
            atUpdateId: modules.getLastUpdateId()
        }));
        emit RequestUpdated(requests.length - 1);
    }
}","[{'function': 'getLastUpdateId', 'complexity': 0}, {'function': 'isInvestmentPermitted', 'complexity': 0}, {'function': 'requestInvestment', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getShares"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""shares"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1000000000000000000"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""melonToken""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""shares""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getLastUpdateId', 'complexity': 0}, {'function': 'isInvestmentPermitted', 'complexity': 0}, {'function': 'requestInvestment', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeMath.sol"";

contract MelonFund {
    using SafeMath for uint256;

    IERC20 public melonToken;

    constructor(address _melonToken) {
        melonToken = IERC20(_melonToken);
    }

    function getShares(uint256 amount) external returns (uint256) {
        uint256 shares = amount.div(1000000000000000000);
        melonToken.transferFrom(msg.sender, address(this), amount);
        return shares;
    }
}",4.505791425704956,getShares,"[{'function': 'getShares', 'complexity': 0}]",1.0,41.0,0.4201702535742405,0.0142467897237803,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MelonFund is Ownable {
    using SafeMath for uint256;

    IERC20 public melonToken;

    constructor(address _melonToken) Ownable(msg.sender) {
        melonToken = IERC20(_melonToken);
    }

    function getShares(uint256 amount) external returns (uint256) {
        uint256 shares = amount.div(1000000000000000000);
        melonToken.transferFrom(msg.sender, address(this), amount);
        return shares;
    }
}"
1160,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public buyPrice;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) external onlyOwner {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""sellTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ethAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""newSellPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ethAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract TokenSale {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    address public owner;
    IERC20 public token;
    uint256 public newBuyPrice;
    uint256 public newSellPrice;

    constructor(address _owner, IERC20 _token) {
        owner = _owner;
        token = _token;
    }

    function buyTokens() external payable {
        require(msg.value == newBuyPrice, ""Insufficient ETH sent"");
        uint256 amount = msg.value / newBuyPrice;
        token.safeTransferFrom(address(this), msg.sender, amount);
    }

    function sellTokens(uint256 _amount) external {
        require(_amount > 0, ""Invalid amount"");
        uint256 ethAmount = _amount * newSellPrice;
        token.safeTransferFrom(msg.sender, address(this), _amount);
        msg.sender.transfer(ethAmount);
    }
}",6.886022329330444,sellTokens,"[{'function': 'buyTokens', 'complexity': 1}, {'function': 'sellTokens', 'complexity': 1}]",2.0,26.0,0.5168559722338274,0.0169167228345438,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenSale is Ownable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    address public owner;
    IERC20 public token;
    uint256 public newBuyPrice;
    uint256 public newSellPrice;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        token = IERC20(""MyToken"");
        newBuyPrice = 1;
        newSellPrice = 1;
    }

    function buyTokens() external payable {
        require(msg.value == newBuyPrice, ""Insufficient ETH sent"");
        uint256 amount = msg.value / newBuyPrice;
        token.safeTransferFrom(address(this), msg.sender, amount);
    }

    function sellTokens(uint256 _amount) external {
        require(_amount > 0, ""Invalid amount"");
        uint256 ethAmount = _amount * newSellPrice;
        token.safeTransferFrom(msg.sender, address(this), _amount);
        msg.sender.transfer(ethAmount);
    }
}"
3416,Returns all the relevant information about a specific property .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PropertyInterface {
    function getProperty(uint256 _id) external view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    );
}

abstract contract PropertyWrapper is Ownable {
    using SafeMath for uint256;

    struct Property {
        uint32 parent;
        uint8 class;
        uint8 x;
        uint8 y;
        uint8 z;
        uint8 dx;
        uint8 dz;
    }

    enum PropertyClass {
        NONE,
        BUILDING
    }

    mapping(uint256 => Property) public properties;

    function _computeHeight(uint8 x, uint8 z, uint8 y) internal pure returns (uint8 height) {
        // Placeholder for the actual computation logic
        return 0; // Replace with actual implementation if needed
    }

    function getProperty(uint256 _id) public view returns (
        uint32 parent,
        uint8 class,
        uint8 x,
        uint8 y,
        uint8 z,
        uint8 dx,
        uint8 dz,
        uint8 height
    ) {
        Property storage property = properties[_id];
        parent = uint32(property.parent);
        class = uint8(property.class);
        height = uint8(property.y);
        if (property.class == PropertyClass.BUILDING) {
            y = uint8(_computeHeight(property.x, property.z, property.y));
        } else {
            y = uint8(property.y);
        }
        x = uint8(property.x);
        z = uint8(property.z);
        dx = uint8(property.dx);
        dz = uint8(property.dz);
    }
}","[{'function': 'getProperty', 'complexity': 0}, {'function': '_computeHeight', 'complexity': 0}, {'function': 'getProperty', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPropertyInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""propertyId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""properties""}, ""index"": {""type"": ""Identifier"", ""name"": ""propertyId""}}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""properties""}, ""index"": {""type"": ""Identifier"", ""name"": ""propertyId""}}, ""memberName"": ""owner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""properties""}, ""index"": {""type"": ""Identifier"", ""name"": ""propertyId""}}, ""memberName"": ""price""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""properties""}, ""index"": {""type"": ""Identifier"", ""name"": ""propertyId""}}, ""memberName"": ""area""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""properties""}, ""index"": {""type"": ""Identifier"", ""name"": ""propertyId""}}, ""memberName"": ""isForSale""}], ""isArray"": False}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getProperty', 'complexity': 0}, {'function': '_computeHeight', 'complexity': 0}, {'function': 'getProperty', 'complexity': 0}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Property {
    using SafeMath for uint256;

    struct PropertyInfo {
        string name;
        address owner;
        uint256 price;
        uint256 area;
        bool isForSale;
    }

    mapping(uint256 => PropertyInfo) public properties;

    function getPropertyInfo(uint256 propertyId) external view returns (string memory, address, uint256, uint256, bool) {
        return (properties[propertyId].name, properties[propertyId].owner, properties[propertyId].price, properties[propertyId].area, properties[propertyId].isForSale);
    }
}",3.3446552753448486,getPropertyInfo,"[{'function': 'getPropertyInfo', 'complexity': 0}]",1.0,65.0,0.6926412765710137,0.0059604359073243,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract Property is Ownable {
    using SafeMath for uint256;

    struct PropertyInfo {
        string name;
        address owner;
        uint256 price;
        uint256 area;
        bool isForSale;
    }

    mapping(uint256 => PropertyInfo) public properties;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 10; i++) {
            properties[i] = PropertyInfo({
                name: 'initialized',
                owner: address(uint160(i + 1)), // Using fixed addresses in sequence
                price: uint256(1), // Never zero
                area: uint256(1), // Never zero
                isForSale: true
            });
        }
    }

    function getPropertyInfo(uint256 propertyId) external view returns (string memory, address, uint256, uint256, bool) {
        return (properties[propertyId].name, properties[propertyId].owner, properties[propertyId].price, properties[propertyId].area, properties[propertyId].isForSale);
    }
}"
4560,Get the current total number of market listings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256[] public forSalePixelconIndexes;

    function totalListings() public view returns (uint256) {
        return forSalePixelconIndexes.length;
    }
}","[{'function': 'totalListings', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalListings"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""listings""}, ""memberName"": ""length""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'totalListings', 'complexity': 0}]",2.0,"
pragma solidity ^0.8.0;

contract MarketListing {
    using SafeMath for uint256;

    struct Listing {
        address seller;
        uint256 price;
        string name;
        string description;
    }

    mapping(uint256 => Listing) public listings;

    function getTotalListings() external view returns (uint256) {
        return listings.length();
    }
}",2.077608585357666,getTotalListings,"[{'function': 'getTotalListings', 'complexity': 0}]",1.0,1.0,0.8197512640166403,0.4052127766461669,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MarketListing is Ownable {
    using SafeMath for uint256;

    struct Listing {
        address seller;
        uint256 price;
        string name;
        string description;
    }

    mapping(uint256 => Listing) public listings;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            listings[i] = Listing({
                seller: address(uint160(uint256(keccak256(abi.encodePacked(""seller"", i)))),
                price: 1,
                name: ""initialized"",
                description: ""initialized""
            });
        }
    }

    function getTotalListings() external view returns (uint256) {
        return listings.length();
    }
}"
2354,Transfer tokens from one address to another and then call ` onTransferReceived ` on receiver,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {
        // Your implementation here
    }
}","[{'function': 'transferFromAndCall', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferAndCall"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid receiver""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}, ""memberName"": ""onTransferReceived""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFromAndCall', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transferAndCall(address from, address to, uint256 amount) public {
        require(from != address(0), ""Invalid sender"");
        require(to != address(0), ""Invalid receiver"");
        require(amount > 0, ""Invalid amount"");

        // Transfer tokens from sender to receiver
        SafeMath.sub(balances[from], amount);
        balances[to] = SafeMath.add(balances[to], amount);

        // Call onTransferReceived on receiver
        IERC20(to).onTransferReceived(amount, from);
    }
}",3.480596780776977,transferAndCall,"[{'function': 'transferAndCall', 'complexity': 3}]",4.0,62.0,0.7171445161470369,0.0099455590981154,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is for Ownable contract

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set balance to 1 for the owner
    }

    function transferAndCall(address from, address to, uint256 amount) public {
        require(from != address(0), ""Invalid sender"");
        require(to != address(0), ""Invalid receiver"");
        require(amount > 0, ""Invalid amount"");

        // Transfer tokens from sender to receiver
        SafeMath.sub(balances[from], amount);
        balances[to] = SafeMath.add(balances[to], amount);

        // Call onTransferReceived on receiver
        IERC20(to).onTransferReceived(amount, from);
    }
}"
3881,Check if specified holder trusts an address with recovery procedure .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TrustedWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) private trustedMap;

    function isTrusted(address _from, address _to) public view returns (bool) {
        return trustedMap[_from][_to];
    }
}","[{'function': 'isTrusted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""add"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""c"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""c""}, ""right"": {""type"": ""Identifier"", ""name"": ""a""}}, {""type"": ""stringLiteral"", ""value"": ""SafeMath: addition overflow""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""c""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'isTrusted', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
}
contract RecoveryContract {
    struct Holder {
        address holderAddress;
        bool trustsRecoveryProcedure;
    }
    mapping (address => Holder) public holders;
    function isTrusted(address _holder, address _recoveryAddress) public view returns (bool) {
        return holders[_holder].trustsRecoveryProcedure && holders[_holder].holderAddress == _recoveryAddress;
    }
}",3.347616195678711,add,"[{'function': 'add', 'complexity': 1}, {'function': 'isTrusted', 'complexity': 0}]",2.0,12.0,0.3019108973272437,0.0188471072687152,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract RecoveryContract is Ownable {
    struct Holder {
        address holderAddress;
        bool trustsRecoveryProcedure;
    }
    mapping (address => Holder) public holders;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            holders[addr] = Holder({holderAddress: addr, trustsRecoveryProcedure: true});
        }
    }

    function isTrusted(address _holder, address _recoveryAddress) public view returns (bool) {
        return holders[_holder].trustsRecoveryProcedure && holders[_holder].holderAddress == _recoveryAddress;
    }
}"
2976,Removes the necessary permissions for a user to destroy tokens from a blacklisted account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bytes4 constant DESTROY_BLACKLISTED_TOKENS_SIG = 0x7c5b3e18;

    mapping(address => bool) public blacklistDestroyers;

    event LogRemovedBlacklistDestroyer(address indexed who);

    modifier onlyValidator() {
        require(msg.sender == owner(), ""Only the validator can call this function"");
        _;
    }

    function isPermission(bytes4 sig) internal view returns (bool) {
        return sig == DESTROY_BLACKLISTED_TOKENS_SIG;
    }

    function removeUserPermission(address _who, bytes4 sig) internal {
        require(!blacklistDestroyers[_who], ""Address already has permission to destroy blacklisted tokens"");
        blacklistDestroyers[_who] = true;
    }

    function removeBlacklistDestroyer(address _who) public onlyValidator {
        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), ""Blacklist token destruction not supported by token"");
        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);
        emit LogRemovedBlacklistDestroyer(_who);
    }
}","[{'function': 'isPermission', 'complexity': 0}, {'function': 'removeUserPermission', 'complexity': 2}, {'function': 'removeBlacklistDestroyer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removePermissions"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isBlacklisted""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Account has been blacklisted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_destroyTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isPermission', 'complexity': 0}, {'function': 'removeUserPermission', 'complexity': 2}, {'function': 'removeBlacklistDestroyer', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Blacklist {
    using SafeMath for uint256;

    mapping(address => bool) public isBlacklisted;

    function removePermissions(address account, uint256 amount) external {
        require(!isBlacklisted[account], ""Account has been blacklisted"");
        // Additional logic can be added here to ensure the user has sufficient permissions to destroy tokens
        _destroyTokens(amount);
    }
}",2.350015163421631,removePermissions,"[{'function': 'removePermissions', 'complexity': 2}]",2.0,10.0,0.6942668980736805,0.048481891631737,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract Blacklist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public isBlacklisted;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function removePermissions(address account, uint256 amount) external {
        require(!isBlacklisted[account], ""Account has been blacklisted"");
        // Additional logic can be added here to ensure the user has sufficient permissions to destroy tokens
        _destroyTokens(amount);
    }
}"
6370,This function enables token transfers for everyone.Can only be enabled after the end of the ICO .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRelease is Ownable {
    using SafeMath for uint256;

    bool public released;
    event TokenReleased(bool indexed released);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Only the admin can call this function"");
        _;
    }

    modifier whenNotPaused() {
        // Assuming a standard Pausable contract from OpenZeppelin for pausing functionality
        // This should be implemented based on actual pause logic in your contract
        require(paused == false, ""Contract is paused"");
        _;
    }

    function releaseTokenForTransfer() public onlyAdmin whenNotPaused {
        require(!released, ""Tokens have already been released"");
        released = true;
        emit TokenReleased(released);
    }
}","[{'function': 'releaseTokenForTransfer', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""ICO has not ended""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""transferEnabled""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""transferEnabled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""FalseBody"": None}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'releaseTokenForTransfer', 'complexity': 2}]",2.0,"
pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint256;

    bool public transferEnabled = false;

    function enableTransfer() external {
        require(block.number > 100, ""ICO has not ended"");

        if (!transferEnabled) {
            transferEnabled = true;
        }
    }
}",1.792827844619751,enableTransfer,"[{'function': 'enableTransfer', 'complexity': 3}]",3.0,12.0,0.5508136735323604,0.0592795918453586,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    bool public transferEnabled = false;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        transferEnabled = true; // Set to true instead of false as per the initialization rules
    }

    function enableTransfer() external {
        require(block.number > 100, ""ICO has not ended"");

        if (!transferEnabled) {
            transferEnabled = true;
        }
    }
}"
3576,adds or removes addresses from the whitelist .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhitelistModifier is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event ModifyWhitelist(address indexed investor, uint timestamp, address indexed caller, bool valid);

    function modifyWhitelist(address _investor, bool _valid) public onlyOwner {
        whitelist[_investor] = _valid;
        emit ModifyWhitelist(_investor, block.timestamp, msg.sender, _valid);
    }
}","[{'function': 'modifyWhitelist', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addToWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""addresses"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelisted""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'modifyWhitelist', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Whitelist {
    using SafeMath for uint256;

    mapping(address => bool) public whitelisted;

    function addToWhitelist(address[] calldata addresses) external {
        for (uint256 i = 0; i < addresses.length; i++) {
            whitelisted[addresses[i]] = true;
        }
    }

    function removeFromWhitelist(address[] calldata addresses) external {
        for (uint256 i = 0; i < addresses.length; i++) {
            whitelisted[addresses[i]] = false;
        }
    }
}",3.3248391151428223,addToWhitelist,"[{'function': 'addToWhitelist', 'complexity': 1}, {'function': 'removeFromWhitelist', 'complexity': 1}]",2.0,24.0,0.5645238961940907,0.0113149364817996,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Whitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelisted;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function addToWhitelist(address[] calldata addresses) external {
        for (uint256 i = 0; i < addresses.length; i++) {
            whitelisted[addresses[i]] = true;
        }
    }

    function removeFromWhitelist(address[] calldata addresses) external {
        for (uint256 i = 0; i < addresses.length; i++) {
            whitelisted[addresses[i]] = false;
        }
    }
}"
1319,Token owner can approve for ` spender ` to transferFrom ( ... ) ` tokens ` from the token owner 's account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address spender, uint256 tokens) public returns (bool success) {
        requireTrade(msg.sender);
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function requireTrade(address sender) internal view {
        // Implement trade requirement logic here if needed
    }
}","[{'function': 'approve', 'complexity': 1}, {'function': 'requireTrade', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the token owner can approve""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, {""type"": ""Identifier"", ""name"": ""tokens""}], ""names"": []}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 1}, {'function': 'requireTrade', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function approve(address spender, uint256 tokens) public returns (bool success) {
        require(msg.sender == owner, ""Only the token owner can approve"");
        balances[spender] = SafeMath.add(balances[spender], tokens);
        return true;
    }
}",2.953984260559082,approve,"[{'function': 'approve', 'complexity': 1}]",2.0,15.0,0.9258356611580894,0.5366899550531248,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract Token is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // No need to initialize balances here as they are already initialized in the mapping
    }

    function approve(address spender, uint256 tokens) public returns (bool success) {
        require(msg.sender == owner, ""Only the token owner can approve"");
        balances[spender] = SafeMath.add(balances[spender], tokens);
        return true;
    }
}"
4806,Returns the ether in escrow to the seller .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EscrowInterface {
    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (Escrow memory, bytes32);
}

abstract contract EscrowWrapper is Ownable {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
        uint256 sellerCanCancelAfter;
        uint128 totalGasFeesSpentByRelayer;
    }

    mapping(bytes32 => Escrow) public escrows;
    address public relayer;
    uint256 constant GAS_doSellerCancel = 20000;

    event CancelledBySeller(bytes32 indexed tradeHash);

    function transferMinusFees(address _seller, uint256 _amount, uint128 _gasFees, uint16 _fee) internal {
        // Implementation of the transfer minus fees logic
    }

    function doSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);

        if (!_escrow.exists) {
            return false;
        }

        if (_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {
            return false;
        }

        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice) : 0);

        delete escrows[_tradeHash];

        emit CancelledBySeller(_tradeHash);

        transferMinusFees(_seller, _value, _gasFees, 0);

        return true;
    }
}","[{'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'transferMinusFees', 'complexity': 0}, {'function': 'doSellerCancel', 'complexity': 5}]",5.0,{},"[{'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'transferMinusFees', 'complexity': 0}, {'function': 'doSellerCancel', 'complexity': 5}]",6.0,"
contract Escrow {
    using SafeMath for uint256;

    address payable public seller;
    address payable public buyer;
    uint256 public amount;

    function releaseEscrow() public {
        require(msg.sender == seller, ""Only the seller can release the escrow"");
        require(amount > 0, ""The escrow must have a positive amount"");

        seller.transfer(amount);
        amount = 0;
    }
}",2.259744167327881,releaseEscrow,"[{'function': 'releaseEscrow', 'complexity': 2}]",3.0,81.0,0.5821842264038831,0.0084649539668989,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable {
    using SafeMath for uint256;

    address payable public seller = payable(address(uint160(uint256(keccak256('seller1')))));
    address payable public buyer = payable(address(uint160(uint256(keccak256('buyer1')))));
    uint256 public amount = 1;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is done in the constructor
    }

    function releaseEscrow() public {
        require(msg.sender == seller, ""Only the seller can release the escrow"");
        require(amount > 0, ""The escrow must have a positive amount"");

        seller.transfer(amount);
        amount = 0;
    }
}"
3857,Puts campaign into active state only controller can do that only possible if team token Vault is set up WARNING : usual caveats apply to the Ethereum 's interpretation of time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum CampaignState { Init, PreSale, Sale, Closed }
    CampaignState public campaignState = CampaignState.Init;

    address public teamVaultAddr;

    uint256 public tCampaignStart;
    uint256 public tBonusStageEnd;
    uint256 public tRegSaleStart;
    uint256 public t_1st_StageEnd;
    uint256 public t_2nd_StageEnd;
    uint256 public t_3rd_StageEnd;
    uint256 public tCampaignEnd;

    event CampaignOpen(uint256 timestamp);

    modifier onlyController() {
        require(owner() == msg.sender, ""Only the controller can call this function"");
        _;
    }

    function startSale() public onlyController {
        require(campaignState > 2 && teamVaultAddr != address(0));
        campaignState = CampaignState.Sale;
        uint256 tNow = block.timestamp;
        tCampaignStart = tNow;
        tBonusStageEnd += tNow;
        tRegSaleStart += tNow;
        t_1st_StageEnd += tNow;
        t_2nd_StageEnd += tNow;
        t_3rd_StageEnd += tNow;
        tCampaignEnd += tNow;
        emit CampaignOpen(tNow);
    }
}","[{'function': 'startSale', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""activateCampaign"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""controller""}}, {""type"": ""stringLiteral"", ""value"": ""Only the controller can activate the campaign""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""teamTokenVault""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Team token vault must be set up before activating the campaign""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""active""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'startSale', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Campaign {
    using SafeMath for uint256;

    address public controller;
    bool public active;
    uint256 public teamTokenVault;

    constructor() public {
        controller = msg.sender;
        active = false;
        teamTokenVault = 0;
    }

    function activateCampaign() public {
        require(msg.sender == controller, ""Only the controller can activate the campaign"");
        require(teamTokenVault > 0, ""Team token vault must be set up before activating the campaign"");
        active = true;
    }
}",3.1056511402130127,activateCampaign,"[{'function': 'activateCampaign', 'complexity': 2}]",4.0,46.0,0.637627916538239,0.0375096306509621,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Campaign is Ownable {
    using SafeMath for uint256;

    address public controller;
    bool public active;
    uint256 public teamTokenVault;

    constructor() Ownable(msg.sender) {
        controller = msg.sender;
        active = false;
        teamTokenVault = 1; // Set to a non-zero value
    }

    function activateCampaign() public {
        require(msg.sender == controller, ""Only the controller can activate the campaign"");
        require(teamTokenVault > 0, ""Team token vault must be set up before activating the campaign"");
        active = true;
    }
}"
497,Add an associated Synth contract to the Synthetix system,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Synth {
    function currencyKey() external view returns (bytes4);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    Synth[] public availableSynths;
    mapping(bytes4 => Synth) public synths;

    event SynthAdded(bytes4 indexed currencyKey, Synth synth);

    function addSynth(Synth synth) external onlyOwner {
        bytes4 currencyKey = synth.currencyKey();
        require(synths[currencyKey] == Synth(0), ""Synth already exists"");
        availableSynths.push(synth);
        synths[currencyKey] = synth;
        emit SynthAdded(currencyKey, synth);
    }
}","[{'function': 'currencyKey', 'complexity': 0}, {'function': 'addSynth', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""addSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Balance must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Owner already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Synth""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_name""}, {""type"": ""Identifier"", ""name"": ""_balance""}], ""names"": [""owner"", ""name"", ""balance""]}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'currencyKey', 'complexity': 0}, {'function': 'addSynth', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""./Synth.sol"";
import ""./SafeMath.sol"";

contract Synthetix {
    using SafeMath for uint256;

    struct Synth {
        address owner;
        string name;
        uint256 balance;
    }

    mapping(address => Synth) public synths;

    function addSynth(string memory _name, uint256 _balance) public returns (bool) {
        require(_balance > 0, ""Balance must be greater than zero"");
        require(synths[msg.sender].owner == address(0), ""Owner already exists"");

        synths[msg.sender] = Synth({
            owner: msg.sender,
            name: _name,
            balance: _balance
        });

        return true;
    }
}",3.8810319900512695,addSynth,"[{'function': 'addSynth', 'complexity': 2}]",3.0,31.0,0.7008713639658796,0.1449892207357603,"pragma solidity ^0.8.0;

import ""./Synth.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is the correct import path for Ownable

contract Synthetix is Ownable {
    using SafeMath for uint256;

    struct Synth {
        address owner;
        string name;
        uint256 balance;
    }

    mapping(address => Synth) public synths;

    constructor() Ownable(msg.sender) {
        // No need to initialize synths here as they are initialized in addSynth function
    }

    function addSynth(string memory _name, uint256 _balance) public returns (bool) {
        require(_balance > 0, ""Balance must be greater than zero"");
        require(synths[msg.sender].owner == address(0), ""Owner already exists"");

        synths[msg.sender] = Synth({
            owner: msg.sender,
            name: _name,
            balance: _balance
        });

        return true;
    }
}"
5313,update the price based on the remaining count of resources,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;
    uint8 public decimals;
    uint256 public sellPrice;
    uint256 public buyPrice;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply, uint256 _totalSupply, uint8 _decimals) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
        totalSupply = _totalSupply;
        decimals = _decimals;
    }

    function updatePrice() public {
        sellPrice = initialSellPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).mul(10 ** uint256(decimals)).div(totalSupply);
    }
}","[{'function': 'updatePrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateResourcePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""resourceCount""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""resourceAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""resourceCount""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""addr""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""remainingCount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""resourceCount""}, ""index"": {""type"": ""Identifier"", ""name"": ""resourceAddress""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""remainingCount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": []}, ""FalseBody"": {""type"": ""Block"", ""statements"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updatePrice', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract ResourcePriceUpdater is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public resourceCount;

    function updateResourcePrice() public onlyOwner {
        for (uint256 i = 0; i < resourceCount.length; i++) {
            address resourceAddress = resourceCount[i].addr;
            uint256 remainingCount = resourceCount[resourceAddress];
            if (remainingCount == 0) {
                // Update price to 0
            } else {
                // Update price based on remaining count
            }
        }
    }
}",4.4626405239105225,updateResourcePrice,"[{'function': 'updateResourcePrice', 'complexity': 3}]",3.0,37.0,0.6979151103040384,0.0256215032488629,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract ResourcePriceUpdater is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public resourceCount;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
        resourceCount[address(0x111)] = 1;
        resourceCount[address(0x222)] = 1;
        resourceCount[address(0x333)] = 1;
    }

    function updateResourcePrice() public onlyOwner {
        for (uint256 i = 0; i < resourceCount.length; i++) {
            address resourceAddress = resourceCount[i].addr;
            uint256 remainingCount = resourceCount[resourceAddress];
            if (remainingCount == 0) {
                // Update price to 0
            } else {
                // Update price based on remaining count
            }
        }
    }
}"
565,Removes a list of addresses from the whitelist .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Whitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    event WhitelistRemoved(address indexed user);

    function removeAddressesFromWhitelist(address[] memory _users) external onlyOwner {
        require(_users.length > 0, ""Cannot remove an empty list to whitelist!"");

        for (uint256 i = 0; i < _users.length; ++i) {
            address user = _users[i];
            if (whitelist[user]) {
                whitelist[user] = false;
                emit WhitelistRemoved(user);
            }
        }
    }
}","[{'function': 'removeAddressesFromWhitelist', 'complexity': 5}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeWhitelistedAddresses"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""addresses"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can remove addresses from the whitelist""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""addr"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""whitelistedAddresses""}, ""memberName"": ""indexOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""addr""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""UnaryOperation"", ""operator"": ""-"", ""subExpression"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}, ""isPrefix"": True}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""whitelistedAddresses""}, ""memberName"": ""removeAt""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""index""}], ""names"": []}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'removeAddressesFromWhitelist', 'complexity': 5}]",4.0,"pragma solidity ^0.8.0;

contract Whitelist {
    using SafeMath for uint256;

    address[] public whitelistedAddresses;

    function removeWhitelistedAddresses(address[] memory addresses) external {
        require(msg.sender == owner, ""Only the owner can remove addresses from the whitelist"");
        for (uint256 i = 0; i < addresses.length; i++) {
            address addr = addresses[i];
            uint256 index = whitelistedAddresses.indexOf(addr);
            if (index != -1) {
                whitelistedAddresses.removeAt(index);
            }
        }
    }
}",3.0926952362060547,removeWhitelistedAddresses,"[{'function': 'removeWhitelistedAddresses', 'complexity': 4}]",4.0,12.0,0.8347424436412892,0.2799416636906395,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Whitelist is Ownable {
    using SafeMath for uint256;

    address[] public whitelistedAddresses;
    bool public initialized = true;
    bytes32 public initializedBytes;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        whitelistedAddresses = new address[](1);
        whitelistedAddresses[0] = 0x1111111111111111111111111111111111111111; // Replace with actual address

        initializedBytes = bytes32('init');
    }

    function removeWhitelistedAddresses(address[] memory addresses) external {
        require(msg.sender == owner, ""Only the owner can remove addresses from the whitelist"");
        for (uint256 i = 0; i < addresses.length; i++) {
            address addr = addresses[i];
            uint256 index = whitelistedAddresses.indexOf(addr);
            if (index != -1) {
                whitelistedAddresses.removeAt(index);
            }
        }
    }
}"
3142,Get the token balance of ` tokenOwner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    mapping(address => uint256) public balances;

    constructor() {}

    function balanceOf(address tokenOwner) public view returns (uint256 balance) {
        return balances[tokenOwner];
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenOwner""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    function getTokenBalance(address tokenOwner) public view returns (uint256 balance) {
        return balances[tokenOwner];
    }
}",5.2789294719696045,getTokenBalance,"[{'function': 'getTokenBalance', 'complexity': 0}]",1.0,0.0,0.9125270580846724,0.8843946454355334,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is how you import Ownable from OpenZeppelin

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Use the owner address and set balance to 1
    }

    function getTokenBalance(address tokenOwner) public view returns (uint256 balance) {
        return balances[tokenOwner];
    }
}"
3096,This method can be used by the owner to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        MiniMeToken token = MiniMeToken(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","[{'function': 'claimTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""recoverTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Recovery failed""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'claimTokens', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

contract TokenRecovery {
    using SafeMath for uint256;

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function recoverTokens(address _tokenAddress, uint256 _amount) external onlyOwner {
        IERC20 token = IERC20(_tokenAddress);
        require(token.transfer(owner, _amount), ""Recovery failed"");
    }
}",2.315149068832397,recoverTokens,"[{'function': 'recoverTokens', 'complexity': 1}]",2.0,25.0,0.6578319937367099,0.0711605387103243,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenRecovery is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function recoverTokens(address _tokenAddress, uint256 _amount) external onlyOwner {
        IERC20 token = IERC20(_tokenAddress);
        require(token.transfer(owner, _amount), ""Recovery failed"");
    }
}"
6593,returns the trader of the given orderID .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderTraderWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address trader;
        // other order details...
    }

    mapping(bytes32 => Order) public orders;

    function orderTrader(bytes32 _orderID) external view returns (address) {
        return orders[_orderID].trader;
    }
}","[{'function': 'orderTrader', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTrader"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""orderID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_orderInfos""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderID""}}, ""memberName"": ""trader""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'orderTrader', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Order {
    using SafeMath for uint256;

    struct OrderInfo {
        address trader;
        uint256 orderID;
    }

    mapping(uint256 => OrderInfo) private _orderInfos;

    function getTrader(uint256 orderID) public view returns (address) {
        return _orderInfos[orderID].trader;
    }
}",2.3842523097991943,getTrader,"[{'function': 'getTrader', 'complexity': 0}]",1.0,0.0,0.8452734196184605,0.4169392927528885,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import for Ownable

contract Order is Ownable {
    using SafeMath for uint256;

    struct OrderInfo {
        address trader;
        uint256 orderID;
    }

    mapping(uint256 => OrderInfo) private _orderInfos;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            _orderInfos[i] = OrderInfo({trader: addr, orderID: i});
        }
    }

    function getTrader(uint256 orderID) public view returns (address) {
        return _orderInfos[orderID].trader;
    }
}"
2524,Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    bool public transfersEnabled;
    address public controller;
    mapping(address => mapping(address => uint256)) public allowed;

    constructor(address _controller, bool _transfersEnabled) {
        require(_controller != address(0), ""Controller must be set"");
        controller = _controller;
        transfersEnabled = _transfersEnabled;
    }

    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {
        if (msg.sender != controller) {
            require(transfersEnabled, ""Transfers are not enabled"");
            if (allowed[_from][msg.sender] < _amount) {
                return false;
            }
            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _amount);
        }
        require(_to != address(0), ""Invalid recipient address"");
        return IERC20(this).transferFrom(_from, _to, _amount);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 5}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isApprovedForAll""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Not approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeERC20""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 5}]",5.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transferFrom(address _from, address _to, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        require(_to != address(0), ""Invalid recipient"");
        require(_from == msg.sender || isApprovedForAll(_from, msg.sender), ""Not approved"");

        SafeERC20.safeTransferFrom(_from, _to, _amount);
    }
}",3.356918811798096,transferFrom,"[{'function': 'transferFrom', 'complexity': 4}]",5.0,25.0,0.9134326245886446,0.3657122853305719,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferFrom(address _from, address _to, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        require(_to != address(0), ""Invalid recipient"");
        require(_from == msg.sender || isApprovedForAll(_from, msg.sender), ""Not approved"");

        SafeERC20.safeTransferFrom(_from, _to, _amount);
    }
}"
4577,Approves `` _who '' to transfer `` _value '' tokens from `` msg.sender '' to any address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _who, uint256 _value) public returns (bool) {
        require(_who != address(0), ""Invalid address"");
        require(_value == 0 || allowed[msg.sender][_who] == 0, ""Allowance already granted"");
        allowed[msg.sender][_who] = _value;
        emit Approval(msg.sender, _who, _value);
        return true;
    }
}","[{'function': 'approve', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_who""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can approve transfers""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_who""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_who""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function approve(address _who, uint256 _value) public returns (bool) {
        require(_value > 0, ""Value must be greater than zero"");
        require(_who != address(0), ""Invalid address"");
        require(msg.sender == owner(), ""Only the owner can approve transfers"");

        uint256 currentAllowance = allowances[msg.sender][_who];
        require(currentAllowance >= _value, ""Insufficient allowance"");

        allowances[msg.sender][_who] = currentAllowance.sub(_value);
        return true;
    }
}",3.922596693038941,approve,"[{'function': 'approve', 'complexity': 4}]",5.0,34.0,0.9347516857791368,0.4492047714595446,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function approve(address _who, uint256 _value) public returns (bool) {
        require(_value > 0, ""Value must be greater than zero"");
        require(_who != address(0), ""Invalid address"");
        require(msg.sender == owner(), ""Only the owner can approve transfers"");

        uint256 currentAllowance = allowances[msg.sender][_who];
        require(currentAllowance >= _value, ""Insufficient allowance"");

        allowances[msg.sender][_who] = currentAllowance.sub(_value);
        return true;
    }
}"
6152,Whether price of asset has been updated less than VALIDITY seconds ago,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAssetInformation {
    function getTimestamp(address ofAsset) external view returns (uint256);
}

abstract contract AssetPriceChecker is Ownable {
    using SafeMath for uint256;

    struct Information {
        bool exists;
        uint256 timestamp;
    }

    mapping(address => Information) public information;
    uint256 public constant VALIDITY = 3600; // 1 hour in seconds

    function hasRecentPrice(address ofAsset) public view pre_cond(information[ofAsset].exists) returns (bool isRecent) {
        require(information[ofAsset].exists, ""Asset information does not exist"");
        return now.sub(information[ofAsset].timestamp).div(1 seconds) <= VALIDITY;
    }
}","[{'function': 'getTimestamp', 'complexity': 0}, {'function': 'hasRecentPrice', 'complexity': 1}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""isValid"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""asset"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""VALIDITY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""prices""}, ""index"": {""type"": ""Identifier"", ""name"": ""asset""}}, ""memberName"": ""timestamp""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""VALIDITY""}], ""names"": []}, ""memberName"": ""lt""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getTimestamp', 'complexity': 0}, {'function': 'hasRecentPrice', 'complexity': 1}]",7.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract AssetPrice {
    using SafeMath for uint256;

    struct Price {
        uint256 price;
        uint256 timestamp;
    }

    mapping(address => Price) public prices;

    function isValid(uint256 asset, uint256 VALIDITY) public view returns (bool) {
        return prices[asset].timestamp.add(VALIDITY).lt(block.timestamp);
    }
}",2.455812931060791,isValid,"[{'function': 'isValid', 'complexity': 0}]",1.0,22.0,0.6957227315001354,0.0485530632399978,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of adding Ownable functionality

contract AssetPrice is Ownable {
    using SafeMath for uint256;

    struct Price {
        uint256 price;
        uint256 timestamp;
    }

    mapping(address => Price) public prices;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            prices[addr] = Price({price: 1, timestamp: block.timestamp});
        }
    }

    function isValid(uint256 asset, uint256 VALIDITY) public view returns (bool) {
        return prices[asset].timestamp.add(VALIDITY).lt(block.timestamp);
    }
}"
4397,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransfersControl is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled = false;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""freeTransfer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""freeTransfer""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""value""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint256;

    struct Token {
        address owner;
        uint256 value;
    }

    mapping(address => Token) public tokens;

    function transferTokens(uint256 amount, bool freeTransfer) external {
        require(amount > 0, ""Invalid amount"");
        require(tokens[msg.sender].value >= amount, ""Insufficient balance"");

        if (freeTransfer) {
            tokens[msg.sender].value = tokens[msg.sender].value.sub(amount);
            tokens[msg.sender].owner = msg.sender;
        } else {
            tokens[msg.sender].value = tokens[msg.sender].value.add(amount);
            tokens[msg.sender].owner = msg.sender;
        }
    }
}",4.005904912948608,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,44.0,0.5313010407534339,0.0048622158795111,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Token {
        address owner;
        uint256 value;
    }

    mapping(address => Token) public tokens;

    function transferTokens(uint256 amount, bool freeTransfer) external {
        require(amount > 0, ""Invalid amount"");
        require(tokens[msg.sender].value >= amount, ""Insufficient balance"");

        if (freeTransfer) {
            tokens[msg.sender].value = tokens[msg.sender].value.sub(amount);
            tokens[msg.sender].owner = msg.sender;
        } else {
            tokens[msg.sender].value = tokens[msg.sender].value.add(amount);
            tokens[msg.sender].owner = msg.sender;
        }
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
6310,Set address of migration target contract and enable migration process,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MigrationAgentSetter {
    using SafeMath for uint256;

    address public migrationAgent;
    uint256 public totalMigrated;

    function setMigrationAgent(address _agent) external onlyOwner {
        require(migrationAgent == address(0x0) && totalMigrated == 0);
        migrationAgent = _agent;
    }
}","[{'function': 'setMigrationAgent', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMigrationTarget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_target""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid target address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""migrationTarget""}, ""right"": {""type"": ""Identifier"", ""name"": ""_target""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MigrationTargetSet""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_target""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setMigrationAgent', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

contract MigrationManager {
    address public migrationTarget;
    bool public migrationEnabled;
    address public owner;

    event MigrationTargetSet(address indexed target);
    event MigrationEnabled(bool enabled);

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    constructor() {
        owner = msg.sender;
        migrationEnabled = false;
    }

    function setMigrationTarget(address _target) external onlyOwner {
        require(_target != address(0), ""Invalid target address"");
        migrationTarget = _target;
        emit MigrationTargetSet(_target);
    }

    function setMigrationEnabled(bool _enabled) external onlyOwner {
        migrationEnabled = _enabled;
        emit MigrationEnabled(_enabled);
    }

    function isMigrationEnabled() external view returns (bool) {
        return migrationEnabled;
    }
}",1.4666376113891602,setMigrationTarget,"[{'function': 'setMigrationTarget', 'complexity': 1}, {'function': 'setMigrationEnabled', 'complexity': 0}, {'function': 'isMigrationEnabled', 'complexity': 0}]",2.0,8.0,0.7363870610297114,0.207936846119762,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MigrationManager is Ownable {
    address public migrationTarget;
    bool public migrationEnabled;

    event MigrationTargetSet(address indexed target);
    event MigrationEnabled(bool enabled);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Not the owner"");
        _;
    }

    constructor() Ownable() {
        migrationEnabled = false;
    }

    function setMigrationTarget(address _target) external onlyOwner {
        require(_target != address(0), ""Invalid target address"");
        migrationTarget = _target;
        emit MigrationTargetSet(_target);
    }

    function setMigrationEnabled(bool _enabled) external onlyOwner {
        migrationEnabled = _enabled;
        emit MigrationEnabled(_enabled);
    }

    function isMigrationEnabled() external view returns (bool) {
        return migrationEnabled;
    }
}"
4553,Allows user to mint if they have the appropriate permissions .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public blacklistedUsers;
    bool public paused = false;

    modifier userNotBlacklisted(address _user) {
        require(!blacklistedUsers[_user], ""User is blacklisted"");
        _;
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller does not have permission"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address _to, uint256 _amount) public userNotBlacklisted(_to) requiresPermission whenNotPaused {
        _mint(_to, _amount);
    }
}","[{'function': 'mint', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""to""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'mint', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract Mintable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function mint(address to, uint256 amount) external {
        require(msg.sender == owner);

        // Additional logic can be added here
        to.transfer(amount);
    }
}",1.8204131126403809,mint,"[{'function': 'mint', 'complexity': 1}]",2.0,9.0,0.7242893481219357,0.135157574904895,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Mintable is Ownable {
    uint256 public constant INITIAL_SUPPLY = 1;
    address public owner;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function mint(address to, uint256 amount) external {
        require(msg.sender == owner);

        // Additional logic can be added here
        to.transfer(amount);
    }
}"
4912,Used only if there are some leftover funds ( because of topUpBalance ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawBalance() public mustBeAtStage(Stage.Finalized) {
        wallet.transfer(address(this).balance);
    }
}","[{'function': 'withdrawBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawLeftoverFunds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'withdrawBalance', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function withdrawLeftoverFunds(uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        uint256 balance = address(this).balance.sub(amount);
        if (balance == 0) {
            // Withdraw all funds
            payable(msg.sender).transfer(address(this).balance);
        } else {
            // Withdraw only the leftover amount
            payable(msg.sender).transfer(amount);
        }
    }
}",3.6639890670776367,withdrawLeftoverFunds,"[{'function': 'withdrawLeftoverFunds', 'complexity': 2}]",3.0,29.0,0.6333631702417616,0.1248981374585523,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        someUint = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        someAddress = address(uint160(uint256(keccak256('address1'))));

        // bool: Set to true
        someBool = true;

        // string: Set to 'initialized'
        someString = ""initialized"";

        // bytes32: Set to bytes32('init')
        someBytes32 = bytes32(keccak256(""init""));
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function withdrawLeftoverFunds(uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        uint256 balance = address(this).balance.sub(amount);
        if (balance == 0) {
            // Withdraw all funds
            payable(msg.sender).transfer(address(this).balance);
        } else {
            // Withdraw only the leftover amount
            payable(msg.sender).transfer(amount);
        }
    }
}"
4727,This method MUST NEVER be called by smart contract code .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IGiftToken {
    function GiftsOfOwner(address _owner) external view returns (uint256[] memory);
}

abstract contract GiftWrapper is Ownable {
    using SafeMath for uint256;

    address public giftContractAddress;

    constructor(address _giftContractAddress) {
        giftContractAddress = _giftContractAddress;
    }

    function giftOwnerByIndex(uint256 _index) external view returns (uint256 GiftId) {
        IGiftToken giftToken = IGiftToken(giftContractAddress);
        uint256[] memory ownerGifts = giftToken.GiftsOfOwner(owner());
        require(_index < ownerGifts.length, ""Index out of bounds"");
        return ownerGifts[_index];
    }
}","[{'function': 'GiftsOfOwner', 'complexity': -2}, {'function': 'giftOwnerByIndex', 'complexity': 1}]",11.0,"{""type"": ""FunctionDefinition"", ""name"": ""myFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""input"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""input""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'GiftsOfOwner', 'complexity': -2}, {'function': 'giftOwnerByIndex', 'complexity': 1}]",13.0,"
pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint256;

    function myFunction(uint256 input) public pure returns (uint256) {
        return input.add(1);
    }
}",1.2511191368103027,myFunction,"[{'function': 'myFunction', 'complexity': 0}]",1.0,23.0,0.233272082881795,0.0217213082895616,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        someUint = 1;
        someAddress = address(0x111);
        someBool = true;
        someString = 'initialized';
        someBytes32 = bytes32('init');
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function myFunction(uint256 input) public pure returns (uint256) {
        return input.add(1);
    }
}"
5921,Hash ( keccak256 ) of the payload used by approvePreSigned,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovePreSignedHashingWrapper {
    using SafeMath for uint256;

    function approvePreSignedHashing(address _token, address _spender, uint256 _value, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(
            bytes4(0xf7ac9c2e),
            _token,
            _spender,
            _value,
            _fee,
            _nonce
        );
    }
}","[{'function': 'approvePreSignedHashing', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""add"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'approvePreSignedHashing', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }
}

contract ApprovePreSigned {
    using SafeMath for uint256;

    struct Payload {
        address owner;
        uint256 value;
        bytes32 hash;
    }

    function approvePreSigned(Payload memory payload) public view returns (bool) {
        return keccak256(abi.encodePacked(payload.owner, payload.value)) == payload.hash;
    }
}",3.044123888015747,add,"[{'function': 'add', 'complexity': 0}, {'function': 'approvePreSigned', 'complexity': 0}]",1.0,14.0,0.362668753594539,0.0316866705934703,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract ApprovePreSigned is Ownable {
    using SafeMath for uint256;

    struct Payload {
        address owner;
        uint256 value;
        bytes32 hash;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        payloads = new Payload[](3);
        payloads[0] = Payload({owner: 0x1111111111111111111111111111111111111111, value: 1, hash: bytes32('init')});
        payloads[1] = Payload({owner: 0x2222222222222222222222222222222222222222, value: 1, hash: bytes32('init')});
        payloads[2] = Payload({owner: 0x3333333333333333333333333333333333333333, value: 1, hash: bytes32('init')});
    }

    Payload[] public payloads;

    function approvePreSigned(Payload memory payload) public view returns (bool) {
        return keccak256(abi.encodePacked(payload.owner, payload.value)) == payload.hash;
    }
}"
5070,Withdraw ether and delete the htlc swap .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MultisigWallet is Ownable {
    using SafeMath for uint256;

    struct Multisig {
        uint unlockTime;
        address[] owners;
        mapping(address => bool) ownerMap;
        uint deposit;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;

    function spendFromMultisig(bytes32 msigId, uint amount, address owner) internal {
        // Implementation of spending from multisig logic
    }

    function timeoutResolve(bytes32 msigId, uint amount) public onlyOwner {
        require(hashIdToMultisig[msigId].deposit >= amount, ""Insufficient deposit"");
        require(block.timestamp >= hashIdToMultisig[msigId].unlockTime, ""Unlock time has not been reached"");
        spendFromMultisig(msigId, amount, hashIdToMultisig[msigId].owner);
    }
}","[{'function': 'spendFromMultisig', 'complexity': 0}, {'function': 'timeoutResolve', 'complexity': 2}]",3.0,{},"[{'function': 'spendFromMultisig', 'complexity': 0}, {'function': 'timeoutResolve', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract HTLC {
    using SafeMath for uint256;

    struct HTLCswap {
        address sender;
        address receiver;
        uint256 amount;
        bytes32 hashLock;
        uint256 timelock;
    }

    mapping(bytes32 => HTLCswap) public swaps;

    function withdrawEtherAndDeleteHTLCswap(address _sender, address _receiver, uint256 _amount, bytes32 _hashLock, uint256 _timelock) external {
        require(_sender == msg.sender);

        HTLCswap memory swap = swaps[_hashLock];
        require(swap.sender == _sender && swap.receiver == _receiver && swap.amount == _amount && swap.hashLock == _hashLock && swap.timelock > now);

        delete swaps[_hashLock];

        uint256 balance = address(this).balance;
        require(balance >= _amount);

        (bool success, ) = _receiver.call{value: _amount}("""");
        require(success);
    }
}",5.427290678024292,withdrawEtherAndDeleteHTLCswap,"[{'function': 'withdrawEtherAndDeleteHTLCswap', 'complexity': 5}]",9.0,38.0,0.4709885268392215,0.0563131016205393,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract HTLC is Ownable {
    using SafeMath for uint256;

    struct HTLCswap {
        address sender;
        address receiver;
        uint256 amount;
        bytes32 hashLock;
        uint256 timelock;
    }

    mapping(bytes32 => HTLCswap) public swaps;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function withdrawEtherAndDeleteHTLCswap(address _sender, address _receiver, uint256 _amount, bytes32 _hashLock, uint256 _timelock) external {
        require(_sender == msg.sender);

        HTLCswap memory swap = swaps[_hashLock];
        require(swap.sender == _sender && swap.receiver == _receiver && swap.amount == _amount && swap.hashLock == _hashLock && swap.timelock > now);

        delete swaps[_hashLock];

        uint256 balance = address(this).balance;
        require(balance >= _amount);

        (bool success, ) = _receiver.call{value: _amount}("""");
        require(success);
    }
}"
4823,Send tokens to multiple recipients on behalf of the address ` from ` The transaction will revert if any of the recipients is frozen .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    mapping(address => bool) public frozenAccounts;

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        require(!paused, ""Contract is already paused."");
        paused = false;
    }

    function freezeAccount(address account) external onlyOwner {
        frozenAccounts[account] = true;
    }

    function unfreezeAccount(address account) external onlyOwner {
        require(frozenAccounts[account], ""Account is not frozen."");
        delete frozenAccounts[account];
    }

    function operatorBatchSend(address _from, address[] memory _recipients, uint256[] memory _amounts, bytes memory _userData, bytes memory _operatorData) external whenNotPaused whenAccountNotFrozen(msg.sender) whenAccountNotFrozen(_from) {
        require(_recipients.length == _amounts.length, ""The lengths of _recipients and _amounts should be the same."");
        require(isOperatorFor(msg.sender, _from), ""Only operators can call this function"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            doSend(msg.sender, _from, _recipients[i], _amounts[i].mul(_amounts[i]), _userData, _operatorData, true);
        }
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused."");
        _;
    }

    modifier whenAccountNotFrozen(address account) {
        require(!frozenAccounts[account], ""Account is frozen."");
        _;
    }
}","[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 2}, {'function': 'freezeAccount', 'complexity': 0}, {'function': 'unfreezeAccount', 'complexity': 1}, {'function': 'operatorBatchSend', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isFrozen""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Sender is frozen""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isFrozen""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Recipient is frozen""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 2}, {'function': 'freezeAccount', 'complexity': 0}, {'function': 'unfreezeAccount', 'complexity': 1}, {'function': 'operatorBatchSend', 'complexity': 3}]",5.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    function sendTokens(address from, address[] memory recipients, uint256 amount) public {
        require(!isFrozen[from], ""Sender is frozen"");
        for (uint256 i = 0; i < recipients.length; i++) {
            require(!isFrozen[recipients[i]], ""Recipient is frozen"");
            address(recipients[i]).transfer(amount);
        }
    }
}",2.8169240951538086,sendTokens,"[{'function': 'sendTokens', 'complexity': 5}]",4.0,41.0,0.6340597830572096,0.1427745857120135,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public isFrozen;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        owner = msg.sender; // Assuming 'owner' is the state variable representing the contract owner
        // Initialize other state variables with safe, non-corner-case values:
        // uint256: Set to 1 (never 0)
        totalSupply = 1000000000000000000;
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        ownerAddress = msg.sender; // Assuming 'ownerAddress' is the state variable representing the contract owner's address
        // bool: Set to true
        initialized = true;
        // string: Set to 'initialized'
        tokenName = ""MyToken""; // Placeholder value for ERC20 uint256 public totalSupply;

 constructor argument
        // bytes32: Set to bytes32('init')
    }

    function sendTokens(address from, address[] memory recipients, uint256 amount) public {
        require(!isFrozen[from], ""Sender is frozen"");
        for (uint256 i = 0; i < recipients.length; i++) {
            require(!isFrozen[recipients[i]], ""Recipient is frozen"");
            address(recipients[i]).transfer(amount);
        }
    }
}"
4675,Used to launch the Module with the help of factory,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPolyToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract GeneralPermissionManager {
    constructor(address owner, address polyTokenAddress) {
        // Constructor implementation
    }
}

abstract contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    IPolyToken public polyToken;
    uint256 public setupCost;

    event GenerateModuleFromFactory(address indexed moduleAddress, string name, address factoryAddress, address sender, uint256 cost, uint256 timestamp);

    constructor(uint256 _setupCost, address _polyToken) {
        setupCost = _setupCost;
        polyToken = IPolyToken(_polyToken);
    }

    function deploy(bytes memory data) external returns (address) {
        if (setupCost > 0) {
            require(polyToken.transferFrom(msg.sender, owner(), setupCost), ""Failed transferFrom due to insufficient Allowance provided"");
        }
        address permissionManager = new GeneralPermissionManager{salt: bytes32(uint256(data))}(msg.sender, address(polyToken));
        emit GenerateModuleFromFactory(address(permissionManager), getName(), address(this), msg.sender, setupCost, block.timestamp);
        return permissionManager;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'deploy', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""launch"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""factory"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""factory""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Factory cannot be 0x0""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'deploy', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract Module is Ownable {
    using SafeMath for uint256;

    function launch(address factory) public onlyOwner {
        require(factory != address(0), ""Factory cannot be 0x0"");
        // Additional logic can be added here
    }
}",2.927903652191162,launch,"[{'function': 'launch', 'complexity': 1}]",2.0,15.0,0.4997438387461637,0.0082465506801228,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract Module is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function launch(address factory) public onlyOwner {
        require(factory != address(0), ""Factory cannot be 0x0"");
        // Additional logic can be added here
    }
}"
772,This should be public rather than external .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

    constructor(address _saleAuction, address _synthesizingAuction, address _geneSynthesis) {
        require(_saleAuction != address(0), ""Sale auction must be a valid address"");
        require(_synthesizingAuction != address(0), ""Synthesizing auction must be a valid address"");
        require(_geneSynthesis != address(0), ""Gene synthesis must be a valid address"");
        saleAuction = _saleAuction;
        synthesizingAuction = _synthesizingAuction;
        geneSynthesis = _geneSynthesis;
    }

    function unpause() public onlyOwner {
        require(saleAuction != address(0));
        require(synthesizingAuction != address(0));
        require(geneSynthesis != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}","[{'function': 'unpause', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""myFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""a""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'unpause', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;
contract MyContract {
    using SafeMath for uint256;
    function myFunction(uint256 a, uint256 b) public returns (uint256) {
        return a.add(b);
    }
}",1.267399549484253,myFunction,"[{'function': 'myFunction', 'complexity': 0}]",1.0,35.0,0.2457536492501118,0.0168384590033649,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    using SafeMath for uint256;

    // Initialize state variables to fixed, safe values
    uint256 public constant _INITIAL_VALUE = 1;
    address public constant _DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant _DEFAULT_BOOL = true;
    string public constant _DEFAULT_STRING = 'initialized';
    bytes32 public constant _DEFAULT_BYTES32 = bytes32('init');

    // Initialize Ownable contract
    constructor() Ownable(_DEFAULT_ADDRESS) {}

    function myFunction(uint256 a, uint256 b) public returns (uint256) {
        return a.add(b);
    }
}"
6429,Update the stored `` poaTokenMaster '' address to upgrade the PoaToken master contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PausableMock is Ownable {
    using SafeMath for uint256;

    address public saleAuction;
    address public synthesizingAuction;
    address public geneSynthesis;
    address public newContractAddress;

   function proxyChangeTokenMaster(address _newMaster) public returns (bool) {
    require(msg.sender == getContractAddress(""PoaManager""), ""Only the PoaManager contract can call this function"");
    require(_newMaster != address(0), ""Invalid new master address"");
    require(poaTokenMaster != _newMaster, ""New master address is the same as the current one"");
    require(isContract(_newMaster), ""New master address must be a contract"");

    address _oldMaster = poaTokenMaster;
    poaTokenMaster = _newMaster;
    emit ProxyUpgraded(_oldMaster, _newMaster);

    getContractAddress(""PoaLogger"").call(bytes4(keccak256(""logProxyUpgraded(address,address)"")), _oldMaster, _newMaster);

    return true;
}
}","[{'function': 'proxyChangeTokenMaster', 'complexity': 4}]",5.0,{},"[{'function': 'proxyChangeTokenMaster', 'complexity': 4}]",5.0,"contract PoaTokenUpgrade {
    using SafeMath for uint256;

    struct PoaTokenMaster {
        address addr;
        mapping(address => bool) authorizedAddresses;
    }

    event UpgradedPoaTokenMaster(address indexed previousMaster, address indexed newMaster);

    function upgradePoaTokenMaster(address newMaster) public {
        require(msg.sender == poaTokenMaster.addr, ""Only the current PoaToken master can upgrade"");
        require(!poaTokenMaster.authorizedAddresses[newMaster], ""New master must not be authorized already"");
        emit UpgradedPoaTokenMaster(poaTokenMaster.addr, newMaster);
        poaTokenMaster.addr = newMaster;
    }
}",3.393512487411499,upgradePoaTokenMaster,"[{'function': 'upgradePoaTokenMaster', 'complexity': 3}]",3.0,68.0,0.758955049537118,0.0466167573094963,"contract PoaTokenUpgrade {
    using SafeMath for uint256;

    struct PoaTokenMaster {
        address addr;
        mapping(address => bool) authorizedAddresses;
    }

    event UpgradedPoaTokenMaster(address indexed previousMaster, address indexed newMaster);

    constructor() Ownable(msg.sender) {
        poaTokenMaster.addr = 0x1111111111111111111111111111111111111111; // Replace with actual address
        poaTokenMaster.authorizedAddresses[msg.sender] = true;
    }

    PoaTokenMaster public poaTokenMaster;

    function upgradePoaTokenMaster(address newMaster) public {
        require(msg.sender == poaTokenMaster.addr, ""Only the current PoaToken master can upgrade"");
        require(!poaTokenMaster.authorizedAddresses[newMaster], ""New master must not be authorized already"");
        emit UpgradedPoaTokenMaster(poaTokenMaster.addr, newMaster);
        poaTokenMaster.addr = newMaster;
    }
}"
4411,Trust an address to perform recovery procedure for the caller .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function getHolderId(address holder) external view returns (uint);
    function isTrusted(address from, address to) external view returns (bool);
    function set(address store, bytes32 key, uint index, address value, bool trusted) external;
    function _emitErrorCode(uint errorCode) external pure returns (uint);
}

abstract contract TrustWrapper is Ownable {
    using SafeMath for uint;

    enum ErrorCodes {
        OK,
        CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF,
        CHRONOBANK_PLATFORM_ALREADY_TRUSTED
    }

    address public constant PLATFORM_ADDRESS = 0xYourPlatformContractAddress;
    ChronoBankPlatform platform = ChronoBankPlatform(PLATFORM_ADDRESS);

    function trust(address _to) public returns (uint) {
        uint fromId = _createHolderId(msg.sender);
        if (fromId == platform.getHolderId(_to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF);
        }
        if (platform.isTrusted(msg.sender, _to)) {
            return platform._emitErrorCode(ErrorCodes.CHRONOBANK_PLATFORM_ALREADY_TRUSTED);
        }
        platform.set(address(this), keccak256(abi.encodePacked(""holdersTrust"", fromId)), 0, _to, true);
        return ErrorCodes.OK;
    }

    function _createHolderId(address holder) internal view returns (uint) {
        // Implement your logic to create a unique ID for the holder
        return uint(keccak256(abi.encodePacked(holder)));
    }
}","[{'function': '_emitErrorCode', 'complexity': 0}, {'function': 'trust', 'complexity': 6}, {'function': '_createHolderId', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""recover"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recoveryData""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""trustedAddress""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only the trusted address can perform recovery""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recoveryData""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""isRecovering""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""The account is already being recovered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recoveryData""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""isRecovering""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_emitErrorCode', 'complexity': 0}, {'function': 'trust', 'complexity': 6}, {'function': '_createHolderId', 'complexity': 0}]",8.0,"
pragma solidity ^0.8.0;

contract Recovery {
    using SafeMath for uint256;

    struct RecoveryData {
        address trustedAddress;
        bool isRecovering;
    }

    mapping(address => RecoveryData) public recoveryData;

    function recover() external {
        require(recoveryData[msg.sender].trustedAddress == msg.sender, ""Only the trusted address can perform recovery"");
        require(!recoveryData[msg.sender].isRecovering, ""The account is already being recovered"");

        recoveryData[msg.sender].isRecovering = true;
    }
}",2.8376686573028564,recover,"[{'function': 'recover', 'complexity': 3}]",4.0,40.0,0.5032640094289931,0.0072513930278021,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Recovery is Ownable {
    using SafeMath for uint256;

    struct RecoveryData {
        address trustedAddress;
        bool isRecovering;
    }

    mapping(address => RecoveryData) public recoveryData;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            recoveryData[addr] = RecoveryData({trustedAddress: addr, isRecovering: false});
        }
    }

    function recover() external {
        require(recoveryData[msg.sender].trustedAddress == msg.sender, ""Only the trusted address can perform recovery"");
        require(!recoveryData[msg.sender].isRecovering, ""The account is already being recovered"");

        recoveryData[msg.sender].isRecovering = true;
    }
}"
2481,Destroy the vesting information associated with an account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    mapping(address => VestingSchedule) public vestingSchedules;
    mapping(address => uint256) public totalVestedAccountBalance;
    uint256 public totalVestedBalance;

    struct VestingSchedule {
        // Define the structure of a vesting schedule here
    }

    function purgeAccount(address account) external onlyOwner onlyDuringSetup {
        delete vestingSchedules[account];
        totalVestedBalance = totalVestedBalance.sub(totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
}","[{'function': 'purgeAccount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyVesting"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""accountAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""accountAddress""}}, ""memberName"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can destroy their vesting information""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""accountAddress""}}, ""isPrefix"": True}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'purgeAccount', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Vesting {
    struct Account {
        address owner;
        uint256 balance;
        bool locked;
        uint256 vestingStart;
        uint256 vestingEnd;
    }

    mapping(address => Account) public accounts;

    function destroyVesting(address accountAddress) external {
        require(accounts[accountAddress].owner == msg.sender, ""Only the owner can destroy their vesting information"");
        delete accounts[accountAddress];
    }
}",2.4047000408172607,destroyVesting,"[{'function': 'destroyVesting', 'complexity': 1}]",3.0,14.0,0.7360976507656919,0.0568513888173337,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Vesting is Ownable {
    struct Account {
        address owner;
        uint256 balance;
        bool locked;
        uint256 vestingStart;
        uint256 vestingEnd;
    }

    mapping(address => Account) public accounts;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            accounts[addr] = Account({
                owner: addr,
                balance: 1,
                locked: true,
                vestingStart: block.timestamp,
                vestingEnd: block.timestamp + 365 days
            });
        }
    }

    function destroyVesting(address accountAddress) external {
        require(accounts[accountAddress].owner == msg.sender, ""Only the owner can destroy their vesting information"");
        delete accounts[accountAddress];
    }
}"
4726,` finalizeSale ( ) ` ends the TokenSale .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function generateTokens(address, uint256) external returns (bool);
}

abstract contract VestedTokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public endTime;
    uint256 public totalIssued;
    uint256 public lockedTokens;
    uint256 public totalVested;
    uint256 public constant HARD_CAP = 100000 * 10**18; // Example hard cap, adjust as needed
    uint256 public constant MAX_TOKENS = 100000 * 10**18; // Example max tokens, adjust as needed
    bool public finalized;
    address public vaultAddress;
    TokenInterface public tokenContract;

    struct Vesting {
        uint256 amount;
        uint256 releaseTime;
    }

    mapping(address => Vesting) public vestedAllowances;

    function finalizeSale() public onlyOwner {
        require(block.timestamp > endTime || totalIssued >= HARD_CAP);
        require(!finalized, ""Sale has already been finalized"");

        vestedAllowances[vaultAddress] = Vesting(lockedTokens, block.timestamp + 3 years);

        uint256 leftoverTokens = MAX_TOKENS.sub(lockedTokens).sub(totalIssued).sub(totalVested);
        require(tokenContract.generateTokens(vaultAddress, leftoverTokens), ""Token transfer failed for vault"");
        require(tokenContract.generateTokens(address(this), lockedTokens.add(totalVested)), ""Token transfer failed for contract"");

        finalized = true;
    }
}","[{'function': 'generateTokens', 'complexity': 0}, {'function': 'finalizeSale', 'complexity': 6}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can end the sale""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'generateTokens', 'complexity': 0}, {'function': 'finalizeSale', 'complexity': 6}]",8.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract TokenSale {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function finalizeSale() external {
        require(msg.sender == owner, ""Only the contract owner can end the sale"");

        // Additional logic can be added here to handle any remaining tokens that have not been sold

        selfdestruct(owner);
    }
}",2.786536455154419,finalizeSale,"[{'function': 'finalizeSale', 'complexity': 1}]",2.0,59.0,0.7928711133439816,0.0291795457052966,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public balances;

    constructor() public Ownable(msg.sender) {
        owner = msg.sender;
        balances[msg.sender] = 1000; // Initialize with a fixed value
    }

    function finalizeSale() external {
        require(msg.sender == owner, ""Only the contract owner can end the sale"");

        // Additional logic can be added here to handle any remaining tokens that have not been sold

        selfdestruct(owner);
    }
}"
475,Release some of an affiliate 's tokens to a broker/trading wallet .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function transfer(address to, uint256 value) external returns (bool success);
}

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool isAffiliate;
    }

    mapping(address => Holding) public heldTokens;
    address public tokenContract;

    event TokensReleased(address indexed beneficiary, uint256 amount);

    modifier onlyTransferAgent() {
        require(hasRole(TRANSFER_AGENT_ROLE, msg.sender), ""Caller is not a transfer agent"");
        _;
    }

    function partialRelease(address who, address tradingWallet, uint256 amount) public onlyTransferAgent returns (bool) {
        require(tradingWallet != address(0), ""The destination wallet cannot be null."");
        require(!isExistingHolding(tradingWallet), ""The destination wallet must be a new fresh wallet."");
        Holding memory holding = heldTokens[who];
        require(holding.isAffiliate, ""Only affiliates can use this function; use release() for non-affiliates."");
        require(amount <= holding.quantity, ""The holding has less than the specified amount of tokens."");
        if (block.timestamp > holding.releaseDate) {
            bool res = ERC20Interface(tokenContract).transfer(tradingWallet, amount);
            if (res) {
                heldTokens[who] = Holding(holding.quantity.sub(amount), holding.releaseDate, holding.isAffiliate);
                emit TokensReleased(who, amount);
                return true;
            }
        }
        return false;
    }

    function isExistingHolding(address wallet) internal view returns (bool) {
        // Implement the logic to check if the wallet has an existing holding
        // This should be implemented based on your specific requirements and data storage
        return heldTokens[wallet].quantity > 0;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'partialRelease', 'complexity': 8}, {'function': 'isExistingHolding', 'complexity': 0}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""releaseTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""broker"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""affiliate""}}, {""type"": ""stringLiteral"", ""value"": ""Only the affiliate can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""broker""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'partialRelease', 'complexity': 8}, {'function': 'isExistingHolding', 'complexity': 0}]",9.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract AffiliateToken {
    using SafeMath for uint256;

    address public affiliate;
    uint256 public balance;

    function releaseTokens(address broker, uint256 amount) external {
        require(msg.sender == affiliate, ""Only the affiliate can call this function"");
        require(amount > 0, ""Invalid amount"");
        balance = balance.sub(amount);
        address(broker).transfer(amount);
    }
}",2.642196655273437,releaseTokens,"[{'function': 'releaseTokens', 'complexity': 2}]",3.0,35.0,0.6906201407328709,0.0385263860117203,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract AffiliateToken is Ownable {
    using SafeMath for uint256;

    address public affiliate;
    uint256 public balance;

    constructor() Ownable(msg.sender) {
        affiliate = 0x1111111111111111111111111111111111111111; // Replace with your affiliate address
        balance = 1; // Set to a fixed, safe value
    }

    function releaseTokens(address broker, uint256 amount) external {
        require(msg.sender == affiliate, ""Only the affiliate can call this function"");
        require(amount > 0, ""Invalid amount"");
        balance = balance.sub(amount);
        address(broker).transfer(amount);
    }
}"
1443,the method caller will have to claim ownership of regulators since regulators are claimable,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Regulator {
    function addValidator(address validator) external;
    function transferOwnership(address newOwner) external;
}

interface RegulatorProxy {
    function initialize(address regulatorImplementation) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public regulators;

    event CreatedRegulatorProxy(address indexed proxy, uint256 index);

    function createRegulatorProxy(address regulatorImplementation) public onlyOwner {
        require(regulatorImplementation != address(0), ""Invalid implementation address"");

        address proxy = address(new RegulatorProxy(regulatorImplementation));
        Regulator newRegulator = Regulator(proxy);
        newRegulator.addValidator(msg.sender);
        addAllPermissions(newRegulator);
        RegulatorProxy(proxy).transferOwnership(msg.sender);
        regulators.push(proxy);
        emit CreatedRegulatorProxy(proxy, getCount() - 1);
    }

    function getCount() public view returns (uint256) {
        return regulators.length;
    }

    function addAllPermissions(Regulator regulator) internal virtual {
        // Implement any necessary permission logic here
    }
}","[{'function': 'transferOwnership', 'complexity': 0}, {'function': 'initialize', 'complexity': 0}, {'function': 'createRegulatorProxy', 'complexity': 1}, {'function': 'getCount', 'complexity': 0}, {'function': 'addAllPermissions', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimRegulator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_regulatorId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_regulatorId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_regulatorId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""regulators""}, ""memberName"": ""length""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid regulator ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Regulator""}, ""name"": ""regulator"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""regulators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_regulatorId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""regulator""}, ""memberName"": ""claimed""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""stringLiteral"", ""value"": ""Regulator already claimed""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""regulator""}, ""memberName"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""_owner""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""regulator""}, ""memberName"": ""claimed""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferOwnership', 'complexity': 0}, {'function': 'initialize', 'complexity': 0}, {'function': 'createRegulatorProxy', 'complexity': 1}, {'function': 'getCount', 'complexity': 0}, {'function': 'addAllPermissions', 'complexity': 0}]",2.0,"
pragma solidity ^0.8.0;

contract RegulatorClaim {
    using SafeMath for uint256;

    struct Regulator {
        address owner;
        bool claimed;
    }

    mapping(address => Regulator) public regulators;

    function claimRegulator(address _owner, uint256 _regulatorId) public {
        require(_regulatorId > 0 && _regulatorId <= regulators.length, ""Invalid regulator ID"");
        Regulator storage regulator = regulators[_regulatorId];
        require(regulator.claimed == false, ""Regulator already claimed"");
        regulator.owner = _owner;
        regulator.claimed = true;
    }
}",3.170180082321167,claimRegulator,"[{'function': 'claimRegulator', 'complexity': 3}]",4.0,41.0,0.6357456054593584,0.0269310839777986,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RegulatorClaim is Ownable {
    using SafeMath for uint256;

    struct Regulator {
        address owner;
        bool claimed;
    }

    mapping(address => Regulator) public regulators;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            regulators[addr] = Regulator({owner: addr, claimed: false});
        }
    }

    function claimRegulator(address _owner, uint256 _regulatorId) public {
        require(_regulatorId > 0 && _regulatorId <= 3, ""Invalid regulator ID"");
        address regulatorAddr = address(uint160(_regulatorId));
        Regulator storage regulator = regulators[regulatorAddr];
        require(!regulator.claimed, ""Regulator already claimed"");
        regulator.owner = _owner;
        regulator.claimed = true;
    }
}"
6667,Compute the new IssuanceData on the old balance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IssuanceData {
    function currentBalanceSum() external view returns (uint);
    function lastAverageBalance() external view returns (uint);
    function lastModified() external view returns (uint);
}

abstract contract IssuanceWrapper is Ownable {
    using SafeMath for uint;

    struct IssuanceDataStruct {
        uint currentBalanceSum;
        uint lastAverageBalance;
        uint lastModified;
    }

    function computeIssuanceData(uint preBalance, IssuanceData preIssuance) internal view returns (IssuanceData) {
        uint currentBalanceSum = preIssuance.currentBalanceSum();
        uint lastAverageBalance = preIssuance.lastAverageBalance();
        uint lastModified = preIssuance.lastModified();

        if (lastModified < feePeriodStartTime()) {
            if (lastModified < lastFeePeriodStartTime()) {
                lastAverageBalance = preBalance;
            } else {
                uint timeUpToRollover = feePeriodStartTime() - lastModified;
                uint lastFeePeriodDuration = feePeriodStartTime() - lastFeePeriodStartTime();
                uint lastBalanceSum = currentBalanceSum.add(preBalance.mul(timeUpToRollover));
                lastAverageBalance = lastBalanceSum / lastFeePeriodDuration;
            }
            currentBalanceSum = preBalance.mul(now - feePeriodStartTime());
        } else {
            currentBalanceSum = currentBalanceSum.add(preBalance.mul(now - lastModified));
        }

        return IssuanceData(currentBalanceSum, lastAverageBalance, now);
    }

    uint public feePeriodStartTime;
    uint public lastFeePeriodStartTime;

    constructor() {
        // Initialize fee period start times or other necessary state variables here.
    }
}","[{'function': 'lastModified', 'complexity': -1}, {'function': 'computeIssuanceData', 'complexity': 9}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""computeNewIssuance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldBalance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBalance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Data""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Data""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newBalance""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""newBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldBalance""}], ""names"": []}], ""names"": [""balance"", ""issuance""]}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'lastModified', 'complexity': -1}, {'function': 'computeIssuanceData', 'complexity': 9}]",9.0,"
pragma solidity ^0.8.0;

contract IssuanceData {
    using SafeMath for uint256;

    struct Data {
        uint256 balance;
        uint256 issuance;
    }

    function computeNewIssuance(uint256 oldBalance, uint256 newBalance) public view returns (Data memory) {
        return Data({
            balance: newBalance,
            issuance: newBalance.sub(oldBalance)
        });
    }
}",2.474334716796875,computeNewIssuance,"[{'function': 'computeNewIssuance', 'complexity': 0}]",1.0,36.0,0.7330481890525853,0.0035813296928565,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract IssuanceData is Ownable {
    using SafeMath for uint256;

    struct Data {
        uint256 balance;
        uint256 issuance;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        balance = 1;
        issuance = 1;
    }

    uint256 private balance = 1;
    uint256 private issuance = 1;

    function computeNewIssuance(uint256 oldBalance, uint256 newBalance) public view returns (Data memory) {
        return Data({
            balance: newBalance,
            issuance: newBalance.sub(oldBalance)
        });
    }
}"
1283,"` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) internal allowances;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        require(approve(_spender, _amount), ""Approve failed"");
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Invalid block number"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid from""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid to""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TransferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

contract Approval {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public allowances;

    constructor() public {
        owner = msg.sender;
    }

    function approve(address _spender, uint256 _amount) public {
        require(_spender != address(0), ""Invalid spender"");
        require(_amount > 0, ""Invalid amount"");

        allowances[_spender] = allowances[_spender].add(_amount);

        emit Approval(msg.sender, _spender, _amount);
    }

    function transferFrom(address _from, address _to, uint256 _amount) public {
        require(_from != address(0), ""Invalid from"");
        require(_to != address(0), ""Invalid to"");
        require(_amount > 0, ""Invalid amount"");

        allowances[_from] = allowances[_from].sub(_amount);

        emit TransferFrom(_from, _to, _amount);
    }
}",5.13233757019043,transferFrom,"[{'function': 'approve', 'complexity': 2}, {'function': 'transferFrom', 'complexity': 3}]",4.0,24.0,0.3193030592335678,0.0374388546586133,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Approval is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => uint256) public allowances;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        owner = msg.sender;
    }

    function approve(address _spender, uint256 _amount) public {
        require(_spender != address(0), ""Invalid spender"");
        require(_amount > 0, ""Invalid amount"");

        allowances[_spender] = allowances[_spender].add(_amount);

        emit Approval(msg.sender, _spender, _amount);
    }

    function transferFrom(address _from, address _to, uint256 _amount) public {
        require(_from != address(0), ""Invalid from"");
        require(_to != address(0), ""Invalid to"");
        require(_amount > 0, ""Invalid amount"");

        allowances[_from] = allowances[_from].sub(_amount);

        emit TransferFrom(_from, _to, _amount);
    }
}"
6724,Adds a pair of addresses to manual blockings,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct ManualBlocking {
        uint256 expiryTime;
    }

    mapping(address => mapping(address => ManualBlocking)) public manualBlockings;

    event AddManualBlocking(address indexed from, address indexed to, uint256 expiryTime, address approver);

    function addManualBlocking(address _from, address _to, uint256 _expiryTime) public onlyOwner {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_expiryTime > block.timestamp, ""Invalid expiry time"");
        require(manualBlockings[_from][_to].expiryTime == 0, ""Blocking already exists"");
        manualBlockings[_from][_to] = ManualBlocking(_expiryTime);
        emit AddManualBlocking(_from, _to, _expiryTime, msg.sender);
    }
}","[{'function': 'addManualBlocking', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""addBlockedPair"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_firstAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_secondAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_firstAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""First address cannot be 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_secondAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Second address cannot be 0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""BlockedPair""}, ""name"": ""pair"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BlockedPair""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_firstAddress""}, {""type"": ""Identifier"", ""name"": ""_secondAddress""}], ""names"": [""firstAddress"", ""secondAddress""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""blockedPairs""}, ""index"": {""type"": ""Identifier"", ""name"": ""_firstAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""pair""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'addManualBlocking', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;

contract ManualBlocking {
    using SafeMath for uint256;

    struct BlockedPair {
        address firstAddress;
        address secondAddress;
    }

    mapping(address => BlockedPair) public blockedPairs;

    function addBlockedPair(address _firstAddress, address _secondAddress) external {
        require(_firstAddress != address(0), ""First address cannot be 0"");
        require(_secondAddress != address(0), ""Second address cannot be 0"");

        BlockedPair memory pair = BlockedPair({
            firstAddress: _firstAddress,
            secondAddress: _secondAddress
        });

        blockedPairs[_firstAddress] = pair;
    }
}",3.3835878372192383,addBlockedPair,"[{'function': 'addBlockedPair', 'complexity': 2}]",3.0,32.0,0.5382823613299987,0.1708544039376279,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ManualBlocking is Ownable {
    using SafeMath for uint256;

    struct BlockedPair {
        address firstAddress;
        address secondAddress;
    }

    mapping(address => BlockedPair) public blockedPairs;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            blockedPairs[addr] = BlockedPair({
                firstAddress: addr,
                secondAddress: addr
            });
        }
    }

    function addBlockedPair(address _firstAddress, address _secondAddress) external {
        require(_firstAddress != address(0), ""First address cannot be 0"");
        require(_secondAddress != address(0), ""Second address cannot be 0"");

        BlockedPair memory pair = BlockedPair({
            firstAddress: _firstAddress,
            secondAddress: _secondAddress
        });

        blockedPairs[_firstAddress] = pair;
    }
}"
2869,this function lets arbitrator withdraw DAI to the provided address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract DAIWrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public DAI;

    event DAIWithdrawn(address indexed receiver, uint256 amount);

    constructor(address _daiAddress) {
        require(_daiAddress != address(0), ""Invalid DAI contract address"");
        DAI = IERC20(_daiAddress);
    }

    function withdrawDAI(address _receiver, uint256 _amount) public onlyOwner {
        require(_receiver != address(0), ""Invalid receiver address"");
        require(_amount > 0, ""Invalid amount"");
        require(DAI.balanceOf(address(this)) >= _amount, ""Insufficient balance"");
        DAI.transfer(_receiver, _amount);
        emit DAIWithdrawn(_receiver, _amount);
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'withdrawDAI', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawDAI"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'withdrawDAI', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

contract Arbitrator {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    function withdrawDAI(address _to, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        require(balances[_to] >= _amount, ""Insufficient balance"");

        balances[_to] = balances[_to].sub(_amount);
    }
}",2.292768955230713,withdrawDAI,"[{'function': 'withdrawDAI', 'complexity': 2}]",3.0,23.0,0.8965077182906855,0.3132769174982777,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Arbitrator is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function withdrawDAI(address _to, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        require(balances[_to] >= _amount, ""Insufficient balance"");

        balances[_to] = balances[_to].sub(_amount);
    }
}"
3748,Get the node at the end of a double linked list .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address next;
        address previous;
    }

    mapping(uint256 => Node) public list;

    function end(List storage self) internal view returns (address) {
        return self.list[0].previous;
    }
}","[{'function': 'end', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLastNode"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Node""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""List is empty""}], ""names"": []}}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'end', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract DoubleLinkedList {
    using SafeMath for uint256;

    struct Node {
        uint256 value;
        address next;
        address previous;
    }

    mapping(address => Node) public nodes;

    function getLastNode() public view returns (Node memory) {
        require(nodes.length > 0, ""List is empty"");
        return nodes[nodes.length - 1];
    }
}",2.423379421234131,getLastNode,"[{'function': 'getLastNode', 'complexity': 1}]",2.0,14.0,0.5267208973220722,0.0497074547280084,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract DoubleLinkedList is Ownable {
    using SafeMath for uint256;

    struct Node {
        uint256 value;
        address next;
        address previous;
    }

    mapping(address => Node) public nodes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            nodes[addr] = Node({value: uint256(i), next: address(0), previous: address(0)});
        }
    }

    function getLastNode() public view returns (Node memory) {
        require(nodes.length > 0, ""List is empty"");
        return nodes[nodes.length - 1];
    }
}"
1053,Updates the board status according to the players score .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGame {
    function calculateBoardScore(uint boardId) external view returns (uint8 blackScore, uint8 whiteScore);
    function updateBoardStatus(uint boardId, BoardStatus status) external;
}

abstract contract GameWrapper is Ownable {
    using SafeMath for uint256;

    struct Board {
        bool exists;
        BoardStatus status;
    }

    mapping(uint => Board) public boards;

    IGame public gameContract;

    event BoardCreated(uint boardId, BoardStatus initialStatus);

    constructor(address _gameContractAddress) {
        gameContract = IGame(_gameContractAddress);
    }

    modifier boardWaitingToResolve(uint boardId) {
        require(boards[boardId].exists, ""Board does not exist"");
        require(boards[boardId].status == BoardStatus.Pending, ""Board status is not pending"");
        _;
    }

    function createBoard(uint boardId, BoardStatus initialStatus) external onlyOwner {
        require(!boards[boardId].exists, ""Board already exists"");
        boards[boardId] = Board({exists: true, status: initialStatus});
        emit BoardCreated(boardId, initialStatus);
    }

    function checkVictoryByScore(uint boardId) external boardWaitingToResolve(boardId) {
        uint8 blackScore;
        uint8 whiteScore;
        (blackScore, whiteScore) = gameContract.calculateBoardScore(boardId);
        BoardStatus status = BoardStatus.Draw;
        if (blackScore > whiteScore) {
            status = BoardStatus.BlackWin;
        } else if (whiteScore > blackScore) {
            status = BoardStatus.WhiteWin;
        }
        gameContract.updateBoardStatus(boardId, status);
    }
}","[{'function': 'updateBoardStatus', 'complexity': 0}, {'function': 'createBoard', 'complexity': 2}, {'function': 'checkVictoryByScore', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateBoardStatus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""players""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""players""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""score""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""players""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""hasWon""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""players""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""hasWon""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updateBoardStatus', 'complexity': 0}, {'function': 'createBoard', 'complexity': 2}, {'function': 'checkVictoryByScore', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;

contract Game {
    struct Player {
        uint256 score;
        bool hasWon;
    }

    mapping(address => Player) public players;

    function updateBoardStatus() public {
        for (uint256 i = 0; i < players.length; i++) {
            if (players[i].score > 100) {
                players[i].hasWon = true;
            } else {
                players[i].hasWon = false;
            }
        }
    }
}",2.690269708633423,updateBoardStatus,"[{'function': 'updateBoardStatus', 'complexity': 3}]",3.0,33.0,0.6769401356628775,0.0133890074746028,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Game is Ownable {
    struct Player {
        uint256 score;
        bool hasWon;
    }

    mapping(address => Player) public players;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            players[addr] = Player({score: 1, hasWon: false});
        }
    }

    function updateBoardStatus() public {
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            if (players[addr].score > 100) {
                players[addr].hasWon = true;
            } else {
                players[addr].hasWon = false;
            }
        }
    }
}"
963,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721 {
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

abstract contract WrappedERC721 is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public approvedOperators;

    event OperatorApproval(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external onlyOwner {
        approvedOperators[_operator] = _approved;
        emit OperatorApproval(_msgSender(), _operator, _approved);
    }

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return approvedOperators[_operator];
    }
}","[{'function': 'isApprovedForAll', 'complexity': 0}, {'function': 'setApprovalForAll', 'complexity': 0}, {'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isAuthorizedOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""OPERATOR_ROLE""}, {""type"": ""Identifier"", ""name"": ""operator""}], ""names"": []}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getApproved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""operator""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isApprovedForAll', 'complexity': 0}, {'function': 'setApprovalForAll', 'complexity': 0}, {'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeMath.sol"";

contract AuthorizedOperator is Context, AccessControl {
    using SafeMath for uint256;

    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR"");

    constructor() public {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function isAuthorizedOperator(address operator, address owner) external view returns (bool) {
        return hasRole(OPERATOR_ROLE, operator) && getApproved(owner) == operator;
    }
}",8.018709897994995,isAuthorizedOperator,"[{'function': 'isAuthorizedOperator', 'complexity': 0}]",2.0,13.0,0.6866795937616932,0.0246762841977017,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AuthorizedOperator is Context, AccessControl, Ownable {
    using SafeMath for uint256;

    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR"");

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        transferOwnership(msg.sender); // Ensure the owner is set correctly
    }

    function isAuthorizedOperator(address operator, address owner) external view returns (bool) {
        return hasRole(OPERATOR_ROLE, operator) && getApproved(owner) == operator;
    }
}"
3793,Create an invite using the signing model described in the contract description,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InviteCreator is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public pendingInvites;
    address public signingLogic;

    event InviteCreated(address indexed user, address indexed inviteAddress);

    modifier onlyUser() {
        require(msg.sender != owner(), ""Owner cannot create invites"");
        _;
    }

    function setSigningLogic(address _signingLogic) public onlyOwner {
        signingLogic = _signingLogic;
    }

    function createInvite(bytes memory _sig) public onlyUser {
        require(signingLogic != address(0), ""Signing logic not set"");
        address inviteAddress = signingLogic.call(abi.encodeWithSelector(this.recoverSigner.selector, keccak256(abi.encodePacked(msg.sender)), _sig));
        require(!pendingInvites[inviteAddress], ""Invite already created"");
        pendingInvites[inviteAddress] = true;
        emit InviteCreated(msg.sender, inviteAddress);
    }

    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        return ECDSA.recover(hash, signature);
    }
}","[{'function': 'setSigningLogic', 'complexity': 0}, {'function': 'createInvite', 'complexity': 3}, {'function': 'recoverSigner', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createInvite"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_inviter"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_invitee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_expirationTimestamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_inviter""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid inviter""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_invitee""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid invitee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_expirationTimestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Expired invitation""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Invitation""}, ""name"": ""invitation"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Invitation""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_inviter""}, {""type"": ""Identifier"", ""name"": ""_invitee""}, {""type"": ""Identifier"", ""name"": ""_expirationTimestamp""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": [""inviter"", ""invitee"", ""expirationTimestamp"", ""isActive""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""invitations""}, ""index"": {""type"": ""Identifier"", ""name"": ""_inviter""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""invitation""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setSigningLogic', 'complexity': 0}, {'function': 'createInvite', 'complexity': 3}, {'function': 'recoverSigner', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Invite {
    using SafeMath for uint256;

    struct Invitation {
        address inviter;
        address invitee;
        uint256 expirationTimestamp;
        bool isActive;
    }

    mapping(address => Invitation[]) public invitations;

    function createInvite(address _inviter, address _invitee, uint256 _expirationTimestamp) public {
        require(_inviter != address(0), ""Invalid inviter"");
        require(_invitee != address(0), ""Invalid invitee"");
        require(_expirationTimestamp > block.timestamp, ""Expired invitation"");

        Invitation memory invitation = Invitation({
            inviter: _inviter,
            invitee: _invitee,
            expirationTimestamp: _expirationTimestamp,
            isActive: true
        });

        invitations[_inviter].push(invitation);
    }
}",4.561088562011719,createInvite,"[{'function': 'createInvite', 'complexity': 3}]",4.0,35.0,0.7795443737554156,0.1575852175693991,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract Invite is Ownable {
    using SafeMath for uint256;

    struct Invitation {
        address inviter;
        address invitee;
        uint256 expirationTimestamp;
        bool isActive;
    }

    mapping(address => Invitation[]) public invitations;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function createInvite(address _inviter, address _invitee, uint256 _expirationTimestamp) public {
        require(_inviter != address(0), ""Invalid inviter"");
        require(_invitee != address(0), ""Invalid invitee"");
        require(_expirationTimestamp > block.timestamp, ""Expired invitation"");

        Invitation memory invitation = Invitation({
            inviter: _inviter,
            invitee: _invitee,
            expirationTimestamp: _expirationTimestamp,
            isActive: true
        });

        invitations[_inviter].push(invitation);
    }
}"
3662,Allow pre-approved user to take ownership of a token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToOwner;

    function takeOwnership(uint256 _tokenId) public override {
        address newOwner = msg.sender;
        address oldOwner = allStarIndexToOwner[_tokenId];
        require(_addressNotNull(newOwner), ""Address should not be null"");
        require(_approved(newOwner, _tokenId), ""Token is not approved for transfer"");
        _transfer(oldOwner, newOwner, _tokenId);
    }

    function _addressNotNull(address addr) internal pure returns (bool) {
        return addr != address(0);
    }

    function _approved(address operator, uint256 tokenId) internal view returns (bool) {
        // Assuming there's a way to check if the operator is approved for the tokenId
        // This should be implemented based on your contract logic
        return true; // Placeholder implementation
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(to != address(0), ""Transfer to zero address"");
        allStarIndexToOwner[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
}","[{'function': 'takeOwnership', 'complexity': 2}, {'function': '_addressNotNull', 'complexity': 0}, {'function': '_approved', 'complexity': 0}, {'function': '_transfer', 'complexity': 1}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'takeOwnership', 'complexity': 2}, {'function': '_addressNotNull', 'complexity': 0}, {'function': '_approved', 'complexity': 0}, {'function': '_transfer', 'complexity': 1}]",4.0,"pragma solidity ^0.8.0;

contract Token {
    address public owner;
    mapping(address => bool) public approvedOwners;

    constructor() public {
        owner = msg.sender;
    }

    function approveOwner(address _owner) public {
        require(_owner != address(0), ""Invalid owner"");
        approvedOwners[_owner] = true;
    }

    function takeOwnership() public {
        require(approvedOwners[msg.sender], ""Not an approved owner"");
        owner = msg.sender;
    }
}",3.679531812667847,approveOwner,"[{'function': 'approveOwner', 'complexity': 1}, {'function': 'takeOwnership', 'complexity': 1}]",2.0,26.0,0.6035281095341288,0.0101788997142267,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Token {
    address public owner;
    mapping(address => bool) public approvedOwners;

    constructor() {
        owner = msg.sender;
    }

    function approveOwner(address _owner) public {
        require(_owner != address(0), ""Invalid owner"");
        approvedOwners[_owner] = true;
    }

    function takeOwnership() public {
        require(approvedOwners[msg.sender], ""Not an approved owner"");
        owner = msg.sender;
    }
}"
4592,Function use to change the lower and upper bound of the compatible version st,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function changeSTVersionBounds(string memory _boundType, uint8[] memory _newVersion) external onlyOwner {
        // Implementation of the function
    }
}","[{'function': 'changeSTVersionBounds', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCompatibleVersionBounds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_lowerBound"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_upperBound"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_lowerBound""}, ""right"": {""type"": ""Identifier"", ""name"": ""_upperBound""}}, {""type"": ""stringLiteral"", ""value"": ""Lower bound must be less than upper bound""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""compatibleVersionBounds""}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""_lowerBound""}, {""type"": ""Identifier"", ""name"": ""_upperBound""}], ""isArray"": False}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changeSTVersionBounds', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function setCompatibleVersionBounds(uint256 _lowerBound, uint256 _upperBound) public {
        require(_lowerBound < _upperBound, ""Lower bound must be less than upper bound"");
        compatibleVersionBounds = (_lowerBound, _upperBound);
    }
}",6.564205884933472,setCompatibleVersionBounds,"[{'function': 'setCompatibleVersionBounds', 'complexity': 1}]",2.0,20.0,0.579645317981236,0.0080713645324799,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract MyContract is Ownable {
    using SafeMath for uint256;

    struct VersionBounds {
        uint256 lowerBound;
        uint256 upperBound;
    }

    VersionBounds public compatibleVersionBounds;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        compatibleVersionBounds = VersionBounds({
            lowerBound: 1,
            upperBound: 1
        });
    }

    function setCompatibleVersionBounds(uint256 _lowerBound, uint256 _upperBound) public {
        require(_lowerBound < _upperBound, ""Lower bound must be less than upper bound"");
        compatibleVersionBounds = VersionBounds({
            lowerBound: _lowerBound,
            upperBound: _upperBound
        });
    }
}"
6054,Only the owner of a locked wallet can unlock the tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UnlockFunctionWrapper is Ownable {
    using SafeMath for uint256;

    struct Allocation {
        bool locked;
        uint256 value;
        uint256 end;
    }

    mapping(address => Allocation) public allocations;
    mapping(address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unlock(address indexed account, address indexed sender, uint256 value);

    function unlock() external {
        require(allocations[msg.sender].locked, ""Allocation is not locked"");
        require(block.timestamp >= allocations[msg.sender].end, ""Unlock time has not arrived yet"");
        balanceOf[msg.sender] = balanceOf[msg.sender].add(allocations[msg.sender].value);
        allocations[msg.sender].locked = false;
        emit Transfer(address(this), msg.sender, allocations[msg.sender].value);
        emit Unlock(msg.sender, address(this), allocations[msg.sender].value);
    }
}","[{'function': 'unlock', 'complexity': 2}]",3.0,{},"[{'function': 'unlock', 'complexity': 2}]",3.0,"contract LockedWallet {
    address public owner;
    uint256 public balance;

    constructor(address _owner) public {
        owner = _owner;
        balance = 0;
    }

    function unlockTokens() external onlyOwner {
        // Additional logic can be added here
    }
}",1.4641005992889404,unlockTokens,"[{'function': 'unlockTokens', 'complexity': 0}]",1.0,75.0,0.7033492076207476,0.0024288748295735,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LockedWallet is Ownable {
    address public owner;
    uint256 public balance;

    constructor(address _owner) Ownable() {
        require(_owner != address(0), ""Invalid owner address"");
        owner = _owner;
        balance = 1; // Set to a non-zero value for safety
    }

    function unlockTokens() external onlyOwner {
        // Additional logic can be added here
    }
}"
6003,Proxy function which allows sending of transactions in behalf of the contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransactionExecutor is Ownable {
    using SafeMath for uint256;

    event Execution(address indexed destination, uint256 value, bytes data);
    event ExecutionFailure(address indexed destination, uint256 value, bytes data);

    function executeTransaction(address destination, uint value, bytes memory data) public onlyOwner {
        if (destination.call{value: value}(data)) {
            emit Execution(destination, value, data);
        } else {
            emit ExecutionFailure(destination, value, data);
        }
    }
}","[{'function': 'executeTransaction', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTransactionInBehalfOfContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedUsers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, {""type"": ""stringLiteral"", ""value"": ""Only authorized users can call this function""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'executeTransaction', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract Proxy {
    using SafeMath for uint256;

    address private owner;
    mapping(address => bool) public authorizedUsers;

    constructor() public {
        owner = msg.sender;
        authorizedUsers[owner] = true;
    }

    function sendTransactionInBehalfOfContract(address _from, uint256 _value, address _to, bytes memory _data) external returns (bool) {
        require(authorizedUsers[_from], ""Only authorized users can call this function"");
        return true;
    }
}",4.972560167312622,sendTransactionInBehalfOfContract,"[{'function': 'sendTransactionInBehalfOfContract', 'complexity': 1}]",2.0,22.0,0.5774990650145245,0.03071884838773,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists in a standard library or path

contract Proxy is Ownable {
    using SafeMath for uint256;

    address private _owner = msg.sender;
    mapping(address => bool) public authorizedUsers;

    constructor() Ownable(_owner) {
        authorizedUsers[_owner] = true;
    }

    function sendTransactionInBehalfOfContract(address _from, uint256 _value, address _to, bytes memory _data) external returns (bool) {
        require(authorizedUsers[_from], ""Only authorized users can call this function"");
        return true;
    }
}"
1262,Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract OperatorSendWrapper is Ownable {
    using SafeMath for uint256;

    function operatorSend(address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) external {
        require(isOperatorFor(msg.sender, _from), ""Not authorized to send from this account"");
        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);
    }
}","[{'function': 'operatorSend', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""to""}}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'operatorSend', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    function transfer(address from, address to, uint256 amount) public {
        require(msg.sender == from || msg.sender == to);
        IERC20 token = IERC20(from);
        token.transferFrom(from, to, amount);
    }
}",3.4197258949279785,transfer,"[{'function': 'transfer', 'complexity': 2}]",3.0,20.0,0.6073826479361689,0.0440468296612163,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transfer(address from, address to, uint256 amount) public {
        require(msg.sender == from || msg.sender == to);
        IERC20 token = IERC20(from);
        token.transferFrom(from, to, amount);
    }
}"
4646,Returns the bond of a given darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeRegistryInterface {
    function darknodeBond(address darknodeID) external view returns (uint256);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address) public darknodeRegistries;

    constructor() {}

    function darknodeBond(address darknodeID, address darknodeRegistryAddress) external view returns (uint256) {
        require(darknodeRegistries[darknodeRegistryAddress] != address(0), ""Darknode registry not set"");
        DarknodeRegistryInterface darknodeRegistry = DarknodeRegistryInterface(darknodeRegistryAddress);
        return darknodeRegistry.darknodeBond(darknodeID);
    }
}","[{'function': 'darknodeBond', 'complexity': 0}, {'function': 'darknodeBond', 'complexity': 1}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""getDarknodeBond"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""darknodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""bond""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'darknodeBond', 'complexity': 0}, {'function': 'darknodeBond', 'complexity': 1}]",10.0,"pragma solidity ^0.8.0;
import ""SafeMath.sol"";

contract Darknodes {
    using SafeMath for uint256;

    struct Darknode {
        address owner;
        string name;
        uint256 bond;
    }

    mapping(address => Darknode) public darknodes;

    function getDarknodeBond(address _owner) external view returns (uint256) {
        return darknodes[_owner].bond;
    }
}",2.32514762878418,getDarknodeBond,"[{'function': 'getDarknodeBond', 'complexity': 0}]",1.0,20.0,0.7727393550415403,0.07928040088482,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for an Ownable contract

contract Darknodes is Ownable {
    using SafeMath for uint256;

    struct Darknode {
        address owner;
        string name;
        uint256 bond;
    }

    mapping(address => Darknode) public darknodes;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
        darknodes[msg.sender] = Darknode({owner: msg.sender, name: ""initialized"", bond: 1});
    }

    function getDarknodeBond(address _owner) external view returns (uint256) {
        return darknodes[_owner].bond;
    }
}"
476,Transfer ` _value ` SAT tokens from sender 's account ` msg.sender ` to provided account address ` _to ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfer(address _to, uint256 _value) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    bool public funding_ended = false;
    address public founders;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(!funding_ended, ""Funding has ended"");
        require(msg.sender != founders, ""Founders cannot transfer tokens"");
        uint256 senderBalance = balances[msg.sender];
        require(senderBalance >= _value && _value > 0, ""Insufficient balance or invalid value"");

        balances[msg.sender] = safeSub(senderBalance, _value);
        balances[_to] = safeAdd(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}]",5.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract SATToken {
    using SafeMath for uint256;

    mapping (address => uint256) public balances;

    function transfer(uint256 _value, address _to) public returns (bool) {
        require(_to != address(0), ""Invalid recipient"");
        require(_value <= balances[msg.sender], ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        return true;
    }
}",3.7212727069854736,transfer,"[{'function': 'transfer', 'complexity': 2}]",3.0,33.0,0.8807883099062183,0.2449923964408612,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract SATToken is Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Use the owner's balance as a fixed value of 1
    }

    function transfer(uint256 _value, address _to) public returns (bool) {
        require(_to != address(0), ""Invalid recipient"");
        require(_value <= balances[msg.sender], ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        return true;
    }
}"
2119,Returns the order amount for trader ` _trader ` at '_price ',"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function getAmount(uint _price, address _trader) public pure returns (uint) {
        return _price;
    }
}","[{'function': 'getAmount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getOrderAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_trader"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_price""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_trader""}, ""memberName"": ""balance""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getAmount', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function getOrderAmount(address _trader, uint256 _price) public view returns (uint256) {
        // Additional logic can be added here
        return _price.mul(_trader.balance);
    }
}",2.4603755474090576,getOrderAmount,"[{'function': 'getOrderAmount', 'complexity': 0}]",1.0,4.0,0.8162795180142841,0.0303764308951931,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getOrderAmount(address _trader, uint256 _price) public view returns (uint256) {
        // Additional logic can be added here
        return _price.mul(_trader.balance);
    }
}"
3447,Set the Synth contract that the issuance controller uses to issue Synths .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    Synth public synth;

    event SynthUpdated(Synth indexed synth);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function setSynth(Synth _synth) external onlyOwner {
        synth = _synth;
        emit SynthUpdated(_synth);
    }
}","[{'function': 'setSynth', 'complexity': 0}]",1.0,{},"[{'function': 'setSynth', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract IssuanceController {
    using SafeMath for uint256;

    function setSynthContract(address _synthAddress) public {
        // Additional logic can be added here
    }
}",1.2129292488098145,setSynthContract,"[{'function': 'setSynthContract', 'complexity': 0}]",1.0,14.0,0.693912041421611,0.0152490092654104,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract IssuanceController is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setSynthContract(address _synthAddress) public {
        // Additional logic can be added here
    }
}"
2394,Migrate tokens to the new token contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MigrationAgent {
    function migrateFrom(address _from, uint256 _value) external;
}

event Migrate(address indexed from, address indexed agent, uint256 value);

abstract contract MigrableToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    uint256 public totalMigrated;
    address public migrationAgent;

    function migrate(uint256 _value) external {
        if (migrationAgent == address(0)) revert();
        if (_value == 0) revert();
        if (_value > balances[msg.sender]) revert();
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalMigrated = totalMigrated.add(_value);
        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);
        emit Migrate(msg.sender, migrationAgent, _value);
    }
}","[{'function': 'migrateFrom', 'complexity': 0}, {'function': 'migrate', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""migrateTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldTokenContract""}], ""names"": []}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldTokenContract""}], ""names"": []}, ""memberName"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldTokenContract""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newTokenContract""}], ""names"": []}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'migrateFrom', 'complexity': 0}, {'function': 'migrate', 'complexity': 0}]",4.0,"
pragma solidity ^0.8.0;

contract MigrateTokens {
    using SafeMath for uint256;

    address public oldTokenContract;
    address public newTokenContract;

    constructor(address _oldTokenContract, address _newTokenContract) {
        oldTokenContract = _oldTokenContract;
        newTokenContract = _newTokenContract;
    }

    function migrateTokens() external {
        uint256 totalSupply = IERC20(oldTokenContract).totalSupply();
        for (uint256 i = 0; i < totalSupply; i++) {
            address owner = IERC20(oldTokenContract).ownerOf(i);
            uint256 balance = IERC20(oldTokenContract).balanceOf(owner);
            IERC20(newTokenContract).mint(owner, balance);
        }
    }
}",4.121866226196289,migrateTokens,"[{'function': 'migrateTokens', 'complexity': 1}]",2.0,51.0,0.6314673645841435,0.0386996549249107,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MigrateTokens is Ownable {
    using SafeMath for uint256;

    address public oldTokenContract;
    address public newTokenContract;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor(address _oldTokenContract, address _newTokenContract) Ownable(msg.sender) {
        oldTokenContract = _oldTokenContract;
        newTokenContract = _newTokenContract;
    }

    function migrateTokens() external {
        uint256 totalSupply = IERC20(oldTokenContract).totalSupply();
        for (uint256 i = 0; i < totalSupply; i++) {
            address owner = IERC20(oldTokenContract).ownerOf(i);
            uint256 balance = IERC20(oldTokenContract).balanceOf(owner);
            IERC20(newTokenContract).mint(owner, balance);
        }
    }
}"
6317,This function handles receiving Ether in favor of a third party address we can use this function for buying tokens on behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContributionProxy is Ownable {
    using SafeMath for uint256;

    function proxy_contribution(address _toAddr) public payable {
        require(_toAddr != address(0));
        process_contribution(_toAddr);
    }

    function process_contribution(address _toAddr) internal {
        // Implementation of the contribution processing logic
    }
}","[{'function': 'proxy_contribution', 'complexity': 1}, {'function': 'process_contribution', 'complexity': 0}]",2.0,{},"[{'function': 'proxy_contribution', 'complexity': 1}, {'function': 'process_contribution', 'complexity': 0}]",2.0,"contract MyContract {
    using SafeMath for uint256;

    function receiveEther(address payable _to) public payable {
        require(_to != address(0), ""Invalid recipient"");

        // Transfer Ether to the third party address
        _to.transfer(msg.value);
    }
}",1.5078556537628174,receiveEther,"[{'function': 'receiveEther', 'complexity': 1}]",2.0,17.0,0.5825066654976941,0.2846069742959034,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
        address1 = address(0x111);
        address2 = address(0x222);
        address3 = address(0x333);
    }

    // State variables
    address public address1;
    address public address2;
    address public address3;

    function receiveEther(address payable _to) public payable {
        require(_to != address(0), ""Invalid recipient"");

        // Transfer Ether to the third party address
        _to.transfer(msg.value);
    }
}"
5800,` seal ( ) ` ends the Campaign by calling ` seal ( ) ` in the CampaignToken contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public tokenContract;
    uint256 public endFundingTime;

    constructor(address _tokenContract, uint256 _endFundingTime) {
        require(_endFundingTime > now, ""End funding time must be in the future"");
        tokenContract = _tokenContract;
        endFundingTime = _endFundingTime;
    }

    function seal() public {
        if (now < endFundingTime) throw;
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(tokenContract != address(0), ""Token contract must be set"");
        IToken(tokenContract).seal();
    }

    interface IToken {
        function seal() external;
    }
}","[{'function': 'seal', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""seal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can seal the campaign""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""CampaignToken""}, ""memberName"": ""seal""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'seal', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;

import ""./CampaignToken.sol"";

contract Campaign {
    using SafeMath for uint256;

    address public owner;
    uint256 public totalSupply;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function seal() external {
        require(msg.sender == owner, ""Only the owner can seal the campaign"");
        CampaignToken.seal();
    }
}",2.6141605377197266,seal,"[{'function': 'seal', 'complexity': 1}]",2.0,16.0,0.7920136968000558,0.1269264697423135,"pragma solidity ^0.8.0;

import ""./CampaignToken.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Campaign is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    uint256 public totalSupply = 1000000000000000000;
    mapping(address => uint256) public balances;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables is already handled in the base class uint256 public totalSupply;

 constructor
    }

    function seal() external {
        require(msg.sender == owner, ""Only the owner can seal the campaign"");
        CampaignToken.seal();
    }
}"
5101,Returns asset balance for a particular holder .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function balanceOf(address _owner, bytes32 smbl) external view returns (uint);
}

abstract contract BalanceWrapper {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;
    bytes32 public smbl;

    constructor(address platformAddress, bytes32 symbol) {
        chronoBankPlatform = ChronoBankPlatform(platformAddress);
        smbl = symbol;
    }

    function balanceOf(address _owner) public view returns (uint) {
        return chronoBankPlatform.balanceOf(_owner, smbl);
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAssetBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""holder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""holder""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"function getAssetBalance(address holder) public view returns (uint256) {
    return balances[holder];
}",0.6867926120758057,getAssetBalance,"[{'function': 'getAssetBalance', 'complexity': 0}]",1.0,3.0,0.7024234408633526,0.2420534238511223,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    uint256 public constant BALANCE = 1;
    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    bool public constant INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    mapping(address => uint256) public balances;

    constructor() Ownable(OWNER) {
        balances[OWNER] = BALANCE;
    }

    function getAssetBalance(address holder) public view returns (uint256) {
        return balances[holder];
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address public owner;

    constructor(address _owner) {
        owner = _owner;
    }

    function transfer(address recipient, uint256 amount) public {
        // Implementation of transfer function
    }
}"
752,"Called by ` settle ` , executes the settlement for a RenEx order or distributes the fees for a RenExAtomic swap .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRENexBalances {
    function transferBalanceWithFee(address, address, address, uint256, uint256, address) external;
}

abstract contract RenExWrapper is Ownable {
    using SafeMath for uint256;

    struct TokenPair {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftVolume;
        uint256 leftTokenFee;
        address rightTokenAddress;
        uint256 rightVolume;
        uint256 rightTokenFee;
    }

    mapping(bytes32 => bytes32) public orderDetails;
    mapping(bytes32 => address) public orderSubmitter;
    IRENexBalances public renExBalancesContract;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = keccak256(""RENEX_ATOMIC_SETTLEMENT"");

    function execute(bytes32 _buyID, bytes32 _sellID, address _buyer, address _seller, TokenPair memory _tokens) public {
        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ? calculateAtomicFees(_buyID, _sellID, _tokens) : calculateSettlementDetails(_buyID, _sellID, _tokens);
        renExBalancesContract.transferBalanceWithFee(_buyer, _seller, settlementDetails.leftTokenAddress, settlementDetails.leftVolume, settlementDetails.leftTokenFee, orderSubmitter[_buyID]);
        renExBalancesContract.transferBalanceWithFee(_seller, _buyer, settlementDetails.rightTokenAddress, settlementDetails.rightVolume, settlementDetails.rightTokenFee, orderSubmitter[_sellID]);
    }

    function calculateAtomicFees(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of atomic fee calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }

    function calculateSettlementDetails(bytes32 _buyID, bytes32 _sellID, TokenPair memory _tokens) private pure returns (SettlementDetails memory) {
        // Implementation of settlement details calculation
        return SettlementDetails({
            leftTokenAddress: _tokens.leftTokenAddress,
            leftVolume: _tokens.leftVolume,
            leftTokenFee: _tokens.leftTokenFee,
            rightTokenAddress: _tokens.rightTokenAddress,
            rightVolume: _tokens.rightVolume,
            rightTokenFee: _tokens.rightTokenFee
        });
    }
}","[{'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'execute', 'complexity': 1}, {'function': 'calculateAtomicFees', 'complexity': 0}, {'function': 'calculateSettlementDetails', 'complexity': 0}]",1.0,{},"[{'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'execute', 'complexity': 1}, {'function': 'calculateAtomicFees', 'complexity': 0}, {'function': 'calculateSettlementDetails', 'complexity': 0}]",1.0,"
contract Settlement {
    using SafeMath for uint;

    function settle(uint256 amount, address payable recipient) public {
        require(msg.sender == tx.origin);
        recipient.transfer(amount);
    }
}",1.2490718364715576,settle,"[{'function': 'settle', 'complexity': 1}]",2.0,59.0,0.4140505698799324,0.01385994517252,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Settlement is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function settle(uint256 amount, address payable recipient) public {
        require(msg.sender == tx.origin);
        recipient.transfer(amount);
    }
}"
1142,` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _amount) public override returns (bool) {
        require(_spender != address(0));
        require(_amount > 0);
        require(_amount <= balanceOf[msg.sender]);

        allowances[_spender][msg.sender] = _amount;

        emit Approval(msg.sender, _spender, _amount);

        return true;
    }
}","[{'function': 'approve', 'complexity': 0}, {'function': 'approve', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 0}, {'function': 'approve', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_amount > 0, ""Invalid amount"");

        // Additional logic can be added here

        return true;
    }
}",2.259340763092041,approve,"[{'function': 'approve', 'complexity': 2}]",3.0,27.0,0.9316814632393552,0.4712861696710866,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract {
    using SafeMath for uint256;
    address public constant DEFAULT_SPENDER = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_APPROVED = true;
    bytes32 public constant DEFAULT_INIT = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_amount > 1, ""Invalid amount""); // Set to at least 1

        // Additional logic can be added here
        return true;
    }
}"
3633,` _value ` tokens will be sended to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITransfer {
    function transfer(bytes32 _to, uint256 _value) external returns (bool);
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event TransferHash(bytes32 indexed from, bytes32 indexed to, uint256 value);

    function transfer(bytes32 _to, uint256 _value) external onlyOwner returns (bool) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit TransferHash(keccak256(abi.encodePacked(msg.sender)), _to, _value);
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint;

    function transferTokens(address _to, IERC20 _token, uint _value) public {
        require(_to != address(0), ""Invalid recipient"");
        require(_value > 0, ""Invalid value"");
        require(_token.transferFrom(msg.sender, _to, _value), ""Transfer failed"");
    }
}",3.8467769622802734,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,38.0,0.688140024786153,0.1309283647366126,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferTokens(address _to, IERC20 _token, uint _value) public {
        require(_to != address(0), ""Invalid recipient"");
        require(_value > 0, ""Invalid value"");
        require(_token.transferFrom(msg.sender, _to, _value), ""Transfer failed"");
    }
}"
4852,Allows user to mint if they have the appropriate permissions .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    function burn(uint256 _amount) public requiresPermission whenNotPaused {
        _burn(msg.sender, _amount);
    }
}","[{'function': 'burn', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""users""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""hasPermissions""}, {""type"": ""stringLiteral"", ""value"": ""Only users with permissions can mint""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""users""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""memberName"": ""balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""users""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract MintingContract {
    using SafeMath for uint256;

    struct User {
        address addr;
        bool hasPermissions;
    }

    mapping(address => User) public users;

    function mint(uint256 amount, address to) public {
        require(users[msg.sender].hasPermissions, ""Only users with permissions can mint"");

        // Additional logic can be added here

        uint256 totalSupply = SafeMath.add(amount, users[to].balance);
        users[to].balance = totalSupply;
    }
}",3.1184256076812744,mint,"[{'function': 'mint', 'complexity': 1}]",2.0,26.0,0.5808079925850623,0.0178397972861236,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MintingContract is Ownable {
    using SafeMath for uint256;

    struct User {
        address addr;
        bool hasPermissions;
        uint256 balance;
    }

    mapping(address => User) public users;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            users[addr] = User({addr: addr, hasPermissions: true, balance: 1});
        }
    }

    function mint(uint256 amount, address to) public {
        require(users[msg.sender].hasPermissions, ""Only users with permissions can mint"");

        // Additional logic can be added here

        uint256 totalSupply = SafeMath.add(amount, users[to].balance);
        users[to].balance = totalSupply;
    }
}"
2521,Returns the address currently assigned ownership of a given Warrior .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WarriorsWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public warriorToOwner;
    uint256[] public warriors;

    function ownerOf(uint208 _tokenId) external view returns (address owner) {
        require(_tokenId < warriors.length);
        owner = warriorToOwner[_tokenId];
    }
}","[{'function': 'ownerOf', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getWarriorOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_warriorAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""warriors""}, ""index"": {""type"": ""Identifier"", ""name"": ""_warriorAddress""}}, ""memberName"": ""owner""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'ownerOf', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

contract Warriors {
    using SafeMath for uint256;

    struct Warrior {
        address owner;
        string name;
        uint256 level;
        uint256 experience;
    }

    mapping(address => Warrior) public warriors;

    function getWarriorOwner(address _warriorAddress) public view returns (address) {
        return warriors[_warriorAddress].owner;
    }
}",2.353527307510376,getWarriorOwner,"[{'function': 'getWarriorOwner', 'complexity': 0}]",1.0,10.0,0.7131977649199938,0.1178721467631613,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Warriors is Ownable {
    using SafeMath for uint256;

    struct Warrior {
        address owner;
        string name;
        uint256 level;
        uint256 experience;
    }

    mapping(address => Warrior) public warriors;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            warriors[addr] = Warrior({
                owner: msg.sender,
                name: ""Warrior"",
                level: 1,
                experience: 0
            });
        }
    }

    function getWarriorOwner(address _warriorAddress) public view returns (address) {
        return warriors[_warriorAddress].owner;
    }
}"
402,Contract owner or Multisig can clawback ether after refund period is finished,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ClawbackEtherWrapper is Ownable {
    using SafeMath for uint256;

    bool public contractFailed;
    bool public contractRefundStarted;
    bool public contractRefundFinished;

    constructor() {}

    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {
        require(contractFailed);
        require(contractRefundStarted);
        require(contractRefundFinished);
        require(value > 0);
        require(value <= address(this).balance);
        payable(msg.sender).transfer(value);
    }
}","[{'function': 'emergencyClawbackEther', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isOwner""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only the current owner can set a new owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isOwner""}, ""index"": {""type"": ""Identifier"", ""name"": ""_newOwner""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isOwner""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOwner""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'emergencyClawbackEther', 'complexity': 5}]",6.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract Clawback {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public isOwner;

    constructor() public {
        owner = msg.sender;
        isOwner[owner] = true;
    }

    function setOwner(address _newOwner) external {
        require(isOwner[msg.sender], ""Only the current owner can set a new owner"");
        isOwner[_newOwner] = true;
        delete isOwner[msg.sender];
        owner = _newOwner;
    }

    function clawbackEther() external {
        require(isOwner[msg.sender], ""Only the current owner or a multisig can claw back ether"");
        uint256 amount = address(this).balance;
        payable(owner).transfer(amount);
    }
}",6.7752087116241455,setOwner,"[{'function': 'setOwner', 'complexity': 1}, {'function': 'clawbackEther', 'complexity': 1}]",2.0,27.0,0.4086020501747143,0.0254343935403065,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Clawback is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public isOwner;

    constructor() {
        owner = msg.sender;
        isOwner[owner] = true;
        initialize();
    }

    function setOwner(address _newOwner) external {
        require(isOwner[msg.sender], ""Only the current owner can set a new owner"");
        isOwner[_newOwner] = true;
        delete isOwner[msg.sender];
        owner = _newOwner;
    }

    function clawbackEther() external {
        require(isOwner[msg.sender], ""Only the current owner or a multisig can claw back ether"");
        uint256 amount = address(this).balance;
        payable(owner).transfer(amount);
    }
}"
2323,By using this function you accept the terms of DXF,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Multisig {
    function send(uint256 amount) external returns (bool);
}

abstract contract DXFContract is Ownable {
    using SafeMath for uint256;

    uint public startingDateFunding;
    bool public dxfOpen = true;
    uint public maxNumberMembers = 1000;
    uint public totalTokens;
    uint public tokensCreationCap = 10000 ether;
    uint public remainingTokensVIPs;
    mapping(address => uint) public balances;
    address[] public members;
    mapping(address => uint) public indexMembers;
    mapping(address => bool) public vips;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function acceptTermsAndJoinDXF() payable external {
        require(now > startingDateFunding + 365 days, ""Too early"");
        require(dxfOpen, ""DXF is closed"");
        require(!vips[msg.sender], ""Already a VIP"");
        require(msg.value >= 10 ether, ""Minimum contribution is 10 ether"");
        require(msg.value <= (tokensCreationCap - totalTokens), ""Exceeds token creation cap"");
        require(msg.value <= 10000 ether - balances[msg.sender], ""Exceeds balance limit"");

        if (balances[msg.sender] == 0) {
            newMember(msg.sender);
            indexMembers[msg.sender] = members.length;
            members.push(Member(msg.sender, now, msg.value));
        } else {
            members[indexMembers[msg.sender]].initial_value += msg.value;
        }

        require(members.length <= maxNumberMembers, ""Max number of members reached"");
        require(multisigDXF != address(0), ""Invalid multisig contract"");

        Multisig multisig = Multisig(multisigDXF);
        require(multisig.send(msg.value), ""Transfer failed"");

        uint numTokens = msg.value;
        totalTokens += numTokens;
        require((tokensCreationCap - totalTokens) >= remainingTokensVIPs, ""Exceeds VIP tokens limit"");

        balances[msg.sender] += numTokens;
        Transfer(address(0), msg.sender, numTokens);
    }

    function newMember(address member) internal {
        // Implementation of newMember logic if needed
    }
}","[{'function': 'send', 'complexity': 0}, {'function': 'acceptTermsAndJoinDXF', 'complexity': 12}, {'function': 'newMember', 'complexity': 0}]",12.0,"{""type"": ""FunctionDefinition"", ""name"": ""acceptTerms"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_termsVersion"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_termsHash"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_termsVersion""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid terms version""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_termsHash""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid terms hash length""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'send', 'complexity': 0}, {'function': 'acceptTermsAndJoinDXF', 'complexity': 12}, {'function': 'newMember', 'complexity': 0}]",12.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract AcceptTerms {
    using SafeMath for uint256;

    function acceptTerms(uint256 _termsVersion, string memory _termsHash) public pure returns (bool) {
        require(_termsVersion > 0, ""Invalid terms version"");
        require(_termsHash.length == 32, ""Invalid terms hash length"");

        return true;
    }
}",2.242516279220581,acceptTerms,"[{'function': 'acceptTerms', 'complexity': 2}]",3.0,130.0,0.4936969143582922,0.0029308146782307,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract AcceptTerms is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function acceptTerms(uint256 _termsVersion, string memory _termsHash) public pure returns (bool) {
        require(_termsVersion > 0, ""Invalid terms version"");
        require(_termsHash.length == 32, ""Invalid terms hash length"");

        return true;
    }
}"
36,Function used by the creator to set the contractor manager smart contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractorManagerSetter is Ownable {
    using SafeMath for uint256;

    event ContractorManagerSet(address indexed contractorManager);

    function setContractorManager(address _contractorManager) public onlyOwner {
        require(_contractorManager != address(0), ""Invalid contractor manager address"");
        emit ContractorManagerSet(_contractorManager);
    }
}","[{'function': 'setContractorManager', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setContractor"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_contractor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can set the contractor""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""contractor""}, ""right"": {""type"": ""Identifier"", ""name"": ""_contractor""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setContractorManager', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

contract ContractorManager {
    address public owner;
    address public contractor;

    constructor() public {
        owner = msg.sender;
    }

    function setContractor(address _contractor) external {
        require(msg.sender == owner, ""Only the owner can set the contractor"");
        contractor = _contractor;
    }
}",1.8634910583496087,setContractor,"[{'function': 'setContractor', 'complexity': 1}]",2.0,7.0,0.8335180078551832,0.0501012193191356,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract ContractorManager is Ownable {
    address public owner;
    address public contractor;

    constructor() public Ownable(msg.sender) {
        owner = msg.sender;
        contractor = address(0);
    }

    function setContractor(address _contractor) external {
        require(msg.sender == owner, ""Only the owner can set the contractor"");
        contractor = _contractor;
    }
}"
1979,Get comprehensive information on an attribute type with ID ` attributeTypeID ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAttributeType {
    struct AttributeType {
        string description;
        bool isRestricted;
        bool isOnlyPersonal;
        address secondarySource;
        uint256 secondaryId;
        uint256 minimumRequiredStake;
        uint256 jurisdictionFee;
    }
}

abstract contract AttributeTypeWrapper {
    using SafeMath for uint256;

    mapping(uint256 => IAttributeType.AttributeType) private _attributeTypes;

    function getAttributeTypeInformation(uint256 attributeTypeID) external view returns (string memory, bool, bool, address, uint256, uint256, uint256) {
        return (
            _attributeTypes[attributeTypeID].description,
            _attributeTypes[attributeTypeID].isRestricted,
            _attributeTypes[attributeTypeID].isOnlyPersonal,
            _attributeTypes[attributeTypeID].secondarySource,
            _attributeTypes[attributeTypeID].secondaryId,
            _attributeTypes[attributeTypeID].minimumRequiredStake,
            _attributeTypes[attributeTypeID].jurisdictionFee
        );
    }
}","[{'function': 'getAttributeTypeInformation', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAttributeType"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""Mapping"", ""keyType"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""valueType"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid attribute type ID""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""id""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attributeTypes""}, ""index"": {""type"": ""Identifier"", ""name"": ""attributeTypeID""}}, ""memberName"": ""isRequired""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getAttributeTypeInformation', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Attribute {
    using SafeMath for uint256;

    struct AttributeType {
        string name;
        uint256 id;
        mapping(uint256 => bool) isRequired;
    }

    mapping(uint256 => AttributeType) public attributeTypes;

    function getAttributeType(uint256 attributeTypeID) public view returns (string memory, uint256, mapping(uint256 => bool)) {
        require(attributeTypeID > 0, ""Invalid attribute type ID"");
        return (attributeTypes[attributeTypeID].name, attributeTypes[attributeTypeID].id, attributeTypes[attributeTypeID].isRequired);
    }
}",3.493415594100952,getAttributeType,"[{'function': 'getAttributeType', 'complexity': 1}]",2.0,28.0,0.8774795860093368,0.236569510693842,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of adding Ownable functionality

contract Attribute is Ownable {
    using SafeMath for uint256;

    struct AttributeType {
        string name;
        uint256 id;
        mapping(uint256 => bool) isRequired;
    }

    mapping(uint256 => AttributeType) public attributeTypes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            attributeTypes[i] = AttributeType({
                name: 'initialized',
                id: i,
                isRequired: new mapping(uint256 => bool)(0)
            });
        }
    }

    function getAttributeType(uint256 attributeTypeID) public view returns (string memory, uint256, mapping(uint256 => bool)) {
        require(attributeTypeID > 0, ""Invalid attribute type ID"");
        return (attributeTypes[attributeTypeID].name, attributeTypes[attributeTypeID].id, attributeTypes[attributeTypeID].isRequired);
    }
}"
2733,Set the stale period on the updated havven price,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public priceStalePeriod;

    function setPriceStalePeriod(uint time) external optionalProxy_onlyOwner {
        priceStalePeriod = time;
    }
}","[{'function': 'setPriceStalePeriod', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setStalePeriod"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_endTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_startTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""now""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_endTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""now""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid time range""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stalePeriods""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""startTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_startTime""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stalePeriods""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""endTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""_endTime""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPriceStalePeriod', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract HavvenPrice {
    using SafeMath for uint256;

    struct StalePeriod {
        uint256 startTime;
        uint256 endTime;
    }

    mapping(address => StalePeriod) public stalePeriods;

    function setStalePeriod(uint256 _startTime, uint256 _endTime) external {
        require(_startTime <= now && _endTime >= now, ""Invalid time range"");
        stalePeriods[msg.sender].startTime = _startTime;
        stalePeriods[msg.sender].endTime = _endTime;
    }
}",3.004081010818481,setStalePeriod,"[{'function': 'setStalePeriod', 'complexity': 2}]",3.0,26.0,0.726546037992098,0.0168941279893678,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract HavvenPrice is Ownable {
    using SafeMath for uint256;

    struct StalePeriod {
        uint256 startTime;
        uint256 endTime;
    }

    mapping(address => StalePeriod) public stalePeriods;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            stalePeriods[addr] = StalePeriod({startTime: uint256(i), endTime: uint256(i + 1)});
        }
    }

    function setStalePeriod(uint256 _startTime, uint256 _endTime) external {
        require(_startTime <= block.timestamp && _endTime >= block.timestamp, ""Invalid time range"");
        stalePeriods[msg.sender].startTime = _startTime;
        stalePeriods[msg.sender].endTime = _endTime;
    }
}"
1587,allows EtherToken to reclaim tokens wrongly sent to its address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/SafeMath.sol"";

interface IBasicToken {
    // Define the interface of the token contract here if needed
}

abstract contract Reclaimable is Ownable {
    using SafeMath for uint256;

    address public constant RECLAIM_ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    function reclaim(IBasicToken token) public onlyOwner {
        require(token != IBasicToken(RECLAIM_ETHER));
        Reclaimable.reclaim(token);
    }
}","[{'function': 'reclaim', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Cannot reclaim tokens from this contract""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'reclaim', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract EtherToken is IERC20 {
    using SafeMath for uint256;

    function reclaimTokens(address _tokenAddress, address _to) public {
        require(_tokenAddress != address(this), ""Cannot reclaim tokens from this contract"");
        require(_to != address(0), ""Invalid recipient"");

        IERC20 token = IERC20(_tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        token.transfer(_to, balance);
    }
}",4.1392974853515625,reclaimTokens,"[{'function': 'reclaimTokens', 'complexity': 2}]",3.0,31.0,0.7115183727716792,0.0372917443299746,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract EtherToken is IERC20 {
    using SafeMath for uint256;
    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with your owner's address
    bool public constant INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(OWNER) {}

    function reclaimTokens(address _tokenAddress, address _to) public {
        require(_tokenAddress != address(this), ""Cannot reclaim tokens from this contract"");
        require(_to != address(0), ""Invalid recipient"");

        IERC20 token = IERC20(_tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        token.transfer(_to, balance);
    }
}"
1004,"Used to reference a loan that is not yet created , and by that does not have an index","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentifierBuilder {
    using SafeMath for uint256;

    function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string memory metadata) public view returns (bytes32) {
        return keccak256(abi.encodePacked(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata));
    }
}","[{'function': 'buildIdentifier', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createLoan"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""principal"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""interestRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""repaymentPeriod"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""principal""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Principal must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""interestRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Interest rate must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""repaymentPeriod""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Repayment period must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""loanIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loans""}, ""memberName"": ""length""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Loan""}, ""name"": ""newLoan"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Loan""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""principal""}, {""type"": ""Identifier"", ""name"": ""interestRate""}, {""type"": ""Identifier"", ""name"": ""repaymentPeriod""}], ""names"": [""principal"", ""interestRate"", ""repaymentPeriod""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""loans""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newLoan""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LoanCreated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""loanIndex""}, {""type"": ""Identifier"", ""name"": ""principal""}, {""type"": ""Identifier"", ""name"": ""interestRate""}, {""type"": ""Identifier"", ""name"": ""repaymentPeriod""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'buildIdentifier', 'complexity': 0}]",2.0,"function createLoan(uint256 principal, uint256 interestRate, uint256 repaymentPeriod) public {
    require(principal > 0, ""Principal must be greater than zero"");
    require(interestRate > 0, ""Interest rate must be greater than zero"");
    require(repaymentPeriod > 0, ""Repayment period must be greater than zero"");

    uint256 loanIndex = loans.length;
    Loan memory newLoan = Loan({ principal: principal, interestRate: interestRate, repaymentPeriod: repaymentPeriod });
    loans.push(newLoan);

    emit LoanCreated(loanIndex, principal, interestRate, repaymentPeriod);
}",3.2806882858276367,createLoan,"[{'function': 'createLoan', 'complexity': 3}]",4.0,46.0,0.4767784230576713,0.0724511494504598,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LoanContract is Ownable {
    struct Loan {
        uint256 principal;
        uint256 interestRate;
        uint256 repaymentPeriod;
    }

    Loan[] public loans;

    event LoanCreated(uint256 indexed loanIndex, uint256 principal, uint256 interestRate, uint256 repaymentPeriod);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        loans = [];
    }

    function createLoan(uint256 principal, uint256 interestRate, uint256 repaymentPeriod) public {
        require(principal > 0, ""Principal must be greater than zero"");
        require(interestRate > 0, ""Interest rate must be greater than zero"");
        require(repaymentPeriod > 0, ""Repayment period must be greater than zero"");

        uint256 loanIndex = loans.length;
        Loan memory newLoan = Loan({ principal: principal, interestRate: interestRate, repaymentPeriod: repaymentPeriod });
        loans.push(newLoan);

        emit LoanCreated(loanIndex, principal, interestRate, repaymentPeriod);
    }
}"
6826,Returns the block number for when the channel was closed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        uint closed;
    }

    Data private data;

    function closed() public view returns (uint) {
        return data.closed;
    }
}","[{'function': 'closed', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getChannelCloseBlockNumber"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_channelAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_channelAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid channel address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""closeBlockNumber"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""channels""}, ""index"": {""type"": ""Identifier"", ""name"": ""_channelAddress""}}, ""memberName"": ""closed""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""closeBlockNumber""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}}]}, ""FalseBody"": None}, {""type"": ""Identifier"", ""name"": ""closeBlockNumber""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'closed', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Channel {
    using SafeMath for uint256;

    struct ChannelData {
        address payable sender;
        address payable receiver;
        uint256 balance;
        bool closed;
    }

    mapping(address => ChannelData) public channels;

    function getChannelCloseBlockNumber(address _channelAddress) public view returns (uint256) {
        require(_channelAddress != address(0), ""Invalid channel address"");

        uint256 closeBlockNumber = 0;

        if (channels[_channelAddress].closed) {
            closeBlockNumber = block.number;
        }

        return closeBlockNumber;
    }
}",3.167729139328003,getChannelCloseBlockNumber,"[{'function': 'getChannelCloseBlockNumber', 'complexity': 2}]",3.0,19.0,0.4896505355830087,0.1027396510811024,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Channel is Ownable {
    using SafeMath for uint256;

    struct ChannelData {
        address payable sender;
        address payable receiver;
        uint256 balance;
        bool closed;
    }

    mapping(address => ChannelData) public channels;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            channels[addr] = ChannelData({
                sender: payable(addr),
                receiver: payable(addr),
                balance: 1,
                closed: true
            });
        }
    }

    function getChannelCloseBlockNumber(address _channelAddress) public view returns (uint256) {
        require(_channelAddress != address(0), ""Invalid channel address"");

        uint256 closeBlockNumber = 0;

        if (channels[_channelAddress].closed) {
            closeBlockNumber = block.number;
        }

        return closeBlockNumber;
    }
}"
4437,` msg.sender ` approves ` _spender ` to spend ` _value ` tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_value > 0, ""Invalid value"");
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","[{'function': 'approve', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Invalid value"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_spender] = balances[_spender].add(_value);

        return true;
    }
}",2.8237011432647705,approve,"[{'function': 'approve', 'complexity': 2}]",3.0,19.0,0.9484434738985268,0.7263683565962553,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        balances[address(0)] = 1; // address(0) is used as a placeholder for zero address initialization
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Invalid value"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_spender] = balances[_spender].add(_value);

        return true;
    }
}"
2473,Finalize an upgrade process setting new asset implementation contract address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract UpgradeHandler is Ownable {
    using SafeMath for uint256;

    uint256 public pendingVersion;
    uint256 public pendingVersionTimestamp;
    uint256 public constant UPGRADE_FREEZE_TIME = 7 days; // Example freeze time, adjust as needed
    uint256 public latestVersion;

    function commitUpgrade() public onlyOwner returns (bool) {
        if (pendingVersion == 0x0) {
            return false;
        }

        if (pendingVersionTimestamp.add(UPGRADE_FREEZE_TIME) > block.timestamp) {
            return false;
        }

        latestVersion = pendingVersion;
        delete pendingVersion;
        delete pendingVersionTimestamp;

        return true;
    }
}","[{'function': 'commitUpgrade', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeUpgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newImplementation"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newImplementation""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New implementation must be set""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""implementation""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Only one upgrade can be performed at a time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""implementation""}, ""right"": {""type"": ""Identifier"", ""name"": ""newImplementation""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'commitUpgrade', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

contract AssetUpgrade {
    address public owner;
    address public implementation;

    constructor() public {
        owner = msg.sender;
        implementation = 0x0;
    }

    function finalizeUpgrade(address newImplementation) external onlyOwner {
        require(newImplementation != address(0), ""New implementation must be set"");
        require(implementation == 0x0, ""Only one upgrade can be performed at a time"");

        implementation = newImplementation;
    }
}",4.653828144073486,finalizeUpgrade,"[{'function': 'finalizeUpgrade', 'complexity': 2}]",4.0,22.0,0.5894504609743704,0.013989427612475,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract AssetUpgrade {
    address public owner;
    address public implementation;

    // Initialize all instance variables to fixed, safe, non-corner-case values.
    constructor() public {
        owner = 0x1111111111111111111111111111111111111111; // Replace with actual address
        implementation = 0x2222222222222222222222222222222222222222; // Replace with actual address
    }

    function finalizeUpgrade(address newImplementation) external onlyOwner {
        require(newImplementation != address(0), ""New implementation must be set"");
        require(implementation == 0x0, ""Only one upgrade can be performed at a time"");

        implementation = newImplementation;
    }
}
```

However, the contract is missing the `Ownable` inheritance. Here's the corrected code:

```solidity
pragma solidity ^0.8.0;

import 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.6.0/contracts/ownership/Ownable.sol';
import ""openzeppelin/SafeMath.sol"";
contract AssetUpgrade is Ownable {
    address public owner;
    address public implementation;

    // Initialize all instance variables to fixed, safe, non-corner-case values.
    constructor() public {
        owner = msg.sender; // Set the owner to the deployer
        implementation = 0x3333333333333333333333333333333333333333; // Replace with actual address
    }

    function finalizeUpgrade(address newImplementation) external onlyOwner {
        require(newImplementation != address(0), ""New implementation must be set"");
        require(implementation == 0x0, ""Only one upgrade can be performed at a time"");

        implementation = newImplementation;
    }
}"
4258,Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowance;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","[{'function': 'approve', 'complexity': 0}]",1.0,{},"[{'function': 'approve', 'complexity': 0}]",1.0,"
contract MyContract {
    using SafeMath for uint256;

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Invalid value"");
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}",2.117100715637207,approve,"[{'function': 'approve', 'complexity': 2}]",3.0,27.0,0.9707456949832224,0.5218034551795248,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Invalid value"");
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}"
3893,should be called off chain with as much gas as needed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface KyberReserveInterface {
    // Define the interface of the KyberReserve here if needed
}

abstract contract KyberReserveWrapper is Ownable {
    using SafeMath for uint256;

    KyberReserveInterface[] public reserves;

    function getReserves() public view returns (KyberReserveInterface[] memory) {
        return reserves;
    }
}","[{'function': 'getReserves', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""myFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'getReserves', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint256;

    function myFunction(uint256 _amount) public payable returns (bool) {
        // Additional logic can be added here
        return true;
    }
}",1.3208038806915283,myFunction,"[{'function': 'myFunction', 'complexity': 0}]",1.0,5.0,0.1868172271010374,0.0344691331672903,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        myUint = 1;
        myAddress = address(0x111);
        myBool = true;
        myString = 'initialized';
        myBytes32 = bytes32('init');
    }

    uint256 public myUint;
    address public myAddress;
    bool public myBool;
    string public myString;
    bytes32 public myBytes32;

    function myFunction(uint256 _amount) public payable returns (bool) {
        // Additional logic can be added here
        return true;
    }
}"
3338,Exposes that this contract thinks it is an AffiliateProgram,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AffiliateProgramWrapper is Ownable {
    using SafeMath for uint256;

    function isAffiliateProgram() public pure returns (bool) {
    return true;
}
}","[{'function': 'isAffiliateProgram', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isAffiliate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isAffiliateProgram', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract AffiliateProgram {
    struct User {
        address userAddress;
        uint256 balance;
    }

    mapping(address => User) public users;

    function isAffiliate() external view returns (bool) {
        return true;
    }
}",1.5178651809692385,isAffiliate,"[{'function': 'isAffiliate', 'complexity': 0}]",1.0,0.0,0.847804175988648,0.5757575636202255,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AffiliateProgram is Ownable {
    struct User {
        address userAddress;
        uint256 balance;
    }

    mapping(address => User) public users;

    constructor() Ownable(msg.sender) {
        for (uint i = 1; i <= 3; i++) {
            users[address(uint160(i << 160))] = User({userAddress: address(uint160(i << 160)), balance: 1});
        }
    }

    function isAffiliate() external view returns (bool) {
        return true;
    }
}"
812,Allow users to buy tokens for ` newRate ` x eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public tokensPerEther;

    function setPrices(uint256 newRate) public onlyOwner {
        tokensPerEther = newRate;
    }
}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient ETH""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newRate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newRate""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Token""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Token""}}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokenAmount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract TokenSale {
    using SafeMath for uint256;

    function buyTokens(uint256 amount) public payable returns (bool) {
        require(msg.value >= amount, ""Insufficient ETH"");

        // Calculate the number of tokens to be minted
        uint256 newRate = 10; // Set a default rate of 10 tokens per ETH
        uint256 tokenAmount = msg.value.mul(newRate);

        // Mint the tokens and transfer them to the buyer
        Token token = new Token();
        token.mint(msg.sender, tokenAmount);

        return true;
    }
}",3.546825170516968,buyTokens,"[{'function': 'buyTokens', 'complexity': 1}]",2.0,34.0,0.4655793811289679,0.0096232471069497,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract TokenSale is Ownable {
    using SafeMath for uint256;

    function buyTokens(uint256 amount) public payable returns (bool) {
        require(msg.value >= amount, ""Insufficient ETH"");

        // Calculate the number of tokens to be minted
        uint256 newRate = 10; // Set a default rate of 10 tokens per ETH
        uint256 tokenAmount = msg.value.mul(newRate);

        // Mint the tokens and transfer them to the buyer
        Token token = new Token();
        token.mint(msg.sender, tokenAmount);

        return true;
    }
}

contract Token {
    mapping(address => uint256) public balances;

    function mint(address account, uint256 amount) internal {
        require(amount > 0, ""Token: cannot mint zero tokens"");
        balances[account] += amount;
    }
}"
714,Transfers ` amount ` from msg.sender to ` destination `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IToken {
    function balances(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
}

abstract contract Token is Ownable, SafeMath {
    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address destination, uint256 amount) public tradable(msg.sender) returns (bool success) {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[destination] = balances[destination].add(amount);
        emit Transfer(msg.sender, destination, amount);
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""destination"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""destination""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""destination""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""destination""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract Transfer {
    using SafeMath for uint256;

    function transfer(uint256 amount, address destination) public {
        require(msg.sender == owner);
        require(amount > 0);
        require(destination != address(0));
        require(balanceOf[msg.sender] >= amount);

        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);
        balanceOf[destination] = balanceOf[destination].add(amount);
    }
}",3.2552733421325684,transfer,"[{'function': 'transfer', 'complexity': 4}]",5.0,34.0,0.8294164530017794,0.1807013825264179,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Transfer is SafeERC20, Ownable {
    using SafeMath for uint256;

    // Fixed values
    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    address public constant DESTINATION = 0x2222222222222222222222222222222222222222; // Replace with actual destination's address

    // Non-zero initial value
    uint256 public balanceOf = 1;

    // Safe initialization of instance variables
    mapping(address => uint256) public balanceOf;

 constructor() Ownable(OWNER) {
        _setBalanceOf(msg.sender, balanceOf);
    }

    function transfer(uint256 amount, address destination) public {
        require(msg.sender == owner());
        require(amount > 0);
        require(destination != address(0));
        require(balanceOf[msg.sender] >= amount);

        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);
        balanceOf[destination] = balanceOf[destination].add(amount);
    }
}"
6517,Set ` _token_address ` as the token address to be used in the auction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RaidenToken {
    function balanceOf(address account) external view returns (uint256);
    function decimals() external view returns (uint8);
}

abstract contract Auction is Ownable {
    using SafeMath for uint256;

    enum Stages { NotDeployed, AuctionDeployed, AuctionSetUp, AuctionEnded }
    Stages public stage;

    RaidenToken public token;
    uint256 public num_tokens_auctioned;
    uint256 public token_multiplier;

    event Setup();

    modifier atStage(Stages expectedStage) {
        require(stage == expectedStage, ""Auction: Invalid stage"");
        _;
    }

    function setup(address _token_address) public onlyOwner atStage(Stages.AuctionDeployed) {
        require(_token_address != address(0), ""Token address must be valid"");
        token = RaidenToken(_token_address);
        num_tokens_auctioned = token.balanceOf(address(this));
        token_multiplier = 10 ** uint256(token.decimals());
        stage = Stages.AuctionSetUp;
        emit Setup();
    }
}","[{'function': 'decimals', 'complexity': 0}, {'function': 'setup', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTokenAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokenAddress""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'decimals', 'complexity': 0}, {'function': 'setup', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract Auction {
    using SafeMath for uint256;

    address private _tokenAddress;

    function setTokenAddress(address tokenAddress) public {
        require(tokenAddress != address(0), ""Invalid token address"");
        _tokenAddress = tokenAddress;
    }
}",1.6993348598480225,setTokenAddress,"[{'function': 'setTokenAddress', 'complexity': 1}]",2.0,33.0,0.6230494198968078,0.0640992207165478,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Auction is Ownable {
    using SafeMath for uint256;

    address private _tokenAddress;
    bool public initialized = true;
    bytes32 public constant initBytes32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        _tokenAddress = 0x1111111111111111111111111111111111111111; // Replace with actual token address
    }

    function setTokenAddress(address tokenAddress) public {
        require(tokenAddress != address(0), ""Invalid token address"");
        _tokenAddress = tokenAddress;
    }
}"
2209,"match orders with admins involved , only admin","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Matcher {
    using SafeMath for uint256;

    address public admin;
    mapping(uint256 => address) public userId2Address;
    mapping(address => uint256) public userNonce;
    mapping(bytes32 => uint256) public orderFills;

    constructor() {
        admin = msg.sender;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, ""Only admin can call this function"");
        _;
    }

    function matchByAdmin_TwH36(uint256[] memory inputs) external onlyAdmin {
        uint256 data = inputs[3];
        address user = userId2Address[data & USER_MASK];
        require(data >> 224 > userNonce[user]);
        (address token, bool isBuy) = decodeOrderTokenAndIsBuy(data);
        bytes32 orderHash = keccak256(this, inputs[0], inputs[1], inputs[2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
        require(verify(orderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[4]), bytes32(inputs[5])));
        uint256 tokenExecute = isBuy ? inputs[1] : inputs[0];
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        require(tokenExecute != 0);
        uint256 etherExecute = 0;
        isBuy = !isBuy;
        for (uint256 i = 6; i < inputs.length; i += 6) {
            require(tokenExecute > 0 && inputs[1].mul(inputs[i + 1]) <= inputs[0].mul(inputs[i]));
            data = inputs[i + 3];
            user = userId2Address[data & USER_MASK];
            require(data >> 224 > userNonce[user]);
            bytes32 makerOrderHash = keccak256(this, inputs[i], inputs[i + 1], inputs[i + 2], data & MATCH_SIGN_MASK | (isBuy ? ORDER_ISBUY : 0) | uint256(token));
            require(verify(makerOrderHash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 4]), bytes32(inputs[i + 5])));
            (tokenExecute, etherExecute) = internalTrade(inputs[i], inputs[i + 1], inputs[i + 2], data, tokenExecute, etherExecute, isBuy, token, 0, makerOrderHash);
        }
        isBuy = !isBuy;
        tokenExecute = isBuy ? inputs[1].sub(tokenExecute) : inputs[0].sub(tokenExecute);
        tokenExecute = tokenExecute.sub(orderFills[orderHash]);
        processTakerOrder(inputs[2], inputs[3], tokenExecute, etherExecute, isBuy, token, 0, orderHash);
    }
}","[{'function': 'matchByAdmin_TwH36', 'complexity': 17}]",11.0,"{""type"": ""FunctionDefinition"", ""name"": ""matchOrders"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Order""}, ""length"": None}, ""name"": ""orders"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""minAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""maxPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only admins can call this function""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""orders""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Order""}, ""name"": ""order"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""order""}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""minAmount""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""order""}, ""memberName"": ""price""}, ""right"": {""type"": ""Identifier"", ""name"": ""maxPrice""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": []}, ""FalseBody"": None}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'matchByAdmin_TwH36', 'complexity': 17}]",11.0,"pragma solidity ^0.8.0;

contract OrderMatcher {
    using SafeMath for uint256;

    struct Order {
        address maker;
        uint256 amount;
        uint256 price;
    }

    mapping(address => bool) admins;

    function matchOrders(Order[] memory orders, uint256 minAmount, uint256 maxPrice) public {
        require(admins[msg.sender], ""Only admins can call this function"");

        for (uint256 i = 0; i < orders.length; i++) {
            Order memory order = orders[i];
            if (order.amount >= minAmount && order.price <= maxPrice) {
                // Perform the match logic here
            }
        }
    }
}",3.6586079597473145,matchOrders,"[{'function': 'matchOrders', 'complexity': 5}]",5.0,290.0,0.6541295083998921,0.0015984979364823,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OrderMatcher is Ownable {
    using SafeMath for uint256;

    struct Order {
        address maker;
        uint256 amount;
        uint256 price;
    }

    mapping(address => bool) admins;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            admins[address(uint160(uint256(keccak256(abi.encodePacked(""admin"", i)))))] = true;
        }
    }

    function matchOrders(Order[] memory orders, uint256 minAmount, uint256 maxPrice) public {
        require(admins[msg.sender], ""Only admins can call this function"");

        for (uint256 i = 0; i < orders.length; i++) {
            Order memory order = orders[i];
            if (order.amount >= minAmount && order.price <= maxPrice) {
                // Perform the match logic here
            }
        }
    }
}"
5033,Returns the total number of Properties currently in existence .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PropertyRegistry is Ownable {
    using SafeMath for uint256;

    struct Property {
        // Define property structure here
    }

    Property[] public properties;

    function totalSupply() public view returns (uint) {
        return properties.length;
    }
}","[{'function': 'totalSupply', 'complexity': 0}]",1.0,{},"[{'function': 'totalSupply', 'complexity': 0}]",1.0,"
contract Property {
    using SafeMath for uint256;

    struct Property {
        address owner;
        string name;
        uint256 value;
    }

    mapping(address => Property) public properties;

    function getTotalProperties() public view returns (uint256) {
        return properties.length();
    }
}",1.62610125541687,getTotalProperties,"[{'function': 'getTotalProperties', 'complexity': 0}]",1.0,8.0,0.788477826546538,0.3770929789171766,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Property is Ownable {
    using SafeMath for uint256;

    struct Property {
        address owner;
        string name;
        uint256 value;
    }

    mapping(address => Property) public properties;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            properties[addr] = Property({owner: addr, name: ""Property"", value: 1});
        }
    }

    function getTotalProperties() public view returns (uint256) {
        return properties.length();
    }
}"
2439,Grant ` _entity ` the ability to perform actions requiring ` _role ` on ` _app `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionManager {
    using SafeMath for uint256;

    struct Permission {
        address entity;
        bytes32 role;
        bytes32 paramsHash;
    }

    mapping(address => mapping(address => mapping(bytes32 => Permission))) private permissions;
    bytes32 public constant EMPTY_PARAM_HASH = keccak256("""");

    address public owner;

    modifier onlyPermissionManager(address _app, bytes32 _role) {
        require(permissions[msg.sender][_app][_role].entity != address(0), ""Only permission manager can call this function"");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] memory _params) public onlyPermissionManager(_app, _role) {
        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;
        _setPermission(_entity, _app, _role, paramsHash);
    }

    function _saveParams(uint256[] memory _params) internal pure returns (bytes32) {
        require(_params.length > 0, ""Params array must not be empty"");
        return keccak256(abi.encodePacked(_params));
    }

    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {
        permissions[_entity][_app][_role] = Permission({
            entity: _entity,
            role: _role,
            paramsHash: _paramsHash
        });
    }
}","[{'function': 'grantPermissionP', 'complexity': 1}, {'function': '_saveParams', 'complexity': 1}, {'function': '_setPermission', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""grantEntityRole"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_entity"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_role"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_entity""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid entity""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_role""}], ""names"": []}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid role""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Role""}, ""name"": ""role"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""roles""}, ""index"": {""type"": ""Identifier"", ""name"": ""_role""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""role""}, ""memberName"": ""isEnabled""}, {""type"": ""stringLiteral"", ""value"": ""Role is not enabled""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""role""}, ""memberName"": ""entities""}, ""index"": {""type"": ""Identifier"", ""name"": ""_entity""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [None]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""entityToRole""}, ""index"": {""type"": ""Identifier"", ""name"": ""_entity""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_role""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'grantPermissionP', 'complexity': 1}, {'function': '_saveParams', 'complexity': 1}, {'function': '_setPermission', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract EntityRoleManager {
    using SafeMath for uint256;

    struct Role {
        string name;
        bool isEnabled;
        mapping(address => bool) entities;
    }

    mapping(string => Role) public roles;
    mapping(address => address) public entityToRole;

    function grantEntityRole(address _entity, string memory _role) public {
        require(_entity != address(0), ""Invalid entity"");
        require(bytes(_role).length > 0, ""Invalid role"");

        Role storage role = roles[_role];
        require(role.isEnabled, ""Role is not enabled"");

        if (role.entities[_entity]) {
            return; // Entity already has the role
        }

        entityToRole[_entity] = _role;
    }
}",4.067708969116211,grantEntityRole,"[{'function': 'grantEntityRole', 'complexity': 4}]",5.0,39.0,0.6037666586706408,0.052414273303619,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract EntityRoleManager is Ownable {
    using SafeMath for uint256;

    struct Role {
        string name;
        bool isEnabled;
        mapping(address => bool) entities;
    }

    mapping(string => Role) public roles;
    mapping(address => address) public entityToRole;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            if (i == 0) roles[""admin""].name = ""admin"";
            else if (i == 1) roles[""user""].name = ""user"";
            else if (i == 2) roles[""guest""].name = ""guest"";
        }
        roles[""admin""].isEnabled = true;
        roles[""user""].isEnabled = true;
        roles[""guest""].isEnabled = true;
    }

    function grantEntityRole(address _entity, string memory _role) public {
        require(_entity != address(0), ""Invalid entity"");
        require(bytes(_role).length > 0, ""Invalid role"");

        Role storage role = roles[_role];
        require(role.isEnabled, ""Role is not enabled"");

        if (role.entities[_entity]) {
            return; // Entity already has the role
        }

        entityToRole[_entity] = _role;
    }
}"
6671,Offer ` ( aenergy / 1.0e6 ) .toFixed ( 6 ) ` kWh of energy for day ` aday ` at a price ` ( aprice / 1.0e3 ) .toFixed ( 3 ) + ' ct/kWh ' ` above market price for a date given as day ` aday ` whilst asserting that the current date and time in nanoseconds since 1970 is ` atimestamp ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface BidInterface {
    struct Bid {
        address producer;
        uint32 day;
        uint32 price;
        uint64 energy;
        uint64 timestamp;
    }
}

abstract contract EnergyMarket is Ownable, BidInterface {
    using SafeMath for uint256;

    uint public kWh = 1000; // Example value for kWh
    Bid[] public bids;
    mapping(address => mapping(uint32 => uint)) public bidsIndex;

    event BidMade(address indexed producer, uint32 day, uint price, uint energy);
    event BidRevoked(address indexed producer, uint32 day, uint price, uint energy);

    modifier onlyRegisteredProducers() {
        require(isProducerRegistered(msg.sender), ""Only registered producers can call this function"");
        _;
    }

    function offer_energy(uint32 aday, uint32 aprice, uint64 aenergy, uint64 atimestamp) onlyRegisteredProducers external {
        require(aenergy >= kWh);
        uint idx = bidsIndex[msg.sender][aday];
        if ((bids.length > idx) && (bids[idx].producer == msg.sender) && (bids[idx].day == aday)) {
            require(atimestamp > bids[idx].timestamp);
            emit BidRevoked(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
        }
        idx = bids.length;
        bidsIndex[msg.sender][aday] = idx;
        bids.push(Bid({producer: msg.sender, day: aday, price: aprice, energy: aenergy, timestamp: atimestamp}));
        emit BidMade(bids[idx].producer, bids[idx].day, bids[idx].price, bids[idx].energy);
    }

    function isProducerRegistered(address producer) internal view returns (bool) {
        // Implement your logic to check if the producer is registered
        return true; // Placeholder for actual implementation
    }
}","[{'function': 'offer_energy', 'complexity': 3}, {'function': 'isProducerRegistered', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""offerEnergy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aenergy"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aday"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""aprice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""aday""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""aprice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid input""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""marketPrice"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getMarketPrice""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""energyOffered"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""aenergy""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1.0e6"", ""subdenomination"": None}}], ""isArray"": False}, ""memberName"": ""toFixed""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""6"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""pricePerKWh"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""aprice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1.0e3"", ""subdenomination"": None}}], ""isArray"": False}, ""memberName"": ""toFixed""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""3"", ""subdenomination"": None}], ""names"": []}, ""right"": {""type"": ""stringLiteral"", ""value"": "" ct/kWh""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""pricePerKWh""}, ""right"": {""type"": ""Identifier"", ""name"": ""marketPrice""}}, {""type"": ""stringLiteral"", ""value"": ""Offered price is lower than market price""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""energyOffered""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'offer_energy', 'complexity': 3}, {'function': 'isProducerRegistered', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract EnergyTrading {
    using SafeMath for uint256;

    function offerEnergy(uint256 aenergy, uint256 aday, uint256 aprice) public view returns (uint256) {
        require(aday > 0 && aprice > 0, ""Invalid input"");
        uint256 marketPrice = getMarketPrice();
        uint256 energyOffered = (aenergy / 1.0e6).toFixed(6);
        uint256 pricePerKWh = (aprice / 1.0e3).toFixed(3) + "" ct/kWh"";
        require(pricePerKWh >= marketPrice, ""Offered price is lower than market price"");
        return energyOffered;
    }
}",8.207573652267456,offerEnergy,"[{'function': 'offerEnergy', 'complexity': 3}]",4.0,77.0,0.7679000339586245,0.04629585390708,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract EnergyTrading is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        marketPrice = 100; // Example value, replace with actual logic if needed
        energyOffered = (aenergy / 1.0e6).toFixed(6);
        pricePerKWh = (aprice / 1.0e3).toFixed(3) + "" ct/kWh"";
    }

    function offerEnergy(uint256 aenergy, uint256 aday, uint256 aprice) public view returns (uint256) {
        require(aday > 0 && aprice > 0, ""Invalid input"");
        uint256 marketPrice = getMarketPrice();
        uint256 energyOffered = (aenergy / 1.0e6).toFixed(6);
        uint256 pricePerKWh = (aprice / 1.0e3).toFixed(3) + "" ct/kWh"";
        require(pricePerKWh >= marketPrice, ""Offered price is lower than market price"");
        return energyOffered;
    }
}"
4083,Calculates unpaid rewards of a given address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RewardCalculator {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] rewardsCumulative;
        mapping(address => uint) addressToPaidRewardIndex;
    }

    uint constant PIXEL_COUNT = 100; // Assuming PIXEL_COUNT is defined somewhere in your contract

    mapping(uint32 => FeeHistory) private feeHistories;

    function _getFeeHistory(uint32 _canvasId) internal view returns (FeeHistory storage) {
        return feeHistories[_canvasId];
    }

    function getPaintedPixelsCountByAddress(address _address, uint32 _canvasId) public view returns (uint);

    function calculateRewardToWithdraw(uint32 _canvasId, address _address) public view stateOwned(_canvasId) returns (uint reward, uint pixelsOwned) {
        FeeHistory storage _history = _getFeeHistory(_canvasId);
        uint _lastIndex = _history.rewardsCumulative.length - 1;
        uint _lastPaidIndex = _history.addressToPaidRewardIndex[_address];
        uint _pixelsOwned = getPaintedPixelsCountByAddress(_address, _canvasId);
        if (_lastIndex < 0) {
            return (0, _pixelsOwned);
        }
        uint _rewardsSum = _history.rewardsCumulative[_lastIndex];
        uint _lastWithdrawn = _history.rewardsCumulative[_lastPaidIndex];
        uint _toWithdraw = ((_rewardsSum - _lastWithdrawn) / PIXEL_COUNT) * _pixelsOwned;
        return (_toWithdraw, _pixelsOwned);
    }
}","[{'function': '_getFeeHistory', 'complexity': 0}, {'function': 'getPaintedPixelsCountByAddress', 'complexity': 0}, {'function': 'calculateRewardToWithdraw', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateUnpaidRewards"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalRewards"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""account""}, ""memberName"": ""transactions""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalRewards""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalRewards""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""account""}, ""memberName"": ""transactions""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""reward""}], ""names"": []}}}]}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalRewards""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""account""}, ""memberName"": ""paidRewards""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': '_getFeeHistory', 'complexity': 0}, {'function': 'getPaintedPixelsCountByAddress', 'complexity': 0}, {'function': 'calculateRewardToWithdraw', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract RewardCalculator {
    using SafeMath for uint256;

    function calculateUnpaidRewards(address account) public view returns (uint256) {
        // Get the total rewards earned by the account
        uint256 totalRewards = 0;

        // Loop through all the transactions made by the account and add their rewards to the total
        for (uint i = 0; i < account.transactions.length; i++) {
            totalRewards = totalRewards.add(account.transactions[i].reward);
        }

        // Return the unpaid rewards by subtracting the paid rewards from the total rewards
        return totalRewards.sub(account.paidRewards);
    }
}",3.8217713832855225,calculateUnpaidRewards,"[{'function': 'calculateUnpaidRewards', 'complexity': 1}]",2.0,55.0,0.5550707965260224,0.0307839807401852,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists in a library or another file

contract RewardCalculator is Ownable {
    using SafeMath for uint256;

    struct Transaction {
        uint256 reward;
        bool paid;
    }

    mapping(address => Transaction[]) public transactions;
    mapping(address => uint256) public paidRewards;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function calculateUnpaidRewards(address account) public view returns (uint256) {
        uint256 totalRewards = 0;

        for (uint i = 0; i < transactions[account].length; i++) {
            if (!transactions[account][i].paid) {
                totalRewards = totalRewards.add(transactions[account][i].reward);
            }
        }

        return totalRewards.sub(paidRewards[account]);
    }
}"
6519,ERC20 transfer function overridden to disable transfers when paused,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    bool public paused = false;

    modifier notPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _value) public notPaused {
        super.transfer(_to, _value);
    }
}","[{'function': 'transfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""paused""}, ""isPrefix"": True}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""Transfers are currently paused""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""super""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract MyToken is ERC20 {
    using SafeMath for uint;

    bool public paused = false;

    function transfer(address recipient, uint amount) public override returns (bool) {
        require(!paused || msg.sender == owner(), ""Transfers are currently paused"");
        return super.transfer(recipient, amount);
    }
}",3.4028773307800293,transfer,"[{'function': 'transfer', 'complexity': 3}]",3.0,16.0,0.7288797372269404,0.1048730309233314,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is ERC20, Ownable {
    using SafeMath for uint;

    bool public paused = false;

    constructor() ERC20(""MyToken"", ""TKN"") Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        paused = false;
    }

    function transfer(address recipient, uint amount) public override returns (bool) {
        require(!paused || msg.sender == owner(), ""Transfers are currently paused"");
        return super.transfer(recipient, amount);
    }
}"
5444,"Set a new campaign owner Based on the Campaign id , update the owner of the refered campaign .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CampaignManager is Ownable {
    using SafeMath for uint256;

    struct Campaign {
        address owner;
        // other campaign details...
    }

    mapping(bytes32 => Campaign) public campaigns;

    event CampaignUpdated(bytes32 indexed bidId, address newOwner);

    modifier onlyIfCampaignExists(bytes32 bidId) {
        require(campaigns[bidId].owner != address(0), ""Campaign does not exist"");
        _;
    }

    modifier onlyIfWhitelisted(address user) {
        // Assuming whitelist is managed elsewhere, implement as needed.
        require(isWhitelisted(user), ""User is not whitelisted"");
        _;
    }

    function setCampaignOwnerById(bytes32 bidId, address newOwner) public onlyIfCampaignExists(bidId) onlyIfWhitelisted(newOwner) {
        campaigns[bidId].owner = newOwner;
        emit CampaignUpdated(bidId, newOwner);
    }

    function isWhitelisted(address user) internal view returns (bool) {
        // Implement whitelist logic here.
        return true; // Placeholder for actual implementation.
    }
}","[{'function': 'setCampaignOwnerById', 'complexity': 0}, {'function': 'isWhitelisted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCampaignOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_campaignId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_campaignId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid campaign ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""owners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_campaignId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOwner""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setCampaignOwnerById', 'complexity': 0}, {'function': 'isWhitelisted', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
contract CampaignOwner {
    mapping(uint => address) public owners;

    function setCampaignOwner(uint256 _campaignId, address _newOwner) external {
        require(_campaignId > 0, ""Invalid campaign ID"");
        require(_newOwner != address(0), ""Invalid owner address"");

        owners[_campaignId] = _newOwner;
    }
}",1.9685487747192385,setCampaignOwner,"[{'function': 'setCampaignOwner', 'complexity': 2}]",3.0,19.0,0.8427567240618773,0.0195438452331632,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CampaignOwner is Ownable {
    mapping(uint => address) public owners;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setCampaignOwner(uint256 _campaignId, address _newOwner) external {
        require(_campaignId > 0, ""Invalid campaign ID"");
        require(_newOwner != address(0), ""Invalid owner address"");

        owners[_campaignId] = _newOwner;
    }
}"
2581,Checks if the makeOrder price is reasonable and not manipulative,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TakePermitWrapper {
    using SafeMath for uint256;

    function isTakePermitted(uint orderPrice, uint referencePrice, address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) public view returns (bool) {
        return true;
    }
}","[{'function': 'isTakePermitted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""1.1"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getPreviousPrice""}, ""arguments"": [], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""Price is too high""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""price""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""0.9"", ""subdenomination"": None}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getPreviousPrice""}, ""arguments"": [], ""names"": []}}}, {""type"": ""stringLiteral"", ""value"": ""Price is too low""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isTakePermitted', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Order {
    using SafeMath for uint256;

    function checkPrice(uint256 price) public view returns (bool) {
        // Check if the price is greater than 10% of the previous price
        require(price > 1.1 * getPreviousPrice(), ""Price is too high"");

        // Check if the price is less than 90% of the previous price
        require(price < 0.9 * getPreviousPrice(), ""Price is too low"");

        return true;
    }
}",3.0227975845336914,checkPrice,"[{'function': 'checkPrice', 'complexity': 2}]",3.0,28.0,0.5169305182633063,0.1143705203353317,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is how you import Ownable from OpenZeppelin

contract Order is Ownable {
    using SafeMath for uint256;

    function checkPrice(uint256 price) public view returns (bool) {
        require(price > 1.1 * getPreviousPrice(), ""Price is too high"");
        require(price < 0.9 * getPreviousPrice(), ""Price is too low"");
        return true;
    }

    function getPreviousPrice() public view returns (uint256) {
        // Placeholder for getting the previous price, replace with actual logic if needed
        revert(""Not implemented"");
    }
}"
4669,Transfer a LAND owned by an Estate to a new owner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LandRegistry is Ownable {
    using SafeMath for uint256;

    struct Estate {
        address owner;
        mapping(uint256 => address) lands;
    }

    mapping(uint256 => Estate) public estates;

    modifier canTransfer(uint256 estateId) {
        require(msg.sender == estates[estateId].owner, ""Not the owner"");
        _;
    }

    function _transferLand(uint256 estateId, uint256 landId, address destinatary) internal returns (bool) {
        require(destinatary != address(0), ""Invalid recipient"");
        estates[estateId].lands[landId] = destinatary;
        return true;
    }

    function transferLand(uint256 estateId, uint256 landId, address destinatary) external canTransfer(estateId) {
        _transferLand(estateId, landId, destinatary);
    }
}","[{'function': '_transferLand', 'complexity': 1}, {'function': 'transferLand', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferLand"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""estate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""estate""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lands""}, ""index"": {""type"": ""Identifier"", ""name"": ""estate""}}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""memberName"": ""owner""}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lands""}, ""index"": {""type"": ""Identifier"", ""name"": ""estate""}}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""memberName"": ""area""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Land""}, ""name"": ""land"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lands""}, ""index"": {""type"": ""Identifier"", ""name"": ""estate""}}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""land""}, ""memberName"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""newOwner""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""lands""}, ""index"": {""type"": ""Identifier"", ""name"": ""estate""}}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""land""}], ""isArray"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_transferLand', 'complexity': 1}, {'function': 'transferLand', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

contract LandTransfer {
    using SafeMath for uint256;

    struct Land {
        address owner;
        string name;
        uint256 area;
    }

    mapping(address => Land[]) public lands;

    function transferLand(address estate, address newOwner) external {
        require(msg.sender == estate || msg.sender == lands[estate][0].owner);
        require(lands[estate][0].area > 0);
        require(newOwner != address(0));

        Land memory land = lands[estate][0];
        land.owner = newOwner;
        lands[estate] = [land];
    }
}",3.2858657836914062,transferLand,"[{'function': 'transferLand', 'complexity': 4}]",5.0,51.0,0.7769052034700523,0.1193270816343047,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LandTransfer is Ownable {
    using SafeMath for uint256;

    struct Land {
        address owner;
        string name;
        uint256 area;
    }

    mapping(address => Land[]) public lands;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            lands[addr] = [Land({owner: addr, name: ""initialized"", area: 1})];
        }
    }

    function transferLand(address estate, address newOwner) external {
        require(msg.sender == estate || msg.sender == lands[estate][0].owner);
        require(lands[estate][0].area > 0);
        require(newOwner != address(0));

        Land memory land = lands[estate][0];
        land.owner = newOwner;
        lands[estate] = [land];
    }
}"
689,Set both ethPreAmount and mtdPreAmount at the same time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdPreAmount;
    uint256 public ethPreAmount;

    function setPreAmounts(uint256 mtdPreAmountInWei, uint256 ethPreAmountInWei) external onlyOwner {
        require(mtdPreAmountInWei > 0);
        require(ethPreAmountInWei > 0);
        mtdPreAmount = mtdPreAmountInWei;
        ethPreAmount = ethPreAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices logic
    }
}","[{'function': 'setPreAmounts', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPreAmounts"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_ethPreAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_mtdPreAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_ethPreAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_mtdPreAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""preAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""memberName"": ""ethPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_ethPreAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""preAmounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""memberName"": ""mtdPreAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_mtdPreAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPreAmounts', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",3.0,"
pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint256;

    struct PreAmounts {
        uint256 ethPreAmount;
        uint256 mtdPreAmount;
    }

    mapping(address => PreAmounts) private preAmounts;

    function setPreAmounts(uint256 _ethPreAmount, uint256 _mtdPreAmount) public {
        address sender = msg.sender;
        require(_ethPreAmount > 0 && _mtdPreAmount > 0);
        preAmounts[sender].ethPreAmount = _ethPreAmount;
        preAmounts[sender].mtdPreAmount = _mtdPreAmount;
    }
}",3.356379985809326,setPreAmounts,"[{'function': 'setPreAmounts', 'complexity': 2}]",3.0,20.0,0.8848494543695462,0.1711366601879724,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    struct PreAmounts {
        uint256 ethPreAmount;
        uint256 mtdPreAmount;
    }

    mapping(address => PreAmounts) private preAmounts;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            preAmounts[addr] = PreAmounts({
                ethPreAmount: uint256(i) * 1 ether,
                mtdPreAmount: uint256(i) * 1e18
            });
        }
    }

    function setPreAmounts(uint256 _ethPreAmount, uint256 _mtdPreAmount) public {
        address sender = msg.sender;
        require(_ethPreAmount > 0 && _mtdPreAmount > 0);
        preAmounts[sender].ethPreAmount = _ethPreAmount;
        preAmounts[sender].mtdPreAmount = _mtdPreAmount;
    }
}"
4185,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract Collectible is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public collectibleIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        collectibleIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender;
    }
}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""grantOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Only the current owner or approved user can call this function.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""ownerToApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_newOwner""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function grantOwnership(address _owner, address _newOwner) public {
        require(_owner == msg.sender || ownerToApproved[_owner][msg.sender], ""Only the current owner or approved user can call this function."");
        ownerToApproved[_owner][_newOwner] = true;
    }

    mapping(address => mapping(address => bool)) public ownerToApproved;
}",3.8892762660980233,grantOwnership,"[{'function': 'grantOwnership', 'complexity': 2}]",3.0,17.0,0.624391071152456,0.139800134566647,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        ownerToApproved[address(0x111)][address(0x222)] = true;
        ownerToApproved[address(0x222)][address(0x333)] = true;
    }

    mapping(address => mapping(address => bool)) public ownerToApproved;

    function grantOwnership(address _owner, address _newOwner) public {
        require(_owner == msg.sender || ownerToApproved[_owner][msg.sender], ""Only the current owner or approved user can call this function."");
        ownerToApproved[_owner][_newOwner] = true;
    }
}"
6513,"Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface tokenltkrecipiente {
    function approve(address _spender, uint256 _value) external returns (bool success);
    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external;
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
        tokenltkrecipiente spender = tokenltkrecipiente(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    function approve(address _spender, uint256 _value) internal returns (bool success) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Value must be greater than zero"");
        return tokenltkrecipiente(_spender).approve(_spender, _value);
    }
}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'approve', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveAndPing"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""safeApprove""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ApprovalPinged""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}, {'function': 'approve', 'complexity': 2}]",2.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol"";

contract MyContract {
    using SafeERC20 for IERC20;

    function approveAndPing(address _spender, uint256 _value) public {
        IERC20 token = IERC20(msg.sender);
        require(_value > 0, ""Invalid value"");
        require(_spender != address(0), ""Invalid spender"");
        token.safeApprove(_spender, _value);
        emit ApprovalPinged(_spender, _value);
    }
}",3.513084173202514,approveAndPing,"[{'function': 'approveAndPing', 'complexity': 2}]",3.0,20.0,0.777646958850575,0.2141615370710973,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeERC20 for IERC20;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveAndPing(address _spender, uint256 _value) public {
        IERC20 token = IERC20(msg.sender);
        require(_value > 0, ""Invalid value"");
        require(_spender != address(0), ""Invalid spender"");
        token.safeApprove(_spender, _value);
        emit ApprovalPinged(_spender, _value);
    }
}"
5584,Function that allows synth contract to delegate sending fee to the fee Pool .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISynth {
    function burn(address from, uint amount) external;
    function issue(address to, uint amount) external;
    function triggerTokenFallbackIfNeeded(address from, address to, uint amount) external;
}

interface IFeePool {
    function FEE_ADDRESS() external view returns (address);
    function amountReceivedFromExchange(uint amount) external pure returns (uint);
}

abstract contract ExchangeWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes4 => ISynth) public synths;
    IFeePool public feePool;
    address public proxy;

    constructor(address _feePool, address _proxy) {
        feePool = IFeePool(_feePool);
        proxy = _proxy;
    }

    function _internalExchange(
        address from,
        bytes4 sourceCurrencyKey,
        uint sourceAmount,
        bytes4 destinationCurrencyKey,
        address destinationAddress,
        bool chargeFee
    ) internal returns (bool) {
        require(destinationAddress != address(0), ""Zero destination"");
        require(destinationAddress != address(this), ""Synthetix is invalid destination"");
        require(destinationAddress != proxy, ""Proxy is invalid destination"");
        synths[sourceCurrencyKey].burn(from, sourceAmount);
        uint destinationAmount = effectiveValue(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);
        uint amountReceived = destinationAmount;
        uint fee = 0;
        if (chargeFee) {
            amountReceived = feePool.amountReceivedFromExchange(destinationAmount);
            fee = destinationAmount.sub(amountReceived);
        }
        synths[destinationCurrencyKey].issue(destinationAddress, amountReceived);
        if (fee > 0) {
            uint xdrFeeAmount = effectiveValue(destinationCurrencyKey, fee, ""XDR"");
            synths[""XDR""].issue(feePool.FEE_ADDRESS(), xdrFeeAmount);
        }
        synths[destinationCurrencyKey].triggerTokenFallbackIfNeeded(from, destinationAddress, amountReceived);
        return true;
    }

    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey) internal view returns (uint) {
        // Implement the logic to calculate effective value based on currency keys and amounts
        // This is a placeholder for actual implementation details
        return sourceAmount;
    }
}","[{'function': 'triggerTokenFallbackIfNeeded', 'complexity': 0}, {'function': 'amountReceivedFromExchange', 'complexity': 0}, {'function': '_internalExchange', 'complexity': 0}, {'function': 'effectiveValue', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""delegateFeeToFeePool"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""feePool""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'triggerTokenFallbackIfNeeded', 'complexity': 0}, {'function': 'amountReceivedFromExchange', 'complexity': 0}, {'function': '_internalExchange', 'complexity': 0}, {'function': 'effectiveValue', 'complexity': 0}]",6.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Synth {
    using SafeMath for uint256;

    address public feePool;

    function delegateFeeToFeePool(uint256 amount) external {
        require(msg.sender == owner, ""Only the owner can call this function"");

        // Transfer the amount to the fee pool
        SafeMath.transfer(feePool, amount);
    }
}",2.360158920288086,delegateFeeToFeePool,"[{'function': 'delegateFeeToFeePool', 'complexity': 1}]",2.0,74.0,0.4548092216318565,0.002277686287315,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract Synth is Ownable {
    using SafeMath for uint256;

    address public feePool = 0x1111111111111111111111111111111111111111; // fixed value
    bool public initialized = true;
    bytes32 public initValue = bytes32('init');

    constructor() Ownable(msg.sender) {
        feePool = 0x2222222222222222222222222222222222222222; // fixed value
        initialized = true;
        initValue = bytes32('init');
    }

    function delegateFeeToFeePool(uint256 amount) external {
        require(msg.sender == owner, ""Only the owner can call this function"");

        // Transfer the amount to the fee pool
        SafeMath.transfer(feePool, amount);
    }
}"
4746,"Notifies the controller about an approval , for this Campaign all approvals are allowed by default and no extra notifications are needed","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onApprove(address _owner, address _spender, uint256 _amount) public returns (bool) {
        if (isRegistered(_owner)) {
            return true;
        } else {
            return false;
        }
    }

    function isRegistered(address _owner) internal view returns (bool) {
        // Implement the logic to check if the owner is registered
        revert(""Not implemented"");
    }
}","[{'function': 'onApprove', 'complexity': 1}, {'function': 'isRegistered', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""controller""}}, {""type"": ""stringLiteral"", ""value"": ""Only the controller can approve""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""approved""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onApprove', 'complexity': 1}, {'function': 'isRegistered', 'complexity': 0}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Approval {
    using SafeMath for uint256;

    address public controller;
    bool public approved = true;

    constructor(address _controller) public {
        controller = _controller;
    }

    function approve() external {
        require(msg.sender == controller, ""Only the controller can approve"");
        approved = true;
        emit Approval();
    }
}",2.270471334457397,approve,"[{'function': 'approve', 'complexity': 1}]",2.0,21.0,0.6119585233382694,0.0095261137438837,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from in OpenZeppelin

contract Approval is Ownable {
    using SafeMath for uint256;

    address public controller;
    bool public approved = true;

    constructor(address _controller) Ownable(msg.sender) {
        controller = _controller;
    }

    function approve() external {
        require(msg.sender == controller, ""Only the controller can approve"");
        approved = true;
        emit Approval();
    }
}"
5679,Sets the new dividend percentage for buyouts .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContract {
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public buyoutDividendPercentage;

    constructor(uint256 initialBuyoutDividendPercentage) {
        require(2000 <= initialBuyoutDividendPercentage && initialBuyoutDividendPercentage <= 12500);
        buyoutDividendPercentage = initialBuyoutDividendPercentage;
    }
    function setBuyoutDividendPercentage(uint256 _buyoutDividendPercentage) external onlyCFO {
    require(2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500);
    buyoutDividendPercentage = _buyoutDividendPercentage;
}
}","[{'function': 'setBuyoutDividendPercentage', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNewDividendPercentage"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newPercentage"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_newPercentage""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid percentage""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""dividendPercentage""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newPercentage""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setBuyoutDividendPercentage', 'complexity': 0}, {'function': 'setBuyoutDividendPercentage', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

contract BuyoutDividends {
    using SafeMath for uint256;

    // State variables
    uint256 public dividendPercentage;

    // Functions
    function setNewDividendPercentage(uint256 _newPercentage) external {
        require(_newPercentage > 0, ""Invalid percentage"");
        dividendPercentage = _newPercentage;
    }
}",2.1805551052093506,setNewDividendPercentage,"[{'function': 'setNewDividendPercentage', 'complexity': 1}]",2.0,6.0,0.7230598498831777,0.0698152187332062,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BuyoutDividends is Ownable {
    using SafeMath for uint256;

    // State variables
    uint256 public dividendPercentage = 1;

    // Functions
    function setNewDividendPercentage(uint256 _newPercentage) external {
        require(_newPercentage > 0, ""Invalid percentage"");
        dividendPercentage = _newPercentage;
    }
}"
5099,This is mainly an helper function to ` finalize ` but can be used if ` finalize ` has issues with the loop,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balancesToken;
    mapping(address => bool) public isWhitelisted;
    uint256 public tokensFinalized;
    uint256 public constant MAX_TOKENS = 1000000 * (10 ** 18); // Example value, adjust as needed
    IERC20 public token;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    constructor(address _token) {
        token = IERC20(_token);
    }

    function finalizeSingleInvestor(address investorAddr) public onlyOwner {
        require(investorAddr != address(0) && investorAddr != address(this));
        require(balancesToken[investorAddr] > 0);
        require(isWhitelisted[investorAddr] == true);
        uint256 balanceToTransfer = balancesToken[investorAddr];
        balancesToken[investorAddr] = 0;
        isWhitelisted[investorAddr] = false;
        require(token.transfer(investorAddr, balanceToTransfer));
        tokensFinalized = tokensFinalized.add(balanceToTransfer);
        assert(tokensFinalized <= MAX_TOKENS);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'finalizeSingleInvestor', 'complexity': 6}, {'function': 'announceFork', 'complexity': 2}]",7.0,{},"[{'function': 'transfer', 'complexity': 0}, {'function': 'finalizeSingleInvestor', 'complexity': 6}, {'function': 'announceFork', 'complexity': 2}]",7.0,"
pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint256;

    function finalize(uint256 _amount) public {
        // Additional logic can be added here
    }
}

function helperFinalize(uint256 _amount) public returns (bool) {
    // Use a loop to iterate over all the tokens in the contract
    for (uint256 i = 0; i < tokenCount; i++) {
        // Get the current token address and balance
        address tokenAddress = tokens[i];
        uint256 tokenBalance = IERC20(tokenAddress).balanceOf(address(this));

        // Transfer the token to the recipient
        require(IERC20(tokenAddress).transfer(recipient, tokenBalance), ""Transfer failed"");
    }

    return true;
}",4.089579105377197,helperFinalize,"[{'function': 'finalize', 'complexity': 0}, {'function': 'helperFinalize', 'complexity': 2}]",3.0,75.0,0.6266633609504877,0.0963324405662072,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    using SafeMath for uint256;

    address private constant _INIT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address private constant _INIT_ADDRESS_2 = 0x2222222222222222222222222222222222222222; // Replace with actual address
    bool private constant _INIT_BOOL = true;
    bytes32 private constant _INIT_BYTES32 = bytes32('init');
    string private constant _INIT_STRING = 'initialized';

    uint256 private constant _INIT_UINT = 1;

    address public owner;
    uint256 public amount;
    mapping(address => uint256) public balances;

    constructor() Ownable(_INIT_ADDRESS, _INIT_ADDRESS_2, _INIT_BOOL, _INIT_BYTES32, _INIT_STRING) {
        owner = msg.sender;
        amount = _INIT_UINT;
    }

    function finalize(uint256 _amount) public {
        require(msg.sender == owner, ""Only the owner can call this function"");
        amount += _amount;
    }
}"
1617,Suspends a given supported market ( asset ) from use with Compound .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Market {
    function isSupported() external view returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint;

    struct MarketInfo {
        bool isSupported;
    }

    mapping(address => MarketInfo) public markets;

    event SuspendedMarket(address indexed asset);

    function suspendMarket(address asset) external returns (uint) {
        if (msg.sender != owner()) {
            return uint(Error.UNAUTHORIZED);
        }
        if (!markets[asset].isSupported) {
            return uint(Error.NO_ERROR);
        }
        markets[asset].isSupported = false;
        emit SuspendedMarket(asset);
        return uint(Error.NO_ERROR);
    }
}","[{'function': 'isSupported', 'complexity': 0}, {'function': 'suspendMarket', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""suspendMarket"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""market"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""market""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Market not supported by Compound""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isSuspended"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MarketStatus""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""market""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isSuspended""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Market is already suspended""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MarketStatus""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""market""}], ""names"": []}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isSupported', 'complexity': 0}, {'function': 'suspendMarket', 'complexity': 3}]",3.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MarketSuspender {
    using SafeMath for uint256;

    function suspendMarket(address market) public {
        // Check if the market is supported by Compound
        require(market == 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, ""Market not supported by Compound"");

        // Get the current market status
        bool isSuspended = MarketStatus(market);

        // Check if the market is already suspended
        require(!isSuspended, ""Market is already suspended"");

        // Suspend the market
        MarketStatus(market) = true;
    }
}",3.8599703311920166,suspendMarket,"[{'function': 'suspendMarket', 'complexity': 3}]",3.0,27.0,0.7547728518273439,0.0557310465893986,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is how you import OpenZeppelin contracts

contract MarketSuspender is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function suspendMarket(address market) public {
        require(market == 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, ""Market not supported by Compound"");
        bool isSuspended = MarketStatus(market);
        require(!isSuspended, ""Market is already suspended"");
        MarketStatus(market) = true;
    }
}"
4581,set beneficiary - the account receiving platform fees .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public beneficiary;

    function setBeneficiary(address newBeneficiary) external onlyOwner {
        beneficiary = newBeneficiary;
    }
}","[{'function': 'setBeneficiary', 'complexity': 0}]",1.0,{},"[{'function': 'setBeneficiary', 'complexity': 0}]",1.0,"contract MyContract {
    using SafeMath for uint256;

    address public beneficiary;

    constructor(address _beneficiary) public {
        beneficiary = _beneficiary;
    }

    function setBeneficiary(address newBeneficiary) external {
        require(msg.sender == owner, ""Only the contract owner can update the beneficiary"");
        beneficiary = newBeneficiary;
    }
}",2.147960662841797,setBeneficiary,"[{'function': 'setBeneficiary', 'complexity': 1}]",2.0,10.0,0.9167744114108196,0.2961516536011624,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    address public beneficiary;

    constructor(address _beneficiary) Ownable() {
        require(_beneficiary != address(0), ""Invalid address"");
        beneficiary = _beneficiary;
    }

    function setBeneficiary(address newBeneficiary) external onlyOwner {
        require(newBeneficiary != address(0), ""Invalid address"");
        beneficiary = newBeneficiary;
    }
}"
5894,Get the address of channel with a partner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ChannelWrapper {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) partyhash_to_channelpos;
        address[] all_channels;
    }

    function getChannelWith(Data storage self, address partner) public view returns (address) {
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint256 channel_pos = self.partyhash_to_channelpos[party_hash];
        if (channel_pos != 0) {
            return self.all_channels[channel_pos - 1];
        }
    }
}","[{'function': 'getChannelWith', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPartnerAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_partner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""partners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_partner""}}, ""memberName"": ""addr""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getChannelWith', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Channel {
    using SafeMath for uint256;

    struct Partner {
        address addr;
        uint256 balance;
    }

    mapping(address => Partner) partners;

    function getPartnerAddress(address _partner) public view returns (address) {
        return partners[_partner].addr;
    }
}",2.1829769611358643,getPartnerAddress,"[{'function': 'getPartnerAddress', 'complexity': 0}]",1.0,21.0,0.6277911171233745,0.0774032381694493,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of adding Ownable functionality

contract Channel is Ownable {
    using SafeMath for uint256;

    struct Partner {
        address addr;
        uint256 balance;
    }

    mapping(address => Partner) partners;

    function getPartnerAddress(address _partner) public view returns (address) {
        return partners[_partner].addr;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            partners[addr] = Partner({addr: addr, balance: 1});
        }
    }
}"
1558,function mint to be executed by Manager of token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract MintableToken is Ownable, IERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyManager() {
        require(owner() == msg.sender, ""Only the manager can call this function"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function mint(address target, uint256 mintedAmount) public onlyManager whenNotPaused {
        require(target != address(0), ""Invalid target address"");
        require(mintedAmount > 0, ""Mint amount must be greater than zero"");
        require(balanceOf[target].add(mintedAmount) >= balanceOf[target], ""SafeMath: addition overflow"");
        require(totalSupply.add(mintedAmount) >= totalSupply, ""SafeMath: addition overflow"");
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(0), target, mintedAmount);
        emit Transfer(target, target, mintedAmount);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'mint', 'complexity': 4}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Token""}, ""name"": ""token"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Token""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": [""owner"", ""amount""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""token""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyManager"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'mint', 'complexity': 4}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    struct Token {
        address owner;
        uint256 amount;
    }

    mapping(address => Token) public tokens;

    function mint(address _to, uint256 _amount) public onlyManager {
        require(_amount > 0, ""Invalid amount"");

        Token memory token = Token({
            owner: _to,
            amount: _amount
        });

        tokens[_to] = token;
    }

    function getToken(address _owner) public view returns (Token memory) {
        return tokens[_owner];
    }
}",3.4950454235076904,mint,"[{'function': 'mint', 'complexity': 1}, {'function': 'getToken', 'complexity': 0}]",2.0,57.0,0.7558964462355272,0.0331463755368932,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Token {
        address owner;
        uint256 amount;
    }

    mapping(address => Token) public tokens;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function mint(address _to, uint256 _amount) public onlyOwner {
        require(_amount > 0, ""Invalid amount"");

        Token memory token = Token({
            owner: _to,
            amount: _amount
        });

        tokens[_to] = token;
    }

    function getToken(address _owner) public view returns (Token memory) {
        return tokens[_owner];
    }
}"
2515,A getter to look up a Admin 's details,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminStorage {
    using SafeMath for uint256;

    struct PledgeAdmin {
        // Define the structure of PledgeAdmin here if needed
    }

    PledgeAdmin[] private admins;

    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {
        require(idAdmin < admins.length, ""Index out of bounds"");
        return admins[idAdmin];
    }
}","[{'function': 'findAdmin', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAdminDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""adminId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""Identifier"", ""name"": ""adminId""}}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""Identifier"", ""name"": ""adminId""}}, ""memberName"": ""id""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""admins""}, ""index"": {""type"": ""Identifier"", ""name"": ""adminId""}}, ""memberName"": ""walletAddress""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'findAdmin', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

contract Admin {
    struct Details {
        string name;
        uint256 id;
        address walletAddress;
    }

    mapping(uint256 => Details) public admins;

    function getAdminDetails(uint256 adminId) public view returns (string memory, uint256, address) {
        return (admins[adminId].name, admins[adminId].id, admins[adminId].walletAddress);
    }
}",2.4001832008361816,getAdminDetails,"[{'function': 'getAdminDetails', 'complexity': 0}]",1.0,15.0,0.6757136963865326,0.0298474589600982,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Admin is Ownable {
    struct Details {
        string name;
        uint256 id;
        address walletAddress;
    }

    mapping(uint256 => Details) public admins;

    constructor() Ownable(msg.sender) {
        for (uint256 i = 1; i <= 3; i++) {
            admins[i] = Details({
                name: 'initialized',
                id: 1,
                walletAddress: address(uint160(uint256(keccak256(abi.encodePacked('address-', uint2str(i))))))
            });
        }
    }

    function getAdminDetails(uint256 adminId) public view returns (string memory, uint256, address) {
        return (admins[adminId].name, admins[adminId].id, admins[adminId].walletAddress);
    }
}

library Utils {
    function uint2str(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        bytes memory buffer = new bytes(32);
        uint256 i;
        while (value > 0) {
            buffer[i++] = byte(uint8(48 + value % 10));
            value /= 10;
        }
        return string(buffer);
    }
}"
4942,"enables withdrawals , only callable by the owner when the withdrawals are disabled","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bool public withdrawalEnabled = false;
    event WithdrawalEnabled(address indexed owner);

    modifier whenStopped() {
        require(!withdrawalEnabled, ""Withdrawal is enabled"");
        _;
    }

    modifier whenWithdrawalDisabled() {
        require(!withdrawalEnabled, ""Withdrawal is already enabled"");
        _;
    }

    function enableWithdrawal() public onlyOwner whenStopped whenWithdrawalDisabled {
        withdrawalEnabled = true;
        emit WithdrawalEnabled(owner());
    }
}","[{'function': 'enableWithdrawal', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableWithdrawals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""withdrawalsDisabled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenWithdrawalsDisabled"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'enableWithdrawal', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract WithdrawalContract {
    address public owner;
    bool public withdrawalsDisabled = true;

    constructor() public {
        owner = msg.sender;
    }

    function enableWithdrawals() external onlyOwner whenWithdrawalsDisabled {
        withdrawalsDisabled = false;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function."");
        _;
    }

    modifier whenWithdrawalsDisabled() {
        require(!withdrawalsDisabled, ""Withdrawals are already enabled."");
        _;
    }
}",3.1732594966888428,enableWithdrawals,"[{'function': 'enableWithdrawals', 'complexity': 0}]",1.0,6.0,0.867885486382816,0.0232728482874673,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WithdrawalContract is Ownable {
    bool public withdrawalsDisabled = true;

    constructor() Ownable(msg.sender) {
        // No need to initialize owner as it's done in the parent constructor
    }

    function enableWithdrawals() external onlyOwner whenWithdrawalsDisabled {
        withdrawalsDisabled = false;
    }

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Only the owner can call this function."");
        _;
    }

    modifier whenWithdrawalsDisabled() {
        require(!withdrawalsDisabled, ""Withdrawals are already enabled."");
        _;
    }
}"
3452,Called by moduleFactory owner to register new modules for SecurityToken to use,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    function registerModule(address _moduleFactory) external returns (bool) {
        // Implementation of the registration logic
        return true;
    }
}","[{'function': 'registerModule', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Owner cannot be 0x0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""isActive""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Module is already active""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Module""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_name""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": [""owner"", ""name"", ""isActive""]}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'registerModule', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract ModuleRegistry {
    using SafeMath for uint256;

    struct Module {
        address owner;
        string name;
        bool isActive;
    }

    mapping(address => Module[]) public modules;

    function registerModule(string memory _name, address _owner) public {
        require(_owner != address(0), ""Owner cannot be 0x0"");
        require(!modules[_owner].isActive, ""Module is already active"");

        modules[_owner].push(Module({
            owner: _owner,
            name: _name,
            isActive: true
        }));
    }
}",3.261230945587158,registerModule,"[{'function': 'registerModule', 'complexity': 3}]",3.0,30.0,0.6548981136898455,0.0205047620977871,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of adding an Ownable contract

contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    struct Module {
        address owner;
        string name;
        bool isActive;
    }

    mapping(address => Module[]) public modules;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function registerModule(string memory _name, address _owner) public {
        require(_owner != address(0), ""Owner cannot be 0x0"");
        require(!modules[_owner].isActive, ""Module is already active"");

        modules[_owner].push(Module({
            owner: _owner,
            name: _name,
            isActive: true
        }));
    }
}"
1228,This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IWPR {
    function totalSupply() external view returns (uint256);
    function mint(address to, uint256 amount) external;
    function finishMinting() external returns (bool);
    function transferOwnership(address newOwner) external;
}

abstract contract WPRCrowdsale is Ownable {
    using SafeMath for uint256;

    IWPR public wpr;
    address public teamHolder;
    address public communityHolder;
    address public futureHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;

    event Finalized(uint256 indexed finalizedBlock);

    constructor(IWPR _wpr, address _teamHolder, address _communityHolder, address _futureHolder, uint256 _startTime, uint256 _endTime) {
        wpr = _wpr;
        teamHolder = _teamHolder;
        communityHolder = _communityHolder;
        futureHolder = _futureHolder;
        startTime = _startTime;
        endTime = _endTime;
    }

    function getBlockTimestamp() internal view returns (uint256) {
        return block.timestamp;
    }

    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }

    function weiToCollect() public view returns (uint256) {
        // Implement the logic to calculate the amount of Wei collected if needed.
        return 0; // Placeholder implementation.
    }

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == owner || getBlockTimestamp() > endTime || weiToCollect() == 0);

        uint256 CROWDSALE_PCT = 62;
        uint256 TEAMHOLDER_PCT = 20;
        uint256 COMMUNITYHOLDER_PCT = 15;
        uint256 FUTUREHOLDER_PCT = 3;
        assert(CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100);

        uint256 tokenCap = wpr.totalSupply().mul(100).div(CROWDSALE_PCT);
        wpr.mint(teamHolder, tokenCap.mul(TEAMHOLDER_PCT).div(100));
        wpr.mint(communityHolder, tokenCap.mul(COMMUNITYHOLDER_PCT).div(100));
        wpr.mint(futureHolder, tokenCap.mul(FUTUREHOLDER_PCT).div(100));

        require(wpr.finishMinting());
        wpr.transferOwnership(owner);

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}","[{'function': 'transferOwnership', 'complexity': 0}, {'function': 'getBlockTimestamp', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'weiToCollect', 'complexity': 0}, {'function': 'finalize', 'complexity': 7}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""contribute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid contribution""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""amount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferOwnership', 'complexity': 0}, {'function': 'getBlockTimestamp', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'weiToCollect', 'complexity': 0}, {'function': 'finalize', 'complexity': 7}]",9.0,"pragma solidity ^0.8.0;

contract Crowdfunding {
    using SafeMath for uint256;

    struct Contribution {
        address contributor;
        uint256 amount;
    }

    mapping(address => Contribution) public contributions;

    function contribute(uint256 _amount) public {
        require(_amount > 0, ""Invalid contribution"");
        contributions[msg.sender].amount = contributions[msg.sender].amount.add(_amount);
    }
}",2.400928735733032,contribute,"[{'function': 'contribute', 'complexity': 1}]",2.0,129.0,0.308665521359991,0.0004040095029062,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Crowdfunding is Ownable {
    using SafeMath for uint256;

    struct Contribution {
        address contributor;
        uint256 amount;
    }

    mapping(address => Contribution) public contributions;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function contribute(uint256 _amount) public {
        require(_amount > 0, ""Invalid contribution"");
        contributions[msg.sender].amount = contributions[msg.sender].amount.add(_amount);
    }
}"
6786,Decrease the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping (address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed newOwner, uint256 value, uint256 fee);

    function decreaseApprovalPreSignedHashing(address _token, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _subtractedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27, _signature[:64], _signature[64:]);
    }

    function decreaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _subtractedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);
        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));
        nonces[_signature] = true;
        uint oldValue = allowed[from][_spender];
        if (_subtractedValue > oldValue) {
            allowed[from][_spender] = 0;
        } else {
            allowed[from][_spender] = oldValue.sub(_subtractedValue);
        }
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}","[{'function': 'decreaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'decreaseApprovalPreSigned', 'complexity': 5}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""decreaseAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""subtractedValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Owner cannot be 0x0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Spender cannot be 0x0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""spender""}}, ""memberName"": ""subtractedValue""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'decreaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'decreaseApprovalPreSigned', 'complexity': 5}]",5.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping (address => uint256) private _allowed;

    function decreaseAllowance(address owner, address spender, uint256 subtractedValue) public {
        require(owner != address(0), ""Owner cannot be 0x0"");
        require(spender != address(0), ""Spender cannot be 0x0"");

        _allowed[owner][spender] = _allowed[owner][spender].subtractedValue;
    }
}",2.8426499366760254,decreaseAllowance,"[{'function': 'decreaseAllowance', 'complexity': 2}]",3.0,40.0,0.6182328833860584,0.0279700649832347,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract Token is Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) private _allowed;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _allowed[address(0x111)] = 1;
        _allowed[address(0x222)] = 1;
        _allowed[address(0x333)] = 1;
    }

    function decreaseAllowance(address owner, address spender, uint256 subtractedValue) public {
        require(owner != address(0), ""Owner cannot be 0x0"");
        require(spender != address(0), ""Spender cannot be 0x0"");

        _allowed[owner][spender] = _allowed[owner][spender].subtractedValue;
    }
}"
3195,Retrieves the encryption public key of the darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface DarknodeStore {
    function darknodePublicKey(address) external view returns (bytes memory);
}

abstract contract DarknodeWrapper is Ownable {
    using SafeMath for uint256;

    DarknodeStore public store;

    constructor(address _storeAddress) {
        store = DarknodeStore(_storeAddress);
    }

    function getDarknodePublicKey(address _darknodeID) external view returns (bytes memory) {
        return store.darknodePublicKey(_darknodeID);
    }
}","[{'function': 'darknodePublicKey', 'complexity': 0}, {'function': 'getDarknodePublicKey', 'complexity': 0}]",1.0,{},"[{'function': 'darknodePublicKey', 'complexity': 0}, {'function': 'getDarknodePublicKey', 'complexity': 0}]",1.0,"contract DarknodeEncryption {
    using SafeMath for uint256;

    struct Darknode {
        address owner;
        string name;
        bytes32 publicKey;
    }

    mapping(address => Darknode) private darknodes;

    function getDarknodePublicKey(address _darknodeAddress) public view returns (bytes32) {
        require(_darknodeAddress != address(0), ""Invalid darknode address"");

        return darknodes[_darknodeAddress].publicKey;
    }
}",2.4335262775421143,getDarknodePublicKey,"[{'function': 'getDarknodePublicKey', 'complexity': 1}]",2.0,12.0,0.8852783252701525,0.1479337874747362,"contract DarknodeEncryption {
    using SafeMath for uint256;

    struct Darknode {
        address owner;
        string name;
        bytes32 publicKey;
    }

    mapping(address => Darknode) private darknodes;

    // Constructor to initialize the contract with fixed values
    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe, non-corner-case values
        darknodes[msg.sender] = Darknode(
            owner: msg.sender,
            name: 'initialized',
            publicKey: bytes32('init')
        );
    }

    function getDarknodePublicKey(address _darknodeAddress) public view returns (bytes32) {
        require(_darknodeAddress != address(0), ""Invalid darknode address"");

        return darknodes[_darknodeAddress].publicKey;
    }
}"
761,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled;

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function enableTransfers(bool _transfersEnabled) external onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;

    function transferTokens(uint256 amount, address recipient) public {
        require(amount > 0, ""Invalid amount"");
        require(recipient != address(0), ""Invalid recipient"");

        uint256 senderBalance = balances[msg.sender];
        require(senderBalance >= amount, ""Insufficient balance"");

        balances[msg.sender] = senderBalance.sub(amount);
        balances[recipient] = recipient.add(amount);
    }
}",3.1904001235961914,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,48.0,0.450691642936873,0.0045262077249676,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set initial balance to 1 for the owner
    }

    function transferTokens(uint256 amount, address recipient) public {
        require(amount > 0, ""Invalid amount"");
        require(recipient != address(0), ""Invalid recipient"");

        uint256 senderBalance = balances[msg.sender];
        require(senderBalance >= amount, ""Insufficient balance"");

        balances[msg.sender] = senderBalance.sub(amount);
        balances[recipient] = recipient.add(amount);
    }
}"
3170,Set an upgrade agent contract to process the upgrade .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface UpgradeAgent {
    function isUpgradeAgent() external view returns (bool);
    function originalSupply() external view returns (uint256);
}

enum UpgradeState { NotUpgradable, Upgrading }

abstract contract Token {
    using SafeMath for uint256;

    address public upgradeAgent;
    uint256 public totalSupply_;

    function getUpgradeState() internal virtual returns (UpgradeState);
    function canUpgrade() internal virtual returns (bool);

    event UpgradeAgentSet(address indexed agent);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }
}

abstract contract UpgradableToken is Token, Ownable {
    using SafeMath for uint256;

    function setUpgradeAgent(UpgradeAgent _upgradeAgent) external onlyOwner {
        require(canUpgrade(), ""Ensure the token is upgradeable in the first place"");
        require(_upgradeAgent != address(0), ""Ensure upgrade agent address is not blank"");
        require(getUpgradeState() != UpgradeState.Upgrading, ""Ensure upgrade has not started"");

        upgradeAgent = address(_upgradeAgent);
        require(UpgradeAgent(upgradeAgent).isUpgradeAgent(), ""New upgradeAgent must be UpgradeAgent"");
        require(UpgradeAgent(upgradeAgent).originalSupply() == totalSupply_, ""Make sure that token supplies match in source and target token contracts"");

        emit UpgradeAgentSet(upgradeAgent);
    }
}","[{'function': 'originalSupply', 'complexity': 0}, {'function': 'canUpgrade', 'complexity': 0}, {'function': 'setUpgradeAgent', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNewOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid new owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""newOwner""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOwner""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'originalSupply', 'complexity': 0}, {'function': 'canUpgrade', 'complexity': 0}, {'function': 'setUpgradeAgent', 'complexity': 5}]",6.0,"
pragma solidity ^0.8.0;

contract UpgradeAgent {
    using SafeMath for uint256;

    address public owner;
    address public newOwner;
    bool public isUpgrading;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
        isUpgrading = false;
    }

    function setNewOwner(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), ""Invalid new owner"");
        newOwner = _newOwner;
    }

    function upgrade() public onlyOwner {
        require(!isUpgrading, ""Already upgrading"");
        isUpgrading = true;
        // Additional logic can be added here
    }
}",3.5445051193237305,upgrade,"[{'function': 'setNewOwner', 'complexity': 1}, {'function': 'upgrade', 'complexity': 2}]",2.0,42.0,0.6188213033550354,0.004410540837395,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract UpgradeAgent {
    using SafeMath for uint256;

    address public owner;
    address public newOwner;
    bool public isUpgrading;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        isUpgrading = false;
    }

    function setNewOwner(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), ""Invalid new owner"");
        newOwner = _newOwner;
    }

    function upgrade() public onlyOwner {
        require(!isUpgrading, ""Already upgrading"");
        isUpgrading = true;
        // Additional logic can be added here
    }
}"
3368,Check whether an address is a regular address or not .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

    function isRegularAddress(address _addr) public view returns (bool) {
        if (_addr == address(0)) {
            return false;
        }
        uint size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }
}","[{'function': 'isRegularAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkRegularAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_address""}, ""memberName"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isRegularAddress', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract RegularAddress {
    using SafeMath for uint256;

    function checkRegularAddress(address _address) public view returns (bool) {
        return _address.balance > 0;
    }
}",1.2950987815856934,checkRegularAddress,"[{'function': 'checkRegularAddress', 'complexity': 0}]",1.0,16.0,0.7444419188281787,0.126729894269251,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RegularAddress is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function checkRegularAddress(address _address) public view returns (bool) {
        return _address.balance > 0;
    }
}"
5919,Initiates a `` send '' operation towards another user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenStorage {
    function balanceOf(address account) external view returns (uint256);
    function subBalance(address account, uint256 amount) external;
    function addBalance(address account, uint256 amount) external;
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    ITokenStorage public tokenStorage;
    bool public paused = false;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transfer(address _to, uint256 _amount) public userNotBlacklisted(_to) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {
        require(_to != address(0), ""to address cannot be 0x0"");
        require(_amount <= tokenStorage.balanceOf(msg.sender), ""not enough balance to transfer"");
        tokenStorage.subBalance(msg.sender, _amount);
        tokenStorage.addBalance(_to, _amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function setTokenStorage(address _tokenStorage) public onlyOwner {
        tokenStorage = ITokenStorage(_tokenStorage);
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }

    modifier userNotBlacklisted(address user) {
        require(!isBlacklisted[user], ""User is blacklisted"");
        _;
    }

    mapping(address => bool) public isBlacklisted;

    function blacklistUser(address user) public onlyOwner {
        isBlacklisted[user] = true;
    }

    function removeFromBlacklist(address user) public onlyOwner {
        isBlacklisted[user] = false;
    }
}","[{'function': 'addBalance', 'complexity': 0}, {'function': 'transfer', 'complexity': 2}, {'function': 'setTokenStorage', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}, {'function': 'blacklistUser', 'complexity': 0}, {'function': 'removeFromBlacklist', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""send"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can send funds""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""receiver"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""receiver""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receiver""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'addBalance', 'complexity': 0}, {'function': 'transfer', 'complexity': 2}, {'function': 'setTokenStorage', 'complexity': 0}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}, {'function': 'blacklistUser', 'complexity': 0}, {'function': 'removeFromBlacklist', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint256;

    function send(address receiver, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        require(msg.sender == owner(), ""Only the owner can send funds"");
        address payable receiver = payable(receiver);
        receiver.transfer(amount);
    }
}",2.0943539142608643,send,"[{'function': 'send', 'complexity': 2}]",3.0,29.0,0.5596068878643568,0.0638197705812344,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender; // address: Use the sender's address
        initialized = true; // bool: Set to true
        tokenName = ""MyToken""; // string: Set to 'initialized'
        initBytes32 = bytes32('init'); // bytes32: Set to bytes32('init')
    }

    function send(address receiver, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        require(msg.sender == owner(), ""Only the owner can send funds"");
        address payable receiver = payable(receiver);
        receiver.transfer(amount);
    }
}"
4803,This is a state-modifying function that can be called while the contract is paused .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Sale {
        address seller;
        // other sale details
    }

    mapping(uint256 => Sale) public tokenIdToSale;

    function _isOnSale(Sale storage sale) internal view returns (bool) {
        return sale.seller != address(0);
    }

    function _cancelSale(uint256 _tokenId, address seller) internal {
        delete tokenIdToSale[_tokenId];
        emit SaleCancelled(_tokenId, seller);
    }

    function cancelSale(uint256 _tokenId) public {
        Sale storage sale = tokenIdToSale[_tokenId];
        require(_isOnSale(sale));
        address seller = sale.seller;
        require(msg.sender == seller);
        _cancelSale(_tokenId, seller);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': '_isOnSale', 'complexity': 0}, {'function': '_cancelSale', 'complexity': 0}, {'function': 'cancelSale', 'complexity': 2}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""modifyState"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newValue""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""New value must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""state""}, ""right"": {""type"": ""Identifier"", ""name"": ""newValue""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""StateModified""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newValue""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_isOnSale', 'complexity': 0}, {'function': '_cancelSale', 'complexity': 0}, {'function': 'cancelSale', 'complexity': 2}, {'function': 'announceFork', 'complexity': 2}]",3.0,"function modifyState(uint256 newValue) public whenNotPaused returns (bool success) {
    require(newValue > 0, ""New value must be greater than zero"");
    state = newValue;
    emit StateModified(newValue);
    return true;
}",1.3133316040039062,modifyState,"[{'function': 'modifyState', 'complexity': 1}]",4.0,23.0,0.2747986778678559,0.024668208723488,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public state = 1;
    bool internal paused = false;

    event StateModified(uint256 indexed newValue);

    constructor() Ownable(msg.sender) {
        // No additional initialization needed for state variables as they are already set to safe, non-corner-case values.
    }

    function modifyState(uint256 newValue) public whenNotPaused returns (bool success) {
        require(newValue > 0, ""New value must be greater than zero"");
        state = newValue;
        emit StateModified(newValue);
        return true;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }
}"
2141,"Submit the answer for a question , for use by the arbitrator .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

function submitAnswerByArbitrator (bytes32 question_id, bytes32 answer, address answerer) onlyArbitrator(question_id) statePendingArbitration(question_id) bondMustBeZero external {
    require(answerer != NULL_ADDRESS, ""answerer must be provided"");
    emit LogFinalize(question_id, answer);
    questions[question_id].is_pending_arbitration = false;
    _addAnswerToHistory(question_id, answer, answerer, 0, false);
    _updateCurrentAnswer(question_id, answer, 0);
}
}","[{'function': 'submitAnswerByArbitrator ', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAnswer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""questionId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""answerText"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""questionId""}}, ""memberName"": ""submitter""}}, {""type"": ""stringLiteral"", ""value"": ""Only the original submitter can submit an answer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""questionId""}}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Question has not been submitted yet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""questions""}, ""index"": {""type"": ""Identifier"", ""name"": ""questionId""}}, ""memberName"": ""answer""}, ""right"": {""type"": ""Identifier"", ""name"": ""answerText""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'submitAnswerByArbitrator ', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract Arbitration {
    struct Question {
        string text;
        address submitter;
        uint256 timestamp;
    }

    mapping(uint256 => Question) public questions;

    function submitAnswer(uint256 questionId, string memory answerText) public {
        require(msg.sender == questions[questionId].submitter, ""Only the original submitter can submit an answer"");
        require(questions[questionId].timestamp > 0, ""Question has not been submitted yet"");
        questions[questionId].answer = answerText;
    }
}",2.7198195457458496,submitAnswer,"[{'function': 'submitAnswer', 'complexity': 2}]",3.0,31.0,0.694007334993,0.0232800881853927,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Arbitration is Ownable {
    struct Question {
        string text;
        address submitter;
        uint256 timestamp;
        string answer;
    }

    mapping(uint256 => Question) public questions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            questions[i] = Question({
                text: ""initial"",
                submitter: addr,
                timestamp: block.timestamp,
                answer: """"
            });
        }
    }

    function submitAnswer(uint256 questionId, string memory answerText) public {
        require(msg.sender == questions[questionId].submitter, ""Only the original submitter can submit an answer"");
        require(questions[questionId].timestamp > 0, ""Question has not been submitted yet"");
        questions[questionId].answer = answerText;
    }
}"
381,"Get the remaining funds needed to end the auction , calculated at the current GOT price in WEI .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AuctionWrapper is Ownable {
    using SafeMath for uint256;

    uint256 public num_tokens_auctioned;
    uint256 public received_wei;
    uint256 public price_per_token;
    uint256 public token_multiplier;

    function remainingFundsToEndAuction() public view returns (uint256) {
        require(num_tokens_auctioned > 0, ""Number of tokens auctioned must be greater than zero"");
        require(token_multiplier > 0, ""Token multiplier must be greater than zero"");
        uint256 required_wei_at_price = num_tokens_auctioned.mul(price_per_token) / token_multiplier;
        if (required_wei_at_price <= received_wei) {
            return 0;
        }
        return required_wei_at_price.sub(received_wei);
    }
}","[{'function': 'remainingFundsToEndAuction', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""getRemainingFunds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalBids""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'remainingFundsToEndAuction', 'complexity': 6}]",7.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract Auction {
    using SafeMath for uint256;

    function getRemainingFunds() public view returns (uint256) {
        return address(this).balance.sub(totalBids);
    }
}",1.6109251976013184,getRemainingFunds,"[{'function': 'getRemainingFunds', 'complexity': 0}]",1.0,29.0,0.7309320516511406,0.0578284444143102,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming Ownable is imported correctly

contract Auction is Ownable {
    using SafeMath for uint256;

    uint256 public totalBids;

    constructor() Ownable(msg.sender) {
        totalBids = 1; // Set to a non-zero value
    }

    function getRemainingFunds() public view returns (uint256) {
        return address(this).balance.sub(totalBids);
    }
}"
242,Withdraw ETH for ` receiverAddress ` after the auction has canceled .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionCreated, AuctionCanceled, AuctionEnded }
    mapping(address => uint) public bids;
    Stages public stage = Stages.AuctionCreated;

    function proxyWithdraw(address receiverAddress) public atStage(Stages.AuctionCanceled) returns (bool) {
        require(receiverAddress != address(0));
        if (bids[receiverAddress] == 0) {
            return false;
        }
        uint amount = bids[receiverAddress];
        bids[receiverAddress] = 0;
        receiverAddress.transfer(amount);
        assert(bids[receiverAddress] == 0);
        return true;
    }
}","[{'function': 'proxyWithdraw', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawETH"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""auctionEndTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Auction has not ended yet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}}, {""type"": ""stringLiteral"", ""value"": ""Only the receiver can withdraw ETH""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receiverAddress""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'proxyWithdraw', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Auction {
    using SafeMath for uint256;

    address payable public receiverAddress;
    uint256 public auctionEndTime;

    function withdrawETH() external {
        require(auctionEndTime <= block.timestamp, ""Auction has not ended yet"");
        require(msg.sender == receiverAddress, ""Only the receiver can withdraw ETH"");

        uint256 amount = address(this).balance;
        receiverAddress.transfer(amount);
    }
}",2.845877885818481,withdrawETH,"[{'function': 'withdrawETH', 'complexity': 2}]",3.0,36.0,0.6165581206924113,0.1151600110358058,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract Auction is Ownable {
    using SafeMath for uint256;

    address payable public receiverAddress;
    uint256 public auctionEndTime;

    constructor() Ownable(msg.sender) {
        receiverAddress = 0x1111111111111111111111111111111111111111; // fixed value
        auctionEndTime = 1; // fixed value, never 0
    }

    function withdrawETH() external {
        require(auctionEndTime <= block.timestamp, ""Auction has not ended yet"");
        require(msg.sender == receiverAddress, ""Only the receiver can withdraw ETH"");

        uint256 amount = address(this).balance;
        receiverAddress.transfer(amount);
    }
}"
1926,Called when ` _owner ` sends ether to the MiniMe Token contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable override returns (bool) {
        return true;
    }
}","[{'function': 'proxyPayment', 'complexity': 0}]",1.0,{},"[{'function': 'proxyPayment', 'complexity': 0}]",1.0,"
contract MiniMeToken {
    using SafeMath for uint256;

    address private owner;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function receiveEther() external payable {
        require(msg.value > 0, ""Invalid amount"");
        balances[owner] = balances[owner].add(msg.value);
    }
}",2.150092363357544,receiveEther,"[{'function': 'receiveEther', 'complexity': 1}]",2.0,9.0,0.471685803408774,0.0127408104603236,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    address private _owner = msg.sender;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        _owner = msg.sender;
    }

    function receiveEther() external payable {
        require(msg.value > 0, ""Invalid amount"");
        balances[_owner] = balances[_owner].add(msg.value);
    }
}"
6311,Vote for specific proposal with yes or no,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

abstract contract Proposal {
    using SafeMath for uint256;
    struct Proposal {
        address token;
        uint256 yesVotes;
        uint256 noVotes;
    }
    Proposal[] public proposals;
    mapping(uint256 => Proposal) public proposalById;

    event Vote(uint256 indexed proposalId, address indexed voter, bool yes, uint256 amount);

    function vote(uint256 _proposalId, bool _yes) public {
        require(_proposalId < proposals.length, ""Invalid proposal ID"");
        require(checkIfCurrentlyActive(_proposalId), ""Proposal is not active"");
        Proposal memory p = proposals[_proposalId];
        uint256 amount = MiniMeToken(p.token).balanceOf(msg.sender);
        require(amount > 0, ""No tokens to vote with"");
        require(MiniMeToken(p.token).transferFrom(msg.sender, address(this), amount), ""Transfer failed"");
        if (_yes) {
            proposals[_proposalId].yesVotes = proposals[_proposalId].yesVotes.add(amount);
        } else {
            proposals[_proposalId].noVotes = proposals[_proposalId].noVotes.add(amount);
        }
        emit Vote(_proposalId, msg.sender, _yes, amount);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'vote', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""vote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_proposalName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_voteYes"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""voters""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Already voted""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Proposal""}, ""name"": ""proposal"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_proposalName""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""_voteYes""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""voteYes""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""proposal""}, ""memberName"": ""voteNo""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'vote', 'complexity': 5}]",6.0,"pragma solidity ^0.8.0;

contract Voting {
    struct Proposal {
        string name;
        bool voteYes;
        bool voteNo;
    }

    mapping(address => bool) public voters;
    mapping(string => Proposal) public proposals;

    function vote(string memory _proposalName, bool _voteYes) public {
        require(!voters[msg.sender], ""Already voted"");
        Proposal storage proposal = proposals[_proposalName];
        if (_voteYes) {
            proposal.voteYes += 1;
        } else {
            proposal.voteNo += 1;
        }
    }
}",3.152691602706909,vote,"[{'function': 'vote', 'complexity': 3}]",3.0,60.0,0.8158700162510892,0.0273534751685408,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Voting is Ownable {
    struct Proposal {
        string name;
        uint256 voteYes;
        uint256 voteNo;
    }

    mapping(address => bool) public voters;
    mapping(string => Proposal) public proposals;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            proposals[string(abi.encodePacked(""Proposal"", uint2str(i)))] = Proposal({
                name: string(abi.encodePacked(""Proposal"", uint2str(i))),
                voteYes: 0,
                voteNo: 0
            });
        }
    }

    function vote(string memory _proposalName, bool _voteYes) public {
        require(!voters[msg.sender], ""Already voted"");
        Proposal storage proposal = proposals[_proposalName];
        if (_voteYes) {
            proposal.voteYes += 1;
        } else {
            proposal.voteNo += 1;
        }
    }

    function uint2str(uint _i) internal pure returns (string memory str) {
        if (_i == 0) {
            return ""0"";
        }
        uint j = _i;
        uint length;
        while (j != 0) {
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint k = length;
        while (_i != 0) {
            k -= 1;
            uint8 temp = uint8(48 + uint(_i - _i / 10 * 10));
            bstr[k] = byte(temp);
            _i /= 10;
        }
        return string(bstr);
    }
}"
2268,"Executes active investment and redemption requests , in a way that minimises information advantages of investor","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AssetInterface {
    function transferFrom(address, address, uint) external returns (bool);
    function transfer(address, uint) external returns (bool);
}

interface PriceFeedInterface {
    function getInterval() external view returns (uint);
    function getLastUpdateId() external view returns (uint);
    function hasRecentPrice(address) external view returns (bool);
    function getInvertedPrice(address) external view returns (bool, uint, uint);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint;

    struct Request {
        address requestAsset;
        address participant;
        uint shareQuantity;
        uint giveQuantity;
        uint receiveQuantity;
        uint timestamp;
        uint atUpdateId;
        RequestStatus status;
        RequestType requestType;
    }

    enum RequestStatus { active, executed }
    enum RequestType { invest, redeem, tokenFallbackRedeem }

    address public constant NATIVE_ASSET = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint public totalSupply;
    bool public isInvestAllowed;
    bool public isRedeemAllowed;
    mapping(uint => Request) public requests;
    mapping(address => uint) public balances;

    PriceFeedInterface public module;

    constructor(PriceFeedInterface _module) {
        module = _module;
    }

    function executeRequest(uint id) external pre_cond(!isShutDown()) pre_cond(requests[id].status == RequestStatus.active) pre_cond(requests[id].requestType != RequestType.redeem || requests[id].shareQuantity <= balances[requests[id].participant]) pre_cond(totalSupply == 0 || (block.timestamp >= add(requests[id].timestamp, module.getInterval()) && module.getLastUpdateId() >= add(requests[id].atUpdateId, 2))) {
        Request memory request = requests[id];
        require(module.hasRecentPrice(address(request.requestAsset)));
        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees()));
        if (request.requestAsset == address(NATIVE_ASSET)) {
            var (isPriceRecent, invertedNativeAssetPrice, nativeAssetDecimal) = module.getInvertedPrice(address(NATIVE_ASSET));
            require(isPriceRecent);
            costQuantity = mul(costQuantity, invertedNativeAssetPrice) / 10**nativeAssetDecimal;
        }
        if (isInvestAllowed && request.requestType == RequestType.invest && costQuantity <= request.giveQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity));
            createShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.redeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(request.participant, request.shareQuantity);
        } else if (isRedeemAllowed && request.requestType == RequestType.tokenFallbackRedeem && request.receiveQuantity <= costQuantity) {
            requests[id].status = RequestStatus.executed;
            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity));
            annihilateShares(address(this), request.shareQuantity);
        } else {
            revert();
        }
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'getInvertedPrice', 'complexity': 0}, {'function': 'executeRequest', 'complexity': 10}]",18.0,"{""type"": ""FunctionDefinition"", ""name"": ""executeRequests"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Request""}, ""length"": None}, ""name"": ""activeRequests"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Request""}, ""length"": None}}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requests""}, ""memberName"": ""length""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""count"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requests""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""isActive""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""activeRequests""}, ""index"": {""type"": ""Identifier"", ""name"": ""count""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""requests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""count""}, ""isPrefix"": False}}]}, ""FalseBody"": None}]}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""activeRequests""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""activeRequests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""activeRequests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""from""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""activeRequests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""amount""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""activeRequests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""amount""}, {""type"": ""UnaryOperation"", ""operator"": ""-"", ""subExpression"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}, ""isPrefix"": True}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""activeRequests""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""from""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'getInvertedPrice', 'complexity': 0}, {'function': 'executeRequest', 'complexity': 10}]",21.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Investment {
    using SafeMath for uint256;

    struct Request {
        address payable from;
        uint256 amount;
        bool isActive;
    }

    mapping(address => Request) public requests;

    function executeRequests() external {
        // Get the list of all active investment and redemption requests
        Request[] memory activeRequests = new Request[](requests.length);
        uint256 count = 0;
        for (uint256 i = 0; i < requests.length; i++) {
            if (requests[i].isActive) {
                activeRequests[count] = requests[i];
                count++;
            }
        }

        // Execute the active investment and redemption requests in a way that minimises information advantages of investor
        for (uint256 i = 0; i < activeRequests.length; i++) {
            if (activeRequests[i].amount > 0) {
                // Investment request
                activeRequests[i].from.transfer(activeRequests[i].amount);
            } else {
                // Redemption request
                uint256 amount = SafeMath.mul(activeRequests[i].amount, -1);
                activeRequests[i].from.transfer(amount);
            }
        }
    }
}",6.615477800369263,executeRequests,"[{'function': 'executeRequests', 'complexity': 6}]",5.0,116.0,0.7606148293447944,0.0269529206498695,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of adding Ownable functionality

contract Investment is Ownable {
    using SafeMath for uint256;

    struct Request {
        address payable from;
        uint256 amount;
        bool isActive;
    }

    mapping(address => Request) public requests;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < address(this).balance; ++i) {
            requests[address(uint160(i + uint160(1)))] = Request({
                from: payable(address(uint160(i + uint160(1)))),
                amount: 1,
                isActive: true
            });
        }
    }

    function executeRequests() external {
        // Get the list of all active investment and redemption requests
        Request[] memory activeRequests = new Request[](requests.length);
        uint256 count = 0;
        for (uint256 i = 0; i < requests.length; i++) {
            if (requests[i].isActive) {
                activeRequests[count] = requests[i];
                count++;
            }
        }

        // Execute the active investment and redemption requests in a way that minimises information advantages of investor
        for (uint256 i = 0; i < activeRequests.length; i++) {
            if (activeRequests[i].amount > 0) {
                // Investment request
                activeRequests[i].from.transfer(activeRequests[i].amount);
            } else {
                // Redemption request
                uint256 amount = SafeMath.mul(activeRequests[i].amount, -1);
                activeRequests[i].from.transfer(amount);
            }
        }
    }
}"
2205,"Submit the answer for a question , for use by the arbitrator .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorContract is Ownable {
    using SafeMath for uint256;

    struct Question {
        bytes32 questionId;
        bytes32 answer;
        address answerer;
        bool answered;
    }

    mapping(bytes32 => Question) public questions;

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external onlyOwner {
        require(!questions[question_id].answered, ""Question already answered"");
        questions[question_id] = Question({
            questionId: question_id,
            answer: answer,
            answerer: answerer,
            answered: true
        });
    }
}","[{'function': 'submitAnswerByArbitrator', 'complexity': 2}]",2.0,{},"[{'function': 'submitAnswerByArbitrator', 'complexity': 2}]",2.0,"
contract Arbitration {
    struct Question {
        string question;
        address submitter;
        uint256 timestamp;
        bool resolved;
    }

    mapping (address => Question[]) public questionsBySubmitter;
    mapping (uint256 => Question) public questionsById;

    function submitQuestion(string memory _question, address payable _submitter) public {
        uint256 questionId = questionsBySubmitter[_submitter].length + 1;
        questionsBySubmitter[_submitter].push(Question(_question, _submitter, block.timestamp, false));
        questionsById[questionId] = Question(_question, _submitter, block.timestamp, false);
    }

    function answerQuestion(uint256 questionId, string memory _answer) public {
        require(questionsById[questionId].resolved == false, ""Question already resolved"");
        questionsById[questionId].answer = _answer;
        questionsById[questionId].timestamp = block.timestamp;
    }

    function resolveQuestion(uint256 questionId) public {
        require(questionsById[questionId].resolved == false, ""Question already resolved"");
        questionsById[questionId].resolved = true;
    }
}",5.502195358276367,submitQuestion,"[{'function': 'submitQuestion', 'complexity': 0}, {'function': 'answerQuestion', 'complexity': 1}, {'function': 'resolveQuestion', 'complexity': 1}]",1.0,30.0,0.7114713305703121,0.0482202665918465,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Arbitration is Ownable {
    struct Question {
        string question;
        address submitter;
        uint256 timestamp;
        bool resolved;
        string answer; // Assuming there's an 'answer' field added for completeness
    }

    mapping(address => Question[]) public questionsBySubmitter;
    mapping(uint256 => Question) public questionsById;
    uint256 public nextQuestionId = 1;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function submitQuestion(string memory _question, address payable _submitter) public {
        Question storage question = questionsBySubmitter[_submitter].push();
        question.question = _question;
        question.submitter = _submitter;
        question.timestamp = block.timestamp;
        question.resolved = false;
        questionsById[nextQuestionId++] = question;
    }

    function answerQuestion(uint256 questionId, string memory _answer) public {
        require(!questionsById[questionId].resolved, ""Question already resolved"");
        Question storage question = questionsById[questionId];
        question.answer = _answer;
        question.timestamp = block.timestamp;
    }

    function resolveQuestion(uint256 questionId) public {
        require(!questionsById[questionId].resolved, ""Question already resolved"");
        Question storage question = questionsById[questionId];
        question.resolved = true;
    }
}"
6381,Calls transferFrom on the token and reverts if the call fails .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface CompatibleERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {
        CompatibleERC20(token).transferFrom(from, to, amount);
        require(previousReturnValue(), ""transferFrom failed"");
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeTransferFrom', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""success""}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeTransferFrom', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transferFrom(address from, address to, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        require(from != address(0), ""Invalid sender"");
        require(to != address(0), ""Invalid recipient"");

        // Transfer the token
        bool success = IERC20(token).transferFrom(from, to, amount);
        require(success, ""Transfer failed"");
    }
}",2.799960136413574,transferFrom,"[{'function': 'transferFrom', 'complexity': 4}]",5.0,31.0,0.8359855111279048,0.3147280198102892,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    // Fixed, safe values
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        _token = DEFAULT_ADDRESS; // Replace with actual token address
        _name = DEFAULT_STRING;
        _symbol = DEFAULT_STRING;
    }

    uint256 public constant DEFAULT_UINT256 = 1;

    address public token;
    string public name;
    string public symbol;

    function transferFrom(address from, address to, uint256 amount) public {
        require(amount > DEFAULT_UINT256, ""Invalid amount"");
        require(from != address(0), ""Invalid sender"");
        require(to != address(0), ""Invalid recipient"");

        // Transfer the token
        bool success = IERC20(token).transferFrom(from, to, amount);
        require(success, ""Transfer failed"");
    }
}"
5030,Slashes the bond of a guilty trader .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOrderbookContract {
    function orderMatch(bytes32 _orderID) external returns (bytes32);
    function orderTrader(bytes32 _orderID) external view returns (address);
}

interface IRenExBalancesContract {
    function transferBalanceWithFee(address _to, address _from, address _tokenAddress, uint256 _amount, uint256 _fee, bytes32 _data) external;
}

abstract contract Slasher is Ownable {
    using SafeMath for uint256;

    IOrderbookContract public orderbookContract;
    IRenExBalancesContract public renExBalancesContract;
    address public slasherAddress;
    bytes32 public constant RENEX_ATOMIC_SETTLEMENT_ID = 0x0;

    enum OrderStatus { Pending, Settled, Slashed }

    struct TokenPair {
        address tokenA;
        address tokenB;
    }

    struct SettlementDetails {
        address leftTokenAddress;
        uint256 leftTokenFee;
    }

    mapping(bytes32 => OrderStatus) public orderStatus;
    mapping(bytes32 => bytes32) public orderDetails;

    function slash(bytes32 _guiltyOrderID) external onlyOwner {
        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, ""slashing non-atomic trade"");
        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, ""invalid order status"");
        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);
        require(orderStatus[innocentOrderID] == OrderStatus.Settled, ""invalid order status"");
        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;
        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ? (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);
        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);
        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), orderbookContract.orderTrader(innocentOrderID), settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
        renExBalancesContract.transferBalanceWithFee(orderbookContract.orderTrader(_guiltyOrderID), slasherAddress, settlementDetails.leftTokenAddress, settlementDetails.leftTokenFee, 0, 0x0);
    }
}","[{'function': 'orderTrader', 'complexity': 0}, {'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'slash', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""slashTraderBond"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_trader"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Bond""}, ""name"": ""bond"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""traderBonds""}, ""index"": {""type"": ""Identifier"", ""name"": ""_trader""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bond""}, ""memberName"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner of the bond can slash it""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bond""}, ""memberName"": ""amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bond""}, ""memberName"": ""amount""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'orderTrader', 'complexity': 0}, {'function': 'transferBalanceWithFee', 'complexity': 0}, {'function': 'slash', 'complexity': 4}]",4.0,"
pragma solidity ^0.8.0;
contract TraderBond {
    using SafeMath for uint256;

    struct Bond {
        address owner;
        uint256 amount;
    }

    mapping(address => Bond) public traderBonds;

    function slashTraderBond(address _trader, uint256 _amount) public {
        require(_amount > 0, ""Amount must be greater than zero"");

        Bond storage bond = traderBonds[_trader];
        require(bond.owner == msg.sender, ""Only the owner of the bond can slash it"");

        bond.amount = bond.amount.sub(_amount);
    }
}",3.159420967102051,slashTraderBond,"[{'function': 'slashTraderBond', 'complexity': 2}]",3.0,85.0,0.5502090236677987,0.0099229661379327,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TraderBond is Ownable {
    using SafeMath for uint256;

    struct Bond {
        address owner;
        uint256 amount;
    }

    mapping(address => Bond) public traderBonds;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function slashTraderBond(address _trader, uint256 _amount) public {
        require(_amount > 0, ""Amount must be greater than zero"");

        Bond storage bond = traderBonds[_trader];
        require(bond.owner == msg.sender, ""Only the owner of the bond can slash it"");

        bond.amount = bond.amount.sub(_amount);
    }
}"
3520,Submit the arbitrator 's answer to a question .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RealityCheck {
    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) external;
}

abstract contract ArbitrationWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => bool) public arbitration_bounties;
    RealityCheck public realitycheck;

    constructor(address _realityCheckAddress) {
        realitycheck = RealityCheck(_realityCheckAddress);
    }

    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) public onlyOwner {
        delete arbitration_bounties[question_id];
        realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);
    }
}","[{'function': 'submitAnswerByArbitrator', 'complexity': 0}, {'function': 'submitAnswerByArbitrator', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAnswer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Question""}, ""name"": ""question"", ""storageLocation"": ""storage"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""answerText"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""question""}, ""memberName"": ""hasVoted""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""You have already voted.""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""question""}, ""memberName"": ""answers""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""answerText""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""question""}, ""memberName"": ""answerCount""}, ""isPrefix"": False}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""question""}, ""memberName"": ""hasVoted""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""AnswerSubmitted""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""question""}, ""memberName"": ""id""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'submitAnswerByArbitrator', 'complexity': 0}, {'function': 'submitAnswerByArbitrator', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Arbitration {
    struct Question {
        string questionText;
        address[] answers;
        uint256 answerCount;
        mapping(address => bool) hasVoted;
    }

    event AnswerSubmitted(uint256 indexed questionId, address indexed submitter);

    function submitAnswer(Question storage question, string memory answerText) public {
        require(!question.hasVoted[msg.sender], ""You have already voted."");
        question.answers.push(answerText);
        question.answerCount++;
        question.hasVoted[msg.sender] = true;
        emit AnswerSubmitted(question.id, msg.sender);
    }
}",3.246134042739868,submitAnswer,"[{'function': 'submitAnswer', 'complexity': 2}]",2.0,31.0,0.6501472146551522,0.0348861153362071,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Arbitration is Ownable {
    struct Question {
        string questionText;
        address[] answers;
        uint256 answerCount;
        mapping(address => bool) hasVoted;
    }

    event AnswerSubmitted(uint256 indexed questionId, address indexed submitter);
    uint256 public nextQuestionId = 1;
    mapping(uint256 => Question) public questions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function submitAnswer(uint256 questionId, string memory answerText) public {
        require(!questions[questionId].hasVoted[msg.sender], ""You have already voted."");
        questions[questionId].answers.push(answerText);
        questions[questionId].answerCount++;
        questions[questionId].hasVoted[msg.sender] = true;
        emit AnswerSubmitted(questionId, msg.sender);
    }
}"
4614,Withdraw nomins : Allows the owner to withdraw nomins from this contract if needed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function withdrawNomins(uint amount) external onlyOwner {
        require(address(nomin).balance >= amount, ""Insufficient balance"");
        nomin.transfer(owner(), amount);
    }
}","[{'function': 'withdrawNomins', 'complexity': 1}]",2.0,{},"[{'function': 'withdrawNomins', 'complexity': 1}]",2.0,"contract NominsWithdrawal {
    using SafeMath for uint256;

    address public owner;
    mapping (address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function withdrawNomins(uint256 amount) external {
        require(msg.sender == owner, ""Only the owner can withdraw nomins"");
        uint256 balance = balances[owner];
        require(balance >= amount, ""Insufficient balance"");

        balances[owner] = balance.sub(amount);
    }
}",2.730600357055664,withdrawNomins,"[{'function': 'withdrawNomins', 'complexity': 2}]",3.0,23.0,0.9405588645280902,0.2754303209747913,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract NominsWithdrawal is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        balances[owner] = 1; // Initialize balance to a non-zero value
    }

    function withdrawNomins(uint256 amount) external onlyOwner {
        uint256 balance = balances[owner];
        require(balance >= amount, ""Insufficient balance"");

        balances[owner] = balance.sub(amount);
    }
}"
1147,"Return the final answer to the specified question , provided it matches the specified criteria .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ArbitratorWrapper {
    using SafeMath for uint256;

    struct Question {
        bytes32 content_hash;
        address arbitrator;
        uint32 timeout;
        uint256 bond;
        bytes32 best_answer;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalAnswerIfMatches(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) external constant returns (bytes32) {
        require(content_hash == questions[question_id].content_hash);
        require(arbitrator == questions[question_id].arbitrator);
        require(min_timeout <= questions[question_id].timeout);
        require(min_bond <= questions[question_id].bond);
        return questions[question_id].best_answer;
    }
}","[{'function': 'getFinalAnswerIfMatches', 'complexity': 4}]",5.0,{},"[{'function': 'getFinalAnswerIfMatches', 'complexity': 4}]",5.0,"
contract QuestionAnswer {
    using SafeMath for uint256;

    struct Question {
        string question;
        uint256 answer;
    }

    mapping(string => Question) public questions;

    function getFinalAnswer(string memory _question, uint256 _answer) public view returns (uint256) {
        require(_question.length > 0);
        require(_answer > 0);

        Question storage question = questions[_question];

        if (question.question == _question && question.answer == _answer) {
            return _answer;
        } else {
            revert(""Invalid answer"");
        }
    }
}",3.0187153816223145,getFinalAnswer,"[{'function': 'getFinalAnswer', 'complexity': 4}]",5.0,56.0,0.6780219461555631,0.1154620611405784,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract QuestionAnswer is Ownable {
    using SafeMath for uint256;

    struct Question {
        string question;
        uint256 answer;
    }

    mapping(string => Question) public questions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            questions[string(abi.encodePacked(""question"", uint2str(i)))] = Question({
                question: ""What is the answer to life, the universe, and everything?"",
                answer: 42
            });
        }
    }

    function getFinalAnswer(string memory _question, uint256 _answer) public view returns (uint256) {
        require(_question.length > 0);
        require(_answer > 0);

        Question storage question = questions[_question];

        if (keccak256(abi.encodePacked(question.question)) == keccak256(abi.encodePacked(_question)) && question.answer == _answer) {
            return _answer;
        } else {
            revert(""Invalid answer"");
        }
    }

    function uint2str(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        bytes memory buffer = new bytes(10);
        uint256 length = 0;
        while (temp != 0) {
            buffer[length++] = byte(uint8(48 + temp % 10));
            temp /= 10;
        }
        return string(revertBytes(buffer, length));
    }

    function revertBytes(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {
        require(_start <= _bytes.length);
        bytes memory temp = new bytes(_bytes.length - _start);
        for (uint256 i = 0; i < temp.length; i++) {
            temp[i] = _bytes[_start + i];
        }
        return temp;
    }
}"
6458,This works even if sender does n't own any tokens at the time .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerToOperators;

    function setApprovalForAll(address _operator, bool _approved) external onlyNonZeroAddress(_operator) {
        require(_operator != address(0), ""Operator address must be non-zero"");
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    modifier onlyNonZeroAddress(address addr) {
        require(addr != address(0), ""Address must be non-zero"");
        _;
    }
}","[{'function': 'setApprovalForAll', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Recipient cannot be the zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}, {""type"": ""stringLiteral"", ""value"": ""Sender does not have enough tokens to transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setApprovalForAll', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transferTokens(address sender, address recipient, uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        require(recipient != address(0), ""Recipient cannot be the zero address"");

        // Check if the sender has enough tokens to transfer
        uint256 balance = IERC20(sender).balanceOf(sender);
        require(amount <= balance, ""Sender does not have enough tokens to transfer"");

        // Transfer tokens from sender to recipient
        IERC20(recipient).transferFrom(sender, amount);
    }
}",3.637425184249878,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",5.0,30.0,0.3831693127584155,0.0877533612876688,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is a standard library or contract for ownership management
import ""IERC20.sol""; // Assuming this is an interface for ERC20 tokens

contract MyContract is Ownable {
    using SafeMath for uint256;

    function transferTokens(address sender, address recipient, uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        require(recipient != address(0), ""Recipient cannot be the zero address"");

        // Check if the sender has enough tokens to transfer
        uint256 balance = IERC20(sender).balanceOf(sender);
        require(amount <= balance, ""Sender does not have enough tokens to transfer"");

        // Transfer tokens from sender to recipient
        IERC20(recipient).transferFrom(sender, amount);
    }
}"
732,Used by a controller to execute a forced transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) external onlyOwner {
        require(_to != address(0), ""Invalid recipient address"");
        (bool success, ) = _to.call{value: _value}(_data);
        require(success, ""Transfer failed"");
        if (_log.length > 0) {
            emit LogData(_log);
        }
    }

    event LogData(bytes log);
}","[{'function': 'forceTransfer', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""executeForcedTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Recipient cannot be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'forceTransfer', 'complexity': 3}]",5.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract ForcedTransfer {
    using SafeMath for uint256;

    function executeForcedTransfer(address payable recipient, uint256 amount) public {
        require(recipient != address(0), ""Recipient cannot be zero address"");
        require(amount > 0, ""Amount must be greater than zero"");
        recipient.transfer(amount);
    }
}",2.699047803878784,executeForcedTransfer,"[{'function': 'executeForcedTransfer', 'complexity': 2}]",3.0,28.0,0.666159397472514,0.1397340868661397,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ForcedTransfer is SafeERC20, Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function executeForcedTransfer(address payable recipient, uint256 amount) public {
        require(recipient != address(0), ""Recipient cannot be zero address"");
        require(amount > 0, ""Amount must be greater than zero"");
        recipient.transfer(amount);
    }
}"
442,"Ends the auction , preventing new bids from entering","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Auction {
    using SafeMath for uint256;

    enum state { active, ended }
    state public status;

    constructor() {
        status = state.active;
    }

    function endAuction() public onlyOwner {
        require(status == state.active);
        status = state.ended;
        emit Ended(block.number);
    }

    event Ended(uint256 indexed blockNumber);
}","[{'function': 'endAuction', 'complexity': 1}]",2.0,{},"[{'function': 'endAuction', 'complexity': 1}]",2.0,"
contract Auction {
    using SafeMath for uint256;

    struct Bid {
        address bidder;
        uint256 amount;
    }

    mapping(address => Bid) public bids;

    function endAuction() public {
        require(msg.sender == owner, ""Only the owner can end the auction"");
        require(!ended, ""The auction has already ended"");

        // Calculate the total amount of bids
        uint256 totalBids = 0;
        for (uint256 i = 0; i < bids.length; i++) {
            totalBids = totalBids.add(bids[i].amount);
        }

        // Calculate the winning bid and set it as the auction winner
        uint256 winningBid = totalBids / 2;
        address winner = bids[winningBid].bidder;

        // Transfer the funds to the winner
        payable(winner).transfer(totalBids);

        // Set the auction as ended
        ended = true;
    }
}",4.879402160644531,endAuction,"[{'function': 'endAuction', 'complexity': 4}]",4.0,21.0,0.83030478368195,0.0562599243274484,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    using SafeMath for uint256;

    struct Bid {
        address bidder;
        uint256 amount;
    }

    mapping(address => Bid) public bids;
    bool public ended = false;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            bids[addr] = Bid({bidder: addr, amount: 1});
        }
    }

    function endAuction() public {
        require(msg.sender == owner(), ""Only the owner can end the auction"");
        require(!ended, ""The auction has already ended"");

        // Calculate the total amount of bids
        uint256 totalBids = 0;
        for (uint256 i = 0; i < 3; i++) {
            address bidderAddr = bids[address(uint160(i + 1))].bidder;
            uint256 bidAmount = bids[address(uint160(i + 1))].amount;
            totalBids = totalBids.add(bidAmount);
        }

        // Calculate the winning bid and set it as the auction winner
        uint256 winningBid = totalBids / 2;
        address winner;
        for (uint256 i = 0; i < 3; i++) {
            if (bids[address(uint160(i + 1))].amount == winningBid) {
                winner = bids[address(uint160(i + 1))].bidder;
                break;
            }
        }

        // Transfer the funds to the winner
        payable(winner).transfer(totalBids);

        // Set the auction as ended
        ended = true;
    }
}"
3580,Check if a given signed attribute approval is currently valid for a given account when submitted by the operator at ` msg.sender ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeValidator {
    using SafeMath for uint256;

    uint256 private _totalAttributeTypes;
    uint256 private _maxValue;
    uint256 private _maxFundsRequired;
    uint256 private _maxValidatorFee;
    uint256 private _signatureLength;

    constructor(uint256 totalAttributeTypes, uint256 maxValue, uint256 maxFundsRequired, uint256 maxValidatorFee, uint256 signatureLength) {
        require(totalAttributeTypes > 0, ""Invalid total attribute types"");
        require(maxValue > 0, ""Invalid maximum value"");
        require(maxFundsRequired > 0, ""Invalid maximum funds required"");
        require(maxValidatorFee >= 0, ""Invalid maximum validator fee"");
        require(signatureLength > 0, ""Invalid signature length"");

        _totalAttributeTypes = totalAttributeTypes;
        _maxValue = maxValue;
        _maxFundsRequired = maxFundsRequired;
        _maxValidatorFee = maxValidatorFee;
        _signatureLength = signatureLength;
    }

    function canAddAttributeFor(address account, uint256 attributeTypeID, uint256 value, uint256 fundsRequired, uint256 validatorFee, bytes memory signature) external view returns (bool) {
        require(account != address(0), ""Invalid account address"");
        require(attributeTypeID > 0 && attributeTypeID <= _totalAttributeTypes, ""Invalid attribute type ID"");
        require(value >= 0 && value <= _maxValue, ""Invalid value"");
        require(fundsRequired >= 0 && fundsRequired <= _maxFundsRequired, ""Invalid funds required"");
        require(validatorFee >= 0 && validatorFee <= _maxValidatorFee, ""Invalid validator fee"");
        require(signature.length == _signatureLength, ""Invalid signature length"");

        uint256 currentBalance = getCurrentBalanceForAccount(account);
        require(currentBalance >= fundsRequired, ""Insufficient funds"");

        bool isAttributeAdded = isAttributeAlreadyAddedForAccount(account, attributeTypeID);
        require(!isAttributeAdded, ""Attribute already added"");

        return true;
    }

    function getCurrentBalanceForAccount(address account) internal view returns (uint256) {
        // Implement the logic to get the current balance of the account
        // This is a placeholder for the actual implementation
        return 0;
    }

    function isAttributeAlreadyAddedForAccount(address account, uint256 attributeTypeID) internal view returns (bool) {
        // Implement the logic to check if the attribute is already added for the account
        // This is a placeholder for the actual implementation
        return false;
    }
}","[{'function': 'canAddAttributeFor', 'complexity': 13}, {'function': 'getCurrentBalanceForAccount', 'complexity': 0}, {'function': 'isAttributeAlreadyAddedForAccount', 'complexity': 0}]",14.0,"{""type"": ""FunctionDefinition"", ""name"": ""isValidApproval"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""operator""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Operator cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Account cannot be zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""approvedAt"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""operator""}}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""memberName"": ""approvedAt""}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""approvedAt""}, {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'canAddAttributeFor', 'complexity': 13}, {'function': 'getCurrentBalanceForAccount', 'complexity': 0}, {'function': 'isAttributeAlreadyAddedForAccount', 'complexity': 0}]",14.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    struct Approval {
        address account;
        uint256 approvedAt;
    }

    mapping(address => Approval[]) public approvals;

    function isValidApproval(address operator, address account) public view returns (bool) {
        require(operator != address(0), ""Operator cannot be zero"");
        require(account != address(0), ""Account cannot be zero"");

        uint256 approvedAt = approvals[operator][account].approvedAt;
        return SafeMath.add(approvedAt, 1 days) > block.timestamp;
    }
}",3.437495708465576,isValidApproval,"[{'function': 'isValidApproval', 'complexity': 2}]",3.0,76.0,0.4841303939326542,0.0737285615943153,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of adding Ownable functionality

contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Approval {
        address account;
        uint256 approvedAt;
    }

    mapping(address => Approval[]) public approvals;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function isValidApproval(address operator, address account) public view returns (bool) {
        require(operator != address(0), ""Operator cannot be zero"");
        require(account != address(0), ""Account cannot be zero"");

        uint256 approvedAt = approvals[operator][account].approvedAt;
        return SafeMath.add(approvedAt, 1 days) > block.timestamp;
    }
}"
3476,Called when tokens have to be burned ( only after sale ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    bool public locked = false;
    string public contractName;
    address public depositAddress;
    mapping(address => uint256) public balances;
    uint256 public totalSupply_;

    event TokensBurned(address indexed from, address indexed to, uint256 value);

    function burnTokens(uint256 _tokens) external {
        require(!locked, ""Contract is locked"");
        require(contractManager.authorize(contractName, msg.sender), ""Unauthorized access"");
        require(depositAddress != address(0), ""Deposit address not set"");
        require(_tokens != 0, ""Tokens amount must be greater than zero"");
        require(_tokens <= balances[depositAddress], ""Insufficient balance to burn tokens"");

        balances[depositAddress] = balances[depositAddress].sub(_tokens);
        totalSupply_ = totalSupply_.sub(_tokens);
        emit TokensBurned(msg.sender, depositAddress, _tokens);
    }
}","[{'function': 'burnTokens', 'complexity': 6}]",6.0,{},"[{'function': 'burnTokens', 'complexity': 6}]",6.0,"
contract Token {
    using SafeMath for uint256;

    function burn(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");

        // Burn the tokens
        _burn(msg.sender, amount);
    }
}",1.3403961658477783,burn,"[{'function': 'burn', 'complexity': 1}]",2.0,71.0,0.7633752157094558,0.0477255219016294,"contract Token is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 constructor() public Ownable(msg.sender) {
        // Initialize state variables
        owner = msg.sender;
        totalSupply_ = 1;
        balances[owner] = 1;
        name = 'initialized';
        symbol = 'TKN';
    }

    uint256 public totalSupply_;
    mapping(address => uint256) public balances;
    string public name;
    string public symbol;

    function burn(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        _burn(msg.sender, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(balances[account] >= amount, ""Insufficient balance"");
        balances[account] = balances[account].sub(amount);
        totalSupply_ = totalSupply_.sub(amount);
    }
}"
1148,Reusable code to do sanity check of transfer variables,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract TransferCheckWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    bool public tokenTransfersFrozen;

    function transferCheck(address _sender, address _receiver, uint256 _amount) external view returns (bool success) {
        require(!tokenTransfersFrozen, ""Token transfers are frozen"");
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_receiver != address(0), ""Receiver address cannot be the zero address"");
        require(balances[_sender] >= _amount, ""Insufficient balance"");
        require(balances[_receiver] + _amount > balances[_receiver], ""Transfer amount exceeds available balance"");
        return true;
    }
}","[{'function': 'transferCheck', 'complexity': 6}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""sanityCheck"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'transferCheck', 'complexity': 6}]",6.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function sanityCheck(uint256 amount, address recipient) public pure returns (bool) {
        require(amount > 0, ""Invalid amount"");
        require(recipient != address(0), ""Invalid recipient"");

        return true;
    }
}",1.9895377159118648,sanityCheck,"[{'function': 'sanityCheck', 'complexity': 2}]",3.0,30.0,0.6690255015251907,0.122371238211667,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is how you import OpenZeppelin contracts

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        _owner = msg.sender; // Ensure the owner is set correctly
    }

    function sanityCheck(uint256 amount, address recipient) public pure returns (bool) {
        require(amount > 0, ""Invalid amount"");
        require(recipient != address(0), ""Invalid recipient"");

        return true;
    }
}"
5952,Sets the contract that will handle a specific interface ; only the address itself or a ` manager ` defined for that address can set it,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract InterfaceImplementerWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed iHash, address implementer);

    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public onlyOwner {
        interfaces[addr][iHash] = implementer;
        emit InterfaceImplementerSet(addr, iHash, implementer);
    }
}","[{'function': 'setInterfaceImplementer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_manager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_manager""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid manager""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasManager""}, ""index"": {""type"": ""Identifier"", ""name"": ""_manager""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Manager already exists""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""manager""}, ""right"": {""type"": ""Identifier"", ""name"": ""_manager""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasManager""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setInterfaceImplementer', 'complexity': 0}]",1.0,"example of a Solidity smart contract function that meets the requirements you specified:
```
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    address public manager;
    mapping(address => bool) public hasManager;

    function setManager(address _manager) external {
        require(_manager != address(0), ""Invalid manager"");
        if (hasManager[_manager]) {
            revert(""Manager already exists"");
        } else {
            manager = _manager;
            hasManager[msg.sender] = true;
        }
    }
}",5.093483686447144,setManager,"[{'function': 'setManager', 'complexity': 2}]",3.0,25.0,0.4934002563499421,0.0324217949956417,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    address public manager;
    mapping(address => bool) public hasManager;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setManager(address _manager) external {
        require(_manager != address(0), ""Invalid manager"");
        if (hasManager[_manager]) {
            revert(""Manager already exists"");
        } else {
            manager = _manager;
            hasManager[msg.sender] = true;
        }
    }

    // Initialize other state variables
    uint256 public constant MAX_VALUE = 1;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant IS_TRUE = true;
    string public constant INITIALIZED_STRING = ""initialized"";
    bytes32 public constant INIT_BYTES32 = bytes32('init');
}"
5131,Function to know how many tokens you will receive at current time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenPrice {
    function USD(uint256 index) external view returns (uint256);
}

abstract contract TokenCalculator is Ownable {
    using SafeMath for uint256;

    ITokenPrice public price;

    constructor(address _priceAddress) {
        price = ITokenPrice(_priceAddress);
    }

    function calculateTokens(uint256 _amountOfWei) public view returns (uint256) {
        require(_amountOfWei >= 1 szabo, ""Amount must be at least 1 szabo"");
        uint256 tokenBought;
        uint256 tokenPrice = price.USD(0);
        tokenPrice = tokenPrice.mul(36).div(10 ** 8);
        tokenBought = _amountOfWei.div(tokenPrice);
        tokenBought = tokenBought.mul(10 ** 10);
        if (_amountOfWei >= 10 ether) {
            tokenBought = tokenBought.mul(123).div(100);
        } else if (_amountOfWei >= 1 ether) {
            tokenBought = tokenBought.mul(11).div(10);
        }
        return tokenBought;
    }
}","[{'function': 'USD', 'complexity': 0}, {'function': 'calculateTokens', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCurrentTokenAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_price""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'USD', 'complexity': 0}, {'function': 'calculateTokens', 'complexity': 3}]",5.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract TokenExchange {
    using SafeMath for uint256;

    function getCurrentTokenAmount(uint256 _amount, uint256 _price) public view returns (uint256) {
        return _amount.mul(_price);
    }
}",1.704223394393921,getCurrentTokenAmount,"[{'function': 'getCurrentTokenAmount', 'complexity': 0}]",1.0,52.0,0.6937259620295484,0.0086587333249073,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of adding Ownable functionality

contract TokenExchange is Ownable {
    using SafeMath for uint256;

    function getCurrentTokenAmount(uint256 _amount, uint256 _price) public pure returns (uint256) {
        return _amount.mul(_price);
    }
}"
725,Checks whether an address is whitelisted in the competition contract and competition is active,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CompetitionWhitelist is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public isWhitelisted;

    function isCompetitionAllowed(address user) public view returns (bool) {
        return isWhitelisted[user];
    }
}","[{'function': 'isCompetitionAllowed', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isWhitelistedAndCompetitionActive"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""right"": {""type"": ""Identifier"", ""name"": ""competitionActive""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isCompetitionAllowed', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Competition {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;
    bool public competitionActive = false;

    function isWhitelistedAndCompetitionActive(address _address) public view returns (bool) {
        return whitelist[_address] && competitionActive;
    }
}",2.0105111598968506,isWhitelistedAndCompetitionActive,"[{'function': 'isWhitelistedAndCompetitionActive', 'complexity': 0}]",2.0,2.0,0.7851247648906929,0.5085991394194219,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract Competition is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;
    bool public competitionActive = false;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function isWhitelistedAndCompetitionActive(address _address) public view returns (bool) {
        return whitelist[_address] && competitionActive;
    }
}"
3756,The sender casts a vote in favour of confiscation of the target account 's nomin balance .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Voting {
    function setupVote(uint motionID) external returns (uint);
}

abstract contract VoteWrapper is Ownable {
    using SafeMath for uint;

    enum Vote { None, Yea, Nay }

    mapping(address => mapping(uint => Vote)) public vote;
    mapping(uint => uint) public votesFor;

    event VotedFor(address indexed voter, uint indexed motionID, uint weight);

    function voteFor(uint motionID, address votingContractAddress) external {
        require(votingContractAddress.call(abi.encodeWithSignature(""setupVote(uint256)"", motionID)), ""Failed to call setupVote"");
        vote[msg.sender][motionID] = Vote.Yea;
        votesFor[motionID] = votesFor[motionID].add(1);
        emit VotedFor(msg.sender, motionID, 1);
    }
}","[{'function': 'setupVote', 'complexity': 0}, {'function': 'voteFor', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""voteForConfiscation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sender""}, ""memberName"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": ""ether""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sender""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": ""ether""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""target""}, ""memberName"": ""nominBalance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""target""}, ""memberName"": ""nominBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": ""ether""}], ""names"": []}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setupVote', 'complexity': 0}, {'function': 'voteFor', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

contract VoteForConfiscation {
    using SafeMath for uint256;

    function voteForConfiscation(address sender, address target) public returns (bool success) {
        // Check if the sender has enough balance to cast a vote
        require(sender.balance >= 10 ether);

        // Transfer 10 ether from the sender to this contract
        sender.transfer(address(this), 10 ether);

        // Confiscate the target account's nomin balance
        target.nominBalance = target.nominBalance.sub(10 ether);

        return true;
    }
}",3.100085020065308,voteForConfiscation,"[{'function': 'voteForConfiscation', 'complexity': 1}]",2.0,29.0,0.5535492576098816,0.0149057398805461,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract VoteForConfiscation is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
        minimumBalance = 10 ether;
    }

    uint256 public constant minimumBalance;

    function voteForConfiscation(address sender, address target) public returns (bool success) {
        // Check if the sender has enough balance to cast a vote
        require(sender.balance >= minimumBalance);

        // Transfer 10 ether from the sender to this contract
        sender.transfer(address(this), minimumBalance);

        // Confiscate the target account's nomin balance
        target.nominBalance = target.nominBalance.sub(minimumBalance);

        return true;
    }
}"
4311,Sets prizes for last tokens and sets prize pool amount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, WinnersAssigned, Finished }
    pointsValidationState public pValidationState;
    uint256 public gameFinishedTime;
    uint256 public adminPool;
    uint256 public prizePool;

    function setEnd() external onlyOwner checkState(pointsValidationState.WinnersAssigned) {
        uint256 balance = address(this).balance;
        adminPool = balance.mul(10).div(100);
        prizePool = balance.mul(90).div(100);
        pValidationState = pointsValidationState.Finished;
        gameFinishedTime = block.timestamp;
        unSetPause();
    }

    function checkState(pointsValidationState state) internal view {
        require(pValidationState == state, ""Invalid state"");
    }

    function unSetPause() internal {
        // Implementation of unSetPause logic
    }
}","[{'function': 'setEnd', 'complexity': 0}, {'function': 'checkState', 'complexity': 1}, {'function': 'unSetPause', 'complexity': 0}]",1.0,{},"[{'function': 'setEnd', 'complexity': 0}, {'function': 'checkState', 'complexity': 1}, {'function': 'unSetPause', 'complexity': 0}]",1.0,"contract PrizePool {
    using SafeMath for uint256;

    struct TokenPrize {
        address owner;
        uint256 amount;
    }

    mapping(uint256 => TokenPrize) public tokenPrizes;

    function setTokenPrizes(address[] memory owners, uint256[] memory amounts) external {
        require(owners.length == amounts.length, ""Invalid input"");

        for (uint256 i = 0; i < owners.length; i++) {
            tokenPrizes[i].owner = owners[i];
            tokenPrizes[i].amount = amounts[i];
        }
    }
}",3.160321950912476,setTokenPrizes,"[{'function': 'setTokenPrizes', 'complexity': 2}]",3.0,47.0,0.4659775929300112,0.01601451847761,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PrizePool is Ownable {
    using SafeMath for uint256;

    struct TokenPrize {
        address owner;
        uint256 amount;
    }

    mapping(uint256 => TokenPrize) public tokenPrizes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            tokenPrizes[i].owner = address(uint160(i + 1));
            tokenPrizes[i].amount = uint256(i + 1);
        }
    }

    function setTokenPrizes(address[] memory owners, uint256[] memory amounts) external {
        require(owners.length == amounts.length, ""Invalid input"");

        for (uint256 i = 0; i < owners.length; i++) {
            tokenPrizes[i].owner = owners[i];
            tokenPrizes[i].amount = amounts[i];
        }
    }
}"
5253,Renouncing to ownership will leave the contract without an owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function renounceOwnership() public override onlyOwner {
        emit OwnershipRenounced(owner());
        _transferOwnership(address(0));
    }
}","[{'function': 'renounceOwnership', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""renounceOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'renounceOwnership', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    constructor() public {
        _owner = msg.sender;
    }

    function renounceOwnership() public onlyOwner {
        delete _owner;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Only the owner can call this function"");
        _;
    }
}",1.921752691268921,renounceOwnership,"[{'function': 'renounceOwnership', 'complexity': 0}]",1.0,9.0,0.9090371494797104,0.1042325717819069,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public constant SOME_CONSTANT = 1; // Example state variable with a fixed value
    address private _owner;

    constructor() {
        _owner = msg.sender;
    }
}"
86,` onlyOwner ` Changes the maximum number of seconds ` securityGuard ` can delay a payment,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public maxSecurityGuardDelay;

    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) external onlyOwner {
        maxSecurityGuardDelay = _maxSecurityGuardDelay;
    }
}","[{'function': 'setMaxSecurityGuardDelay', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMaxDelaySeconds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newMaxDelaySeconds"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newMaxDelaySeconds""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""New maximum delay seconds must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxDelaySeconds""}, ""right"": {""type"": ""Identifier"", ""name"": ""newMaxDelaySeconds""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setMaxSecurityGuardDelay', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract PaymentDelay {
    using SafeMath for uint256;

    address public owner;
    uint256 public maxDelaySeconds;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor() public {
        owner = msg.sender;
        maxDelaySeconds = 0;
    }

    function setMaxDelaySeconds(uint256 newMaxDelaySeconds) public onlyOwner {
        require(newMaxDelaySeconds > 0, ""New maximum delay seconds must be greater than zero"");
        maxDelaySeconds = newMaxDelaySeconds;
    }
}",4.904635190963745,setMaxDelaySeconds,"[{'function': 'setMaxDelaySeconds', 'complexity': 1}]",2.0,7.0,0.7094422128104197,0.018061933874476,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentDelay is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    uint256 public maxDelaySeconds = 1;

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is already handled in the parent constructor
    }

    function setMaxDelaySeconds(uint256 newMaxDelaySeconds) public onlyOwner {
        require(newMaxDelaySeconds > 0, ""New maximum delay seconds must be greater than zero"");
        maxDelaySeconds = newMaxDelaySeconds;
    }
}"
3464,_addModule handles the attachment ( or replacement ) of modules for the ST,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IModuleRegistry {
    function getType() external view returns (uint8);
}

interface IModuleFactory {
    function setupCost() external view returns (uint256);
    function deploy(bytes calldata) external returns (address);
    function getName() external view returns (bytes32);
}

interface ERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract ModuleRegistryWrapper is Ownable {
    using SafeMath for uint256;

    struct ModuleData {
        bytes32 name;
        address module;
    }

    mapping(uint8 => ModuleData[]) public modules;
    address public polyToken;
    uint8 constant MAX_MODULES = 10;

    event LogModuleAdded(uint8 indexed moduleType, bytes32 indexed moduleName, address indexed moduleFactory, address module, uint256 cost, uint256 budget, uint256 timestamp);

    function _addModule(address _moduleFactory, bytes memory _data, uint256 _maxCost, uint256 _budget) internal {
        IModuleRegistry moduleRegistry = IModuleRegistry(_moduleFactory);
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint8 moduleType = moduleFactory.getType();
        require(modules[moduleType].length < MAX_MODULES, ""Limit of MAX MODULES is reached"");
        uint256 moduleCost = moduleFactory.setupCost();
        require(moduleCost <= _maxCost, ""Max Cost is always be greater than module cost"");
        require(ERC20(polyToken).approve(_moduleFactory, moduleCost), ""Not able to approve the module cost"");
        address module = moduleFactory.deploy(_data);
        require(ERC20(polyToken).approve(module, _budget), ""Not able to approve the budget"");
        bytes32 moduleName = moduleFactory.getName();
        modules[moduleType].push(ModuleData(moduleName, module));
        emit LogModuleAdded(moduleType, moduleName, _moduleFactory, module, moduleCost, _budget, block.timestamp);
    }
}","[{'function': 'getType', 'complexity': 0}, {'function': 'getName', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': '_addModule', 'complexity': 4}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""_addModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_moduleIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_moduleAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Module address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_moduleIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_moduleIndex""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid module index""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""modules""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""moduleIndices""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_moduleIndex""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getType', 'complexity': 0}, {'function': 'getName', 'complexity': 0}, {'function': 'approve', 'complexity': 0}, {'function': '_addModule', 'complexity': 4}]",8.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function _addModule(address _moduleAddress, uint256 _moduleIndex) public {
        require(_moduleAddress != address(0), ""Module address cannot be zero"");
        require(_moduleIndex > 0 && _moduleIndex <= 100, ""Invalid module index"");

        // Add the module to the list of modules for this contract
        modules.push(_moduleAddress);

        // Set the module's index in the list to the specified value
        moduleIndices[_moduleAddress] = _moduleIndex;
    }
}",3.1377289295196533,_addModule,"[{'function': '_addModule', 'complexity': 3}]",4.0,81.0,0.6565344187048494,0.0307895798802586,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract MyContract is Ownable {
    using SafeMath for uint256;

    address[] public modules;
    mapping(address => uint256) public moduleIndices;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')

        modules.push(address(0x111));
        moduleIndices[address(0x111)] = 1;

        // Assuming there are more addresses and they follow a pattern, e.g., incrementing by 0x10...
        modules.push(address(0x222));
        moduleIndices[address(0x222)] = 2;

        modules.push(address(0x333));
        moduleIndices[address(0x333)] = 3;
    }

    function _addModule(address _moduleAddress, uint256 _moduleIndex) public {
        require(_moduleAddress != address(0), ""Module address cannot be zero"");
        require(_moduleIndex > 0 && _moduleIndex <= 100, ""Invalid module index"");

        // Add the module to the list of modules for this contract
        modules.push(_moduleAddress);

        // Set the module's index in the list to the specified value
        moduleIndices[_moduleAddress] = _moduleIndex;
    }
}"
2419,Return the permissions flag that are associated with Module,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PermissionsContract is Ownable {
    using SafeMath for uint256;

    bytes32[] private permissions;

    function getPermissions() public view returns (bytes32[]) {
        return permissions;
    }
}","[{'function': 'getPermissions', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getModulePermissions"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""moduleId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""permissions"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""moduleId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid module ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Module""}, ""name"": ""module"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""Modules""}, ""index"": {""type"": ""Identifier"", ""name"": ""moduleId""}}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""module""}, ""memberName"": ""permissions""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getPermissions', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./Permissions.sol"";
import ""./Modules.sol"";

contract MyContract {
    using SafeMath for uint256;

    function getModulePermissions(uint256 moduleId) public view returns (uint256 permissions) {
        require(moduleId > 0, ""Invalid module ID"");
        Module memory module = Modules[moduleId];
        return module.permissions;
    }
}",2.223465204238892,getModulePermissions,"[{'function': 'getModulePermissions', 'complexity': 1}]",2.0,17.0,0.691231461640344,0.1353916148720782,"pragma solidity ^0.8.0;

import ""./Permissions.sol"";
import ""./Modules.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is the correct import for Ownable
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable, Modules {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        moduleId = 1;
        modules[moduleId] = Module({permissions: 1});
    }

    function getModulePermissions(uint256 moduleId) public view returns (uint256 permissions) {
        require(moduleId > 0, ""Invalid module ID"");
        Module memory module = Modules[moduleId];
        return module.permissions;
    }
}"
3265,"Called by the owner to unpause , returns to normal state","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused;

    event Unpause(uint256 timestamp);

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function _unpause() internal whenPaused {
        paused = false;
        emit Unpause(block.timestamp);
    }
}","[{'function': '_unpause', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_unpause', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract MyContract {
    bool public paused = false;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function unpause() external onlyOwner {
        paused = false;
    }
}",1.5055155754089355,unpause,"[{'function': 'unpause', 'complexity': 0}]",1.0,5.0,0.789516026304708,0.1737703992250832,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    bool public paused = false;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function unpause() external onlyOwner {
        paused = false;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        paused = true; // Set to true instead of false as per the requirement
    }
}"
1244,Returns all the relevant information about a specific grey .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GreyWrapper {
    using SafeMath for uint256;

    struct Grey {
        string name;
    }

    mapping(uint256 => Grey) private greys;
    mapping(uint256 => uint256) public greyIndexToPrice;
    mapping(uint256 => address) public greyIndexToOwner;
    mapping(uint256 => uint256) public greyIndexToPreviousPrice;
    mapping(uint256 => address[5]) public greyIndexToPreviousOwners;

    function getGrey(uint256 _tokenId) public view returns (string memory, uint256, address, uint256, address[5] memory) {
        Grey storage grey = greys[_tokenId];
        return (grey.name, greyIndexToPrice[_tokenId], greyIndexToOwner[_tokenId], greyIndexToPreviousPrice[_tokenId], greyIndexToPreviousOwners[_tokenId]);
    }
}","[{'function': 'getGrey', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getGreyInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""greyId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grey""}, ""name"": ""grey"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""greys""}, ""index"": {""type"": ""Identifier"", ""name"": ""greyId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grey""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grey""}, ""memberName"": ""age""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grey""}, ""memberName"": ""weight""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grey""}, ""memberName"": ""height""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getGrey', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract GreyInfo {
    using SafeMath for uint256;

    struct Grey {
        string name;
        uint256 age;
        uint256 weight;
        uint256 height;
    }

    mapping(uint256 => Grey) public greys;

    function getGreyInfo(uint256 greyId) public view returns (string memory, uint256, uint256, uint256) {
        Grey storage grey = greys[greyId];
        return (grey.name, grey.age, grey.weight, grey.height);
    }
}",3.151297807693481,getGreyInfo,"[{'function': 'getGreyInfo', 'complexity': 0}]",1.0,13.0,0.7773642395969338,0.4545303745421133,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract GreyInfo is Ownable {
    using SafeMath for uint256;

    struct Grey {
        string name;
        uint256 age;
        uint256 weight;
        uint256 height;
    }

    mapping(uint256 => Grey) public greys;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) { // Assuming there are up to 3 greys
            greys[i] = Grey({
                name: 'Grey',
                age: uint256(i), // Initialize age based on index
                weight: uint256(i) * 10, // Example initialization for weight
                height: uint256(i) * 20 // Example initialization for height
            });
        }
    }

    function getGreyInfo(uint256 greyId) public view returns (string memory, uint256, uint256, uint256) {
        Grey storage grey = greys[greyId];
        return (grey.name, grey.age, grey.weight, grey.height);
    }
}"
1531,This method may be deprecated or refactored to allow for multiple interfaces,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LibStorage {
    function setBool(bytes32 id, bool value) external returns (bool);
}

interface TokenXInterface {
    function setAssetCurrency(address asset, string memory currency) external returns (bool);
}

abstract contract TokenXWrapper is Ownable {
    using SafeMath for uint256;

    LibStorage public lib;
    TokenXInterface public tokenX;

    constructor(address _libAddress, address _tokenXAddress) {
        lib = LibStorage(_libAddress);
        tokenX = TokenXInterface(_tokenXAddress);
    }

    function setTokenXCurrency(address asset, string memory currency) public onlyOwner returns (bool success) {
        bytes32 id = keccak256(abi.encodePacked('tokenx', asset, currency));
        require(lib.setBool(id, true), ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."");
        require(tokenX.setAssetCurrency(asset, currency), ""Error: Failed to set asset currency."");
        return true;
    }
}","[{'function': 'setBool', 'complexity': 0}, {'function': 'setAssetCurrency', 'complexity': 0}, {'function': 'setTokenXCurrency', 'complexity': 2}]",3.0,{},"[{'function': 'setBool', 'complexity': 0}, {'function': 'setAssetCurrency', 'complexity': 0}, {'function': 'setTokenXCurrency', 'complexity': 2}]",3.0,"
contract MyContract {
    using SafeMath for uint256;

    function myFunction(uint256 amount) public returns (bool success) {
        require(amount > 0, ""Invalid amount"");
        // Additional logic can be added here
        return true;
    }
}",1.3030714988708496,myFunction,"[{'function': 'myFunction', 'complexity': 1}]",2.0,41.0,0.4115827039214507,0.0518731618926497,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
        someUint = 1;
        someAddress = address(0x111);
        someBool = true;
        someString = ""initialized"";
        someBytes32 = bytes32('init');
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function myFunction(uint256 amount) public returns (bool success) {
        require(amount > 0, ""Invalid amount"");
        // Additional logic can be added here
        return true;
    }
}"
4775,Checks whether the cap has been reached .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    uint256 public totalTokensSold;
    uint256 public cap;

    function capReached() public view returns (bool) {
        return totalTokensSold >= cap;
    }
}","[{'function': 'capReached', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkCapReached"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_cap"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""arguments"": [], ""names"": []}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_cap""}], ""names"": []}, ""memberName"": ""gt""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""cap""}, ""arguments"": [], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'capReached', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function checkCapReached(uint256 _cap) public view returns (bool) {
        return totalSupply().add(_cap).gt(cap());
    }
}",1.591947317123413,checkCapReached,"[{'function': 'checkCapReached', 'complexity': 0}]",1.0,9.0,0.7467360109736358,0.2986723204743082,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        cap = 1; // uint256: Set to 1 (never 0)
        address1 = address(0x111); // address: Use fixed value 0x1111111111111111111111111111111111111111
        address2 = address(0x222); // address: Use fixed value 0x2222222222222222222222222222222222222222
        boolValue = true; // bool: Set to true
        stringValue = 'initialized'; // string: Set to 'initialized'
        bytes32Value = bytes32('init'); // bytes32: Set to bytes32('init')
    }

    uint256 public cap;
    address public address1;
    address public address2;
    bool public boolValue;
    string public stringValue;
    bytes32 public bytes32Value;

    function checkCapReached(uint256 _cap) public view returns (bool) {
        return totalSupply().add(_cap).gt(cap());
    }
}"
39,"Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    function createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) public payable onlyOwner {
        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);
    }

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        // Implementation of the function
    }
}","[{'function': 'createDividendWithCheckpointAndExclusions', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createDividend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_checkpoint"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_excludedAddresses"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""checkpoint""}, ""right"": {""type"": ""Identifier"", ""name"": ""_checkpoint""}}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_excludedAddresses""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""excludedAddresses""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excludedAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createDividendWithCheckpointAndExclusions', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Dividend {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) excludedAddresses;
    uint256 public checkpoint;
    uint256 public totalDividends;

    constructor() public {
        owner = msg.sender;
    }

    function createDividend(uint256 _checkpoint, address[] memory _excludedAddresses) public {
        require(msg.sender == owner);
        checkpoint = _checkpoint;
        for (uint256 i = 0; i < _excludedAddresses.length; i++) {
            excludedAddresses[_excludedAddresses[i]] = true;
        }
    }
}",3.703856229782105,createDividend,"[{'function': 'createDividend', 'complexity': 2}]",3.0,32.0,0.807879058941785,0.0433946712802433,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract Dividend is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public excludedAddresses;
    uint256 public checkpoint = 1; // Set to 1 (never 0)
    uint256 public totalDividends = 1; // Set to 1 (never 0)

    constructor() Ownable(msg.sender) {
        // The base constructor of Ownable is invoked here with msg.sender
    }

    function createDividend(uint256 _checkpoint, address[] memory _excludedAddresses) public onlyOwner {
        require(msg.sender == owner);
        checkpoint = _checkpoint;
        for (uint256 i = 0; i < _excludedAddresses.length; i++) {
            excludedAddresses[_excludedAddresses[i]] = true;
        }
    }
}"
2566,Prevents the seller from cancelling an escrow .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EscrowContract {
    using SafeMath for uint256;

    struct Escrow {
        bool exists;
        uint256 sellerCanCancelAfter;
        address seller;
        address buyer;
        uint256 value;
        uint16 fee;
    }

    mapping(bytes32 => Escrow) public escrows;
    bytes32[] public tradeHashes;
    address public relayer;
    uint256 public constant GAS_doDisableSellerCancel = 50000;

    event SellerCancelDisabled(bytes32 indexed tradeHash);

    function doDisableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _additionalGas) public returns (bool) {
        Escrow memory _escrow;
        bytes32 _tradeHash;
        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
        if (!_escrow.exists) return false;
        if (_escrow.sellerCanCancelAfter == 0) return false;
        escrows[_tradeHash].sellerCanCancelAfter = 0;
        emit SellerCancelDisabled(_tradeHash);
        if (msg.sender == relayer) {
            increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
        }
        return true;
    }

    function getEscrowAndHash(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) public pure returns (Escrow memory, bytes32) {
        Escrow memory escrow = Escrow({
            exists: true,
            sellerCanCancelAfter: block.timestamp + 1 days, // Example value for demonstration
            seller: _seller,
            buyer: _buyer,
            value: _value,
            fee: _fee
        });

        bytes32 tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));
        return (escrow, tradeHash);
    }

    function increaseGasSpent(bytes32 _tradeHash, uint256 _gasAmount) public {
        // Implementation of increasing gas spent
    }
}","[{'function': 'doDisableSellerCancel', 'complexity': 2}, {'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'increaseGasSpent', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelEscrow"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""seller""}}, {""type"": ""stringLiteral"", ""value"": ""Only the seller can cancel the escrow""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""isCancelled""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""The escrow has already been cancelled""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""isCancelled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'doDisableSellerCancel', 'complexity': 2}, {'function': 'getEscrowAndHash', 'complexity': 0}, {'function': 'increaseGasSpent', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

contract Escrow {
    address payable public seller;
    address payable public buyer;
    uint256 public amount;
    bool public isCancelled;

    constructor(address _seller, address _buyer, uint256 _amount) public {
        seller = _seller;
        buyer = _buyer;
        amount = _amount;
        isCancelled = false;
    }

    function cancelEscrow() external {
        require(msg.sender == seller, ""Only the seller can cancel the escrow"");
        require(!isCancelled, ""The escrow has already been cancelled"");
        isCancelled = true;
    }
}",3.288547277450561,cancelEscrow,"[{'function': 'cancelEscrow', 'complexity': 3}]",3.0,52.0,0.6725362161471977,0.0103108312461765,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Escrow is Ownable {
    address payable public seller;
    address payable public buyer;
    uint256 public amount;
    bool public isCancelled;

    constructor(address _seller, address _buyer, uint256 _amount) Ownable(msg.sender) {
        seller = payable(_seller);
        buyer = payable(_buyer);
        amount = _amount;
        isCancelled = false;
    }

    function cancelEscrow() external {
        require(msg.sender == seller, ""Only the seller can cancel the escrow"");
        require(!isCancelled, ""The escrow has already been cancelled"");
        isCancelled = true;
    }
}"
4877,"The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Clawback is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 10 ether; // Example value, adjust as needed
    uint256 public constant OWNER_CLAWBACK_DATE = 1700889600; // Example value, adjust as needed
    uint256 public totalFunding;

    function ownerClawback() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        payable(owner()).transfer(address(this).balance);
    }
}","[{'function': 'ownerClawback', 'complexity': 2}]",3.0,{},"[{'function': 'ownerClawback', 'complexity': 2}]",3.0,"contract Clawback {
    using SafeMath for uint256;

    address public owner;
    uint256 public clawbackDate;

    constructor() public payable {
        owner = msg.sender;
        clawbackDate = block.timestamp + 1 weeks;
    }

    function claimEthers() external {
        require(block.timestamp >= clawbackDate, ""Clawback date not reached"");
        require(msg.sender == owner, ""Only the owner can claim ethers"");

        uint256 balance = address(this).balance;
        payable(owner).transfer(balance);
    }
}",2.9269356727600098,claimEthers,"[{'function': 'claimEthers', 'complexity': 2}]",3.0,28.0,0.6947999404455693,0.2373996630036795,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Clawback is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    uint256 public clawbackDate = block.timestamp + 1 weeks;

    constructor() payable Ownable(msg.sender) {
        // Initialization of state variables is already handled in the base class constructor
    }

    function claimEthers() external {
        require(block.timestamp >= clawbackDate, ""Clawback date not reached"");
        require(msg.sender == owner, ""Only the owner can claim ethers"");

        uint256 balance = address(this).balance;
        payable(owner).transfer(balance);
    }
}"
4681,` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public timeLock;
    uint public absoluteMinTimeLock;

    constructor(uint _absoluteMinTimeLock) {
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    function setTimelock(uint _newTimeLock) public onlyOwner {
        require(_newTimeLock >= absoluteMinTimeLock, ""Time lock must be at least the absolute minimum time lock."");
        timeLock = _newTimeLock;
    }
}","[{'function': 'setTimelock', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTimeLock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newTimeLock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""newTimeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""absoluteMinTimeLock""}}, {""type"": ""stringLiteral"", ""value"": ""New time lock must be greater than or equal to the absolute minimum""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""timeLock""}, ""right"": {""type"": ""Identifier"", ""name"": ""newTimeLock""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setTimelock', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

contract TimeLock {
    address public owner;
    uint256 public timeLock;
    uint256 public absoluteMinTimeLock;

    constructor(address _owner, uint256 _timeLock, uint256 _absoluteMinTimeLock) public {
        owner = _owner;
        timeLock = _timeLock;
        absoluteMinTimeLock = _absoluteMinTimeLock;
    }

    function setTimeLock(uint256 newTimeLock) public onlyOwner {
        require(newTimeLock >= absoluteMinTimeLock, ""New time lock must be greater than or equal to the absolute minimum"");
        timeLock = newTimeLock;
    }
}",3.147958517074585,setTimeLock,"[{'function': 'setTimeLock', 'complexity': 1}]",2.0,0.0,0.880404307483834,0.3011292001539513,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TimeLock {
    address public owner;
    uint256 public timeLock;
    uint256 public absoluteMinTimeLock;

    // Initialize Ownable contract
    constructor() Ownable(msg.sender) public {
        // Initialize instance variables with fixed, safe values
        owner = msg.sender;
        timeLock = 1; // Never set to 0
        absoluteMinTimeLock = 1; // Never set to 0

        // Invoke parent contracts' constructors
        Ownable.constructor();
    }

    function setTimeLock(uint256 newTimeLock) public onlyOwner {
        require(newTimeLock >= absoluteMinTimeLock, ""New time lock must be greater than or equal to the absolute minimum"");
        timeLock = newTimeLock;
    }
}"
5481,Transfer tokens from ` msg.sender ` to another address and then call ` onTransferReceived ` on receiver,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedTransferAndCall is Ownable {
    using SafeMath for uint256;

    function transferAndCall(address _to, uint256 _value, bytes memory _data) public returns (bool) {
        return _to.call{value: _value}(_data);
    }
}","[{'function': 'transferAndCall', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""onTransferReceived""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferAndCall', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transferTokens(address recipient, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        require(recipient != address(0), ""Invalid recipient"");

        uint256 senderBalance = balanceOf(msg.sender);
        require(senderBalance >= amount, ""Insufficient funds"");

        _transfer(msg.sender, recipient, amount);
        onTransferReceived(recipient, amount);
    }
}",2.978368759155273,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,49.0,0.5260333783670413,0.0245200375218078,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender; // address: Use the deployer's address
        balanceOfMap[owner] = 1 ether; // uint256: Set to 1 ether (not zero or a typical initial value)
        initializedFlag = true; // bool: Set to true
        tokenName = ""MyToken""; // string: Set to 'initialized'
        initBytes32 = bytes32('init'); // bytes32: Set to bytes32('init')
    }

    function transferTokens(address recipient, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        require(recipient != address(0), ""Invalid recipient"");

        uint256 senderBalance = balanceOf(msg.sender);
        require(senderBalance >= amount, ""Insufficient funds"");

        _transfer(msg.sender, recipient, amount);
        onTransferReceived(recipient, amount);
    }

    // State variables
    address public owner;
    mapping(address => uint256) public balanceOfMap;
    bool public initializedFlag;
    string public tokenName;
    bytes32 public initBytes32;

    // Internal functions and modifiers can be added here as needed
}"
1824,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Value must be greater than zero"");
        require(msg.sender == _from, ""Sender must match the caller"");
        require(_value <= balanceOf[_from], ""Insufficient balance"");

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid from address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid to address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""currentBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""isApproved"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""isApproved""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}, {""type"": ""stringLiteral"", ""value"": ""Recipient not approved""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 5}]",6.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_value > 0, ""Invalid value"");
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");

        // Check that the sender has enough balance
        uint256 currentBalance = balances[_from];
        require(currentBalance >= _value, ""Insufficient balance"");

        // Check that the recipient is approved
        bool isApproved = approvals[_from][_to];
        require(isApproved == true, ""Recipient not approved"");

        // Transfer tokens
        balances[_from] = currentBalance.sub(_value);
        balances[_to] = balances[_to].add(_value);

        // Emit transfer event
        emit Transfer(_from, _to, _value);

        return true;
    }
}",5.556381464004517,transferFrom,"[{'function': 'transferFrom', 'complexity': 5}]",6.0,24.0,0.9223631012228404,0.4798508670759248,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => bool)) public approvals;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set balance to 1 for the owner
        balances[address(0x111)] = 1; // Set balance to 1 for address 0x1111111111111111111111111111111111111111
        balances[address(0x222)] = 1; // Set balance to 1 for address 0x2222222222222222222222222222222222222222
        approvals[owner()][address(0x333)] = true; // Set approval for owner to address 0x3333333333333333333333333333333333333333
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_value > 0, ""Invalid value"");
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");

        // Check that the sender has enough balance
        uint256 currentBalance = balances[_from];
        require(currentBalance >= _value, ""Insufficient balance"");

        // Check that the recipient is approved
        bool isApproved = approvals[_from][_to];
        require(isApproved == true, ""Recipient not approved"");

        // Transfer tokens
        balances[_from] = currentBalance.sub(_value);
        balances[_to] = balances[_to].add(_value);

        // Emit transfer event
        emit Transfer(_from, _to, _value);

        return true;
    }
}"
1782,Gets the EscrowDeposit based on the input id .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow {
    using SafeMath for uint256;

    struct EscrowDeposit {
        address bidder;
        bytes data;
        uint256 amount;
        bool exists;
    }

    mapping(string => EscrowDeposit) public escrows;

    function getEscrowDeposit(string memory _id) external view returns (address, bytes memory, uint256) {
        require(escrows[_id].exists, ""Escrow does not exist"");
        EscrowDeposit storage escrow = escrows[_id];
        return (escrow.bidder, escrow.data, escrow.amount);
    }
}","[{'function': 'getEscrowDeposit', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getEscrowDeposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""EscrowDeposit""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""id""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""EscrowDeposit""}, ""length"": None}, ""name"": ""escrowDeposits"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""EscrowDeposit""}, ""memberName"": ""getAll""}, ""arguments"": [], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""escrowDeposits""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrowDeposits""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""id""}, ""right"": {""type"": ""Identifier"", ""name"": ""id""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""escrowDeposits""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}]}, ""FalseBody"": None}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Escrow deposit not found""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getEscrowDeposit', 'complexity': 1}]",3.0,"
pragma solidity ^0.8.0;

import ""./EscrowDeposit.sol"";

contract EscrowDepositManager {
    using SafeMath for uint256;

    function getEscrowDeposit(uint256 id) public view returns (EscrowDeposit memory) {
        require(id > 0, ""Invalid ID"");
        EscrowDeposit[] memory escrowDeposits = EscrowDeposit.getAll();
        for (uint256 i = 0; i < escrowDeposits.length; i++) {
            if (escrowDeposits[i].id == id) {
                return escrowDeposits[i];
            }
        }
        revert(""Escrow deposit not found"");
    }
}",3.5342702865600586,getEscrowDeposit,"[{'function': 'getEscrowDeposit', 'complexity': 4}]",4.0,31.0,0.8242922230822307,0.0960893655979421,"pragma solidity ^0.8.0;

import ""./EscrowDeposit.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming you have this import for Ownable
import ""openzeppelin/SafeMath.sol"";
contract EscrowDepositManager is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getEscrowDeposit(uint256 id) public view returns (EscrowDeposit memory) {
        require(id > 0, ""Invalid ID"");
        EscrowDeposit[] memory escrowDeposits = EscrowDeposit.getAll();
        for (uint256 i = 0; i < escrowDeposits.length; i++) {
            if (escrowDeposits[i].id == id) {
                return escrowDeposits[i];
            }
        }
        revert(""Escrow deposit not found"");
    }
}"
3204,Remove ` _value ` tokens from the system irreversibly,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balances(address account) external view returns (uint256);
    function totalBhinneka() external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalBhinneka;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalBhinneka = totalBhinneka.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}","[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,{},"[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function removeValueTokens(uint256 _value) public {
        // Additional logic can be added here
    }
}",1.88129997253418,removeValueTokens,"[{'function': 'removeValueTokens', 'complexity': 0}]",1.0,44.0,0.3933916235970039,0.0420335336260747,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        value = 1;
        address1 = address(0x111);
        address2 = address(0x222);
        address3 = address(0x333);
        isTrue = true;
        tokenName = 'initialized';
        bytes32Init = bytes32('init');
    }

    uint256 public value;
    address public address1;
    address public address2;
    address public address3;
    bool public isTrue;
    string public tokenName;
    bytes32 public bytes32Init;

    function removeValueTokens(uint256 _value) public {
        // Additional logic can be added here
    }
}"
1281,Function for attester to submit attestation from their own account ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttestationContract is Ownable {
    using SafeMath for uint256;

    function attest(address _subject, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) external {
        require(_subject != address(0), ""Invalid subject address"");
        require(_requester != address(0), ""Invalid requester address"");
        require(_reward > 0, ""Reward must be greater than zero"");
        require(_requestNonce != bytes32(0), ""Request nonce cannot be empty"");

        // Assuming attestForUser is defined elsewhere in the contract or imported library
        attestForUser(_subject, msg.sender, _requester, _reward, _requesterSig, _dataHash, _requestNonce, _subjectSig);
    }

    function attestForUser(address _subject, address _attester, address _requester, uint256 _reward, bytes memory _requesterSig, bytes32 _dataHash, bytes32 _requestNonce, bytes memory _subjectSig) internal {
        // Implementation of the actual attestation logic
    }
}","[{'function': 'attest', 'complexity': 4}, {'function': 'attestForUser', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""submitAttestation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_message"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_hash"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_message""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Message cannot be empty""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_hash""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Hash must be 32 bytes long""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Attestation""}, ""name"": ""attestation"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""attestations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attestation""}, ""memberName"": ""attester""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attestation""}, ""memberName"": ""message""}, ""right"": {""type"": ""Identifier"", ""name"": ""_message""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""attestation""}, ""memberName"": ""hash""}, ""right"": {""type"": ""Identifier"", ""name"": ""_hash""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'attest', 'complexity': 4}, {'function': 'attestForUser', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;

contract Attestation {
    using SafeMath for uint256;

    struct Attestation {
        address attester;
        string message;
        bytes32 hash;
    }

    mapping(address => Attestation) public attestations;

    function submitAttestation(string memory _message, bytes32 _hash) public {
        require(_message.length > 0, ""Message cannot be empty"");
        require(_hash.length == 32, ""Hash must be 32 bytes long"");

        Attestation storage attestation = attestations[msg.sender];
        attestation.attester = msg.sender;
        attestation.message = _message;
        attestation.hash = _hash;
    }
}",3.557569980621338,submitAttestation,"[{'function': 'submitAttestation', 'complexity': 2}]",3.0,42.0,0.6384812248541444,0.0522942383898672,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Attestation is Ownable {
    using SafeMath for uint256;

    struct Attestation {
        address attester;
        string message;
        bytes32 hash;
    }

    mapping(address => Attestation) public attestations;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            Attestation storage attestation = attestations[addr];
            attestation.attester = addr;
            attestation.message = ""initialized"";
            attestation.hash = bytes32('init');
        }
    }

    function submitAttestation(string memory _message, bytes32 _hash) public {
        require(_message.length > 0, ""Message cannot be empty"");
        require(_hash.length == 32, ""Hash must be 32 bytes long"");

        Attestation storage attestation = attestations[msg.sender];
        attestation.attester = msg.sender;
        attestation.message = _message;
        attestation.hash = _hash;
    }
}"
4148,"Escrows the ERC721 Token , assigning ownership to this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Escrow is Ownable {
    using SafeMath for uint256;

    address public nonFungibleContract;

    constructor(address _nonFungibleContract) {
        nonFungibleContract = _nonFungibleContract;
    }

    function escrow(address _owner, uint256 _tokenId) external onlyOwner {
        require(_owner != address(0), ""Invalid owner address"");
        (bool success, ) = nonFungibleContract.call(abi.encodeWithSelector(bytes4(keccak256(""safeTransferFrom(address,address,uint256)"")), _owner, address(this), _tokenId));
        require(success, ""Safe transfer failed"");
    }
}","[{'function': 'escrow', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""escrow"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid from address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid to address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'escrow', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeMath.sol"";

contract Escrow is IERC721Receiver {
    using SafeMath for uint256;

    function escrow(address _from, address _to, uint256 _tokenId) external override {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_tokenId > 0, ""Invalid token ID"");

        IERC721(_from).transferFrom(_from, address(this), _tokenId);
        IERC721(address(this)).approve(_to, _tokenId);
    }
}",4.5889623165130615,escrow,"[{'function': 'escrow', 'complexity': 3}]",4.0,31.0,0.7674881679676,0.3148404866360201,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Escrow is Ownable, IERC721Receiver {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function escrow(address _from, address _to, uint256 _tokenId) external override {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_tokenId > 0, ""Invalid token ID"");

        IERC721(_from).transferFrom(_from, address(this), _tokenId);
        IERC721(address(this)).approve(_to, _tokenId);
    }
}"
6515,"Computes the id for a node in a given Grove index which is sha3 ( indexId , id )","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GroveLibWrapper is Ownable {
    using SafeMath for uint256;

    function computeNodeId(bytes32 indexId, bytes32 id) public pure returns (bytes32) {
        return GroveLib.computeNodeId(indexId, id);
    }
}","[{'function': 'computeNodeId', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""computeNodeId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""indexId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""sha3""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""indexId""}, {""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'computeNodeId', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Node {
    using SafeMath for uint256;

    function computeNodeId(uint256 indexId, uint256 id) public pure returns (bytes32) {
        return sha3(indexId, id);
    }
}",1.6528537273406982,computeNodeId,"[{'function': 'computeNodeId', 'complexity': 0}]",1.0,1.0,0.8565263357153139,0.6694660144597179,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Node is Ownable {
    using SafeMath for uint256;

    function computeNodeId(uint256 indexId, uint256 id) public pure returns (bytes32) {
        return sha3(indexId, id);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
211,Uses the same signature as initializeTokenSale ( ) with :,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    bool public buyModeEth;
    address public payableTokenAddress;

    function initializeSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) internal {
        // Sale initialization logic here
    }

    function initializeTokenSaleWithToken(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary, address _tokenAddress) public onlyOwner {
        buyModeEth = false;
        payableTokenAddress = _tokenAddress;
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}","[{'function': 'initializeSale', 'complexity': 0}, {'function': 'initializeTokenSaleWithToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeTokenSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxTokens"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenPrice""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_maxTokens""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_tokenPrice""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxTokens""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxTokens""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'initializeSale', 'complexity': 0}, {'function': 'initializeTokenSaleWithToken', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function initializeTokenSale(uint256 _tokenPrice, uint256 _maxTokens) public {
        require(_tokenPrice > 0);
        require(_maxTokens > 0);

        tokenPrice = _tokenPrice;
        maxTokens = _maxTokens;
    }
}
```
This function is a simplified version of the `initializeTokenSale` function from the previous code summary. It takes two input parameters, `_tokenPrice` and `_maxTokens`, and sets them as state variables in the contract. The function also includes a require statement to ensure that both inputs are greater than zero.

Here is the modified function:
```solidity
function initializeTokenSale(uint256 _tokenPrice, uint256 _maxTokens) public {
    require(_tokenPrice > 0);
    require(_maxTokens > 0);

    tokenPrice = _tokenPrice;
    maxTokens = _maxTokens;
}",5.1472532749176025,initializeTokenSale,"[{'function': 'initializeTokenSale', 'complexity': 2}, {'function': 'initializeTokenSale', 'complexity': 2}]",6.0,23.0,0.6412492698461274,0.0084102650417512,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming OpenZeppelin's Ownable contract is used

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public tokenPrice;
    uint256 public maxTokens;

    constructor() Ownable(msg.sender) {
        // Initialization values as per the rules provided:
        tokenPrice = 1; // Set to 1 (never 0)
        maxTokens = 1; // Set to 1 (never 0)
    }
}"
5005,If this function is called again it overwrites the current allowance with _value .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => bool) public frozenAccount;
    mapping(address => mapping(address => uint256)) public allowed;

    function approve(address _spender, uint256 _value) external returns (bool success) {
        require(!frozenAccount[msg.sender]);
        assert(_spender != address(0));
        require(_value >= 0);
        allowed[msg.sender][_spender] = _value;
        return true;
    }
}","[{'function': 'approve', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 4}]",4.0,"
pragma solidity ^0.8.0;

contract Allowance {
    using SafeMath for uint256;

    mapping(address => uint256) public allowances;

    function setAllowance(uint256 _value, address _spender) external {
        require(_value > 0, ""Invalid value"");
        require(_spender != address(0), ""Invalid spender"");

        if (allowances[_spender] == 0) {
            allowances[_spender] = _value;
        } else {
            allowances[_spender] = SafeMath.add(allowances[_spender], _value);
        }
    }
}",3.0101146697998047,setAllowance,"[{'function': 'setAllowance', 'complexity': 3}]",4.0,23.0,0.6294867106189047,0.2370087009718136,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Allowance {
    using SafeMath for uint256;

    mapping(address => uint256) public allowances;
    address public owner;
    bool public initialized = true;
    bytes32 public constant initBytes32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        allowances[msg.sender] = 1; // Set to a fixed value
        owner = msg.sender;
    }

    function setAllowance(uint256 _value, address _spender) external {
        require(_value > 0, ""Invalid value"");
        require(_spender != address(0), ""Invalid spender"");

        if (allowances[_spender] == 0) {
            allowances[_spender] = _value;
        } else {
            allowances[_spender] = SafeMath.add(allowances[_spender], _value);
        }
    }

    function setOwner(address _newOwner) public {
        require(_newOwner != address(0), ""Invalid owner"");
        owner = _newOwner;
    }
}"
2436,Function for transfering tokens from one account to another .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(bytes16 => uint256) public balances;
    address[] private allowedAddresses;
    bool public paused = false;

    modifier onlyAllowedAddresses() {
        require(_isAllowedAddress(msg.sender), ""Only allowed addresses can call this function"");
        _;
    }

    modifier onlyRegisteredAccount(bytes16 _account) {
        require(_isRegisteredAccount(_account), ""The account must be registered"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function transferTokensToAccount(bytes16 _from, bytes16 _to, uint256 _tokensCount) public onlyAllowedAddresses onlyRegisteredAccount(_from) whenNotPaused {
        registerAccount(_to);
        balances[_from] = balances[_from].sub(_tokensCount);
        balances[_to] = balances[_to].add(_tokensCount);
    }

    function registerAccount(bytes16 _account) internal {
        // Implementation of the registerAccount function
    }

    function _isAllowedAddress(address _addr) internal view returns (bool) {
        for (uint i = 0; i < allowedAddresses.length; i++) {
            if (allowedAddresses[i] == _addr) {
                return true;
            }
        }
        return false;
    }

    function _isRegisteredAccount(bytes16 _account) internal view returns (bool) {
        // Implementation of the check for registered account
        return balances[_account] > 0;
    }
}","[{'function': 'transferTokensToAccount', 'complexity': 0}, {'function': 'registerAccount', 'complexity': 0}, {'function': '_isAllowedAddress', 'complexity': 3}, {'function': '_isRegisteredAccount', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid from address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid to address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferTokensToAccount', 'complexity': 0}, {'function': 'registerAccount', 'complexity': 0}, {'function': '_isAllowedAddress', 'complexity': 3}, {'function': '_isRegisteredAccount', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    function transfer(address _from, address _to, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");

        // Transfer tokens from sender to recipient
        uint256 balance = SafeMath.sub(balances[_from], _amount);
        balances[_from] = balance;
        balances[_to] = SafeMath.add(balances[_to], _amount);
    }
}",3.296794414520264,transfer,"[{'function': 'transfer', 'complexity': 3}]",4.0,40.0,0.3217536312298182,0.0074598801587887,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;
    bytes32 public constant INIT = bytes32('init');

    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual default address
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    uint256 public constant DEFAULT_UINT = 1;

    mapping(address => uint256) public balances;

    constructor() Ownable(DEFAULT_ADDRESS, DEFAULT_BOOL, DEFAULT_STRING) {
        balances[msg.sender] = DEFAULT_UINT;
    }

    function transfer(address _from, address _to, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");

        // Transfer tokens from sender to recipient
        uint256 balance = SafeMath.sub(balances[_from], _amount);
        balances[_from] = balance;
        balances[_to] = SafeMath.add(balances[_to], _amount);
    }
}"
2602,` onlyOwner ` An efficient way to confirm multiple payments,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiConfirm(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }

    function doConfirmPayment(uint256 _idPayment) internal virtual {
        // Implementation of the payment confirmation logic
    }
}","[{'function': 'multiConfirm', 'complexity': 1}, {'function': 'doConfirmPayment', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""pay"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""amounts"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Recipient and amount arrays must be of equal length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'multiConfirm', 'complexity': 1}, {'function': 'doConfirmPayment', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MultiPayment {
    using SafeMath for uint256;

    address private owner;

    constructor() public {
        owner = msg.sender;
    }

    function pay(address[] memory recipients, uint256[] memory amounts) public onlyOwner {
        require(recipients.length == amounts.length, ""Recipient and amount arrays must be of equal length"");

        for (uint256 i = 0; i < recipients.length; i++) {
            address recipient = recipients[i];
            uint256 amount = amounts[i];

            require(amount > 0, ""Amount must be greater than zero"");

            recipient.transfer(amount);
        }
    }
}",3.7371726036071777,pay,"[{'function': 'pay', 'complexity': 3}]",4.0,32.0,0.5558612911293673,0.1429278854336334,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MultiPayment is Ownable {
    using SafeMath for uint256;

    address private _owner = msg.sender;

    constructor() public Ownable(msg.sender) {}

    function pay(address[] memory recipients, uint256[] memory amounts) public onlyOwner {
        require(recipients.length == amounts.length, ""Recipient and amount arrays must be of equal length"");

        for (uint256 i = 0; i < recipients.length; i++) {
            address recipient = recipients[i];
            uint256 amount = amounts[i];

            require(amount > 0, ""Amount must be greater than zero"");

            recipient.transfer(amount);
        }
    }
}"
1905,Function used by the client to block the transfer of shares from and to a share holder,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function blockTransfer(address _shareHolder, uint _deadLine) external onlyOwner {
        // Implementation of the blockTransfer function
    }
}","[{'function': 'blockTransfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""blockShareTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'blockTransfer', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract ShareTransfer {
    using SafeMath for uint256;

    function blockShareTransfer(address _from, address _to, uint256 _value) public returns (bool success) {
        // Check if the sender is a shareholder
        require(_from == msg.sender);

        // Check if the recipient is a shareholder
        require(_to != address(0));

        // Check if the sender has enough shares to transfer
        uint256 balance = SafeMath.sub(msg.sender, _value);
        require(balance >= 0);

        // Transfer the shares from the sender to the recipient
        msg.sender.transfer(_to, _value);

        return true;
    }
}",3.72726058959961,blockShareTransfer,"[{'function': 'blockShareTransfer', 'complexity': 3}]",4.0,50.0,0.5648710472848063,0.0066810091551256,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is for OpenZeppelin's Ownable contract

contract ShareTransfer is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        owner = msg.sender; // address: 0x1111111111111111111111111111111111111111 (first address)
        balanceOf[owner] = 1; // uint256: Set to 1 for the owner
    }

    mapping(address => uint256) public balanceOf;

    function blockShareTransfer(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_from == msg.sender); // Check if the sender is a shareholder
        require(_to != address(0)); // Check if the recipient is not the zero address
        uint256 balance = SafeMath.sub(msg.sender, _value);
        require(balance >= 0); // Check if the sender has enough shares to transfer
        msg.sender.transfer(_to, _value); // Transfer the shares from the sender to the recipient
        return true;
    }
}"
6047,Send ` _value ` tokens to ` _to ` from your account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(checkVestingCondition(msg.sender));
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function checkVestingCondition(address account) internal view returns (bool) {
        // Implement your vesting condition logic here
        return false;
    }

    function _transfer(address from, address to, uint256 value) internal virtual {
        require(to != address(0), ""ERC20: transfer to the zero address"");
        require(balanceOf(from) >= value, ""ERC20: transfer amount exceeds balance"");

        // Subtract the amount from the sender's balance
        _balances[from] = _balances[from].sub(value);

        // Add the amount to the recipient's balance
        _balances[to] = _balances[to].add(value);

        emit Transfer(from, to, value);
    }

    mapping(address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
}","[{'function': 'transfer', 'complexity': 1}, {'function': 'checkVestingCondition', 'complexity': 0}, {'function': '_transfer', 'complexity': 2}, {'function': 'balanceOf', 'complexity': 0}]",3.0,{},"[{'function': 'transfer', 'complexity': 1}, {'function': 'checkVestingCondition', 'complexity': 0}, {'function': '_transfer', 'complexity': 2}, {'function': 'balanceOf', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function sendTokens(uint256 _value, address payable _to) public {
        require(_value > 0, ""Value must be greater than zero"");
        require(_to != address(0), ""Recipient address cannot be zero"");

        uint256 balance = SafeMath.sub(address(this).balance, _value);
        require(balance >= 0, ""Insufficient funds"");

        (bool success, ) = _to.call{value: _value}("""");
        require(success, ""Transfer failed"");
    }
}",3.3708653450012207,sendTokens,"[{'function': 'sendTokens', 'complexity': 4}]",5.0,55.0,0.7048633845070426,0.1397699173089507,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        _value = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        _to = address(uint160(uint256(keccak256('address1'))));

        // bool: Set to true
        _initialized = true;

        // string: Set to 'initialized'
        _tokenName = ""MyToken"";
    }

    uint256 private _value;
    address payable private _to;
    bool private _initialized;
    bytes32 private constant INITIALIZE_BYTES = bytes32('init');
    string private constant TOKEN_NAME = 'initialized';

    function sendTokens(uint256 _value, address payable _to) public {
        require(_value > 0, ""Value must be greater than zero"");
        require(_to != address(0), ""Recipient address cannot be zero"");

        uint256 balance = SafeMath.sub(address(this).balance, _value);
        require(balance >= 0, ""Insufficient funds"");

        (bool success, ) = _to.call{value: _value}("""");
        require(success, ""Transfer failed"");
    }
}"
189,To be called by the account that holds Mio tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) public lockedBalances;
    IERC20 public token;

    constructor(IERC20 _token) {
        token = _token;
    }

    function addBalanceFor(address account, uint256 value) public onlyOwner {
        lockedBalances[account] = lockedBalances[account].add(value);
        require(token.safeTransferFrom(msg.sender, address(this), value), ""Token transfer failed"");
    }
}","[{'function': 'safeTransferFrom', 'complexity': 0}, {'function': 'addBalanceFor', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferMio"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'safeTransferFrom', 'complexity': 0}, {'function': 'addBalanceFor', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract MioToken {
    using SafeMath for uint256;

    function transferMio(address _to, uint256 _amount) public {
        require(_to != address(0), ""Invalid recipient"");
        require(_amount > 0, ""Invalid amount"");
        require(balanceOf(msg.sender) >= _amount, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);
    }
}",3.0833089351654053,transferMio,"[{'function': 'transferMio', 'complexity': 3}]",4.0,46.0,0.5836991571537761,0.0843177778385365,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MioToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        balances[owner()] = 1 ether; // Initialize balance to 1 ether
        balances[address(0x111)] = 1 ether; // Address 0x111 initialized with 1 ether
        balances[address(0x222)] = 2 ether; // Address 0x222 initialized with 2 ether
        balances[address(0x333)] = 3 ether; // Address 0x333 initialized with 3 ether
    }

    function transferMio(address _to, uint256 _amount) public {
        require(_to != address(0), ""Invalid recipient"");
        require(_amount > 0, ""Invalid amount"");
        require(balances[msg.sender] >= _amount, ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);

        emit Transfer(msg.sender, _to, _amount);
    }
}"
3776,Ability to transfer where the sender pays the fees ( not ERC20 ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function _transferSenderPaysFee_byProxy(address sender, address to, uint256 value) internal returns (bool) {
        uint256 fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee);
    }

    function transferFeeIncurred(uint256 value) internal pure returns (uint256) {
        // Example logic for calculating the fee
        return value.div(100); // 1% fee
    }

    function _internalTransfer(address sender, address to, uint256 value, uint256 fee) internal returns (bool) {
        require(balanceOf(sender) >= value.add(fee), ""Insufficient balance"");

        // Deduct the fee from the sender's balance
        _balances[sender] = _balances[sender].sub(value).sub(fee);

        // Add the fee to the contract balance (or any other logic)
        _balances[address(this)] = _balances[address(this)].add(fee);

        // Transfer the value to the recipient
        _balances[to] = _balances[to].add(value);

        emit Transfer(sender, to, value);
        return true;
    }

    mapping (address => uint256) private _balances;

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}","[{'function': '_transferSenderPaysFee_byProxy', 'complexity': 0}, {'function': 'transferFeeIncurred', 'complexity': 0}, {'function': '_internalTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TransferWithFees""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': '_transferSenderPaysFee_byProxy', 'complexity': 0}, {'function': 'transferFeeIncurred', 'complexity': 0}, {'function': '_internalTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract TransferWithFees {
    using SafeMath for uint256;

    function transfer(address payable recipient, uint256 amount) public payable {
        require(msg.value >= amount, ""Insufficient funds"");
        recipient.transfer(amount);
        emit TransferWithFees(msg.sender, recipient, amount);
    }
}",2.0481650829315186,transfer,"[{'function': 'transfer', 'complexity': 1}]",2.0,48.0,0.7139173748865384,0.0106305280374967,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming Ownable is imported correctly

contract TransferWithFees is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        owner = msg.sender;
        // No need to initialize other variables as they are not present in the provided contract logic
    }

    function transfer(address payable recipient, uint256 amount) public payable {
        require(msg.value >= amount, ""Insufficient funds"");
        recipient.transfer(amount);
        emit TransferWithFees(msg.sender, recipient, amount);
    }
}"
4464,"Returns the cost of the cosigner This cosigner does not have any risk or maintenance cost , so its free .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CostWrapper is Ownable {
    using SafeMath for uint256;

    function cost(address _address, uint256 _uint256, bytes memory _bytes1, bytes memory _bytes2) external view returns (uint256) {
        require(_address != address(0), ""Invalid address"");
        // The logic for calculating the cost is not provided in the snippet.
        return 0;
    }
}","[{'function': 'cost', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCosignerCost"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'cost', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

contract CosignerCost {
    function getCosignerCost() public view returns (uint256) {
        return 0;
    }
}",0.8945267200469971,getCosignerCost,"[{'function': 'getCosignerCost', 'complexity': 0}]",1.0,17.0,0.600011347318737,0.0295196336917268,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CosignerCost {
    address public constant COSIGNER_COST_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    uint256 public constant COSIGNER_COST = 1;
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        _setInitialized(true);
    }

    function getCosignerCost() public view returns (uint256) {
        return COSIGNER_COST;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;

    constructor(address owner) {
        require(owner != address(0), ""Owner cannot be the zero address"");
        _owner = owner;
    }

    function setOwner(address newOwner) public {
        require(newOwner != address(0), ""New owner cannot be the zero address"");
        _owner = newOwner;
    }
}"
1265,Checks whether the cap has been reached .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CapReachedWrapper is Ownable {
    using SafeMath for uint256;

    bool public isFinalized;
    uint256 public finalAmountReturned;
    mapping(uint256 => uint256) public mintedPerTierTotal;
    uint256[] public tokensPerTierTotal;

    function capReached() public view returns (bool) {
        if (isFinalized) {
            return finalAmountReturned == 0;
        }
        return mintedPerTierTotal[mintedPerTierTotal.length - 1] == tokensPerTierTotal[tokensPerTierTotal.length - 1];
    }
}","[{'function': 'capReached', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""hasCapBeenReached"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""cap""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'capReached', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

contract MyContract {
    uint256 public cap;

    constructor(uint256 _cap) public {
        cap = _cap;
    }

    function hasCapBeenReached() public view returns (bool) {
        return cap == 0;
    }
}",1.5574772357940674,hasCapBeenReached,"[{'function': 'hasCapBeenReached', 'complexity': 0}]",1.0,12.0,0.6890172714853845,0.2753596437280865,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public cap;

    constructor() public {
        cap = 1;
        _transferOwnership(msg.sender);
    }

    function hasCapBeenReached() public view returns (bool) {
        return cap == 0;
    }
}"
4986,Returns the number of decimals the token uses .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    function decimals() public view returns (uint8 _decimals) {
        return 18; // Example implementation, adjust as needed
    }
}","[{'function': 'decimals', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getDecimals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'decimals', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    function getDecimals() public view returns (uint256) {
        return 18;
    }
}",1.3209662437438965,getDecimals,"[{'function': 'getDecimals', 'complexity': 0}]",1.0,0.0,0.8704499755785995,0.314261380179443,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract Token is Ownable {
    using SafeMath for uint256;

    function getDecimals() public pure returns (uint256) {
        return 18;
    }

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        _totalSupply = 1000000000000000000;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        owner = msg.sender;
        tokenOwner = address(uint160(uint256(keccak256('init'))));
        anotherAddress = address(uint160(uint256(keccak256('init2'))));

        // bool: Set to true
        isInitialized = true;

        // string: Set to 'initialized'
        tokenName = ""MyToken"";

        // bytes32: Set to bytes32('init')
        tokenSymbol = bytes32(keccak256(""init""));
    }

    uint256 private _totalSupply;
    address private owner;
    address private tokenOwner;
    address private anotherAddress;
    bool private isInitialized;
    string private tokenName;
    bytes32 private tokenSymbol;
}"
6318,Deploy a new TokenNetwork contract for the Token deployed at ` _token_address ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenNetworkFactory is Ownable {
    using SafeMath for uint256;

    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    mapping(address => address) public tokenToTokenNetworks;
    bool public tokenNetworkCreated;

    event TokenNetworkCreated(address indexed tokenAddress, address indexed tokenNetworkAddress);

    function createERC20TokenNetwork(address _token_address) external returns (address token_network_address) {
        require(tokenToTokenNetworks[_token_address] == address(0x0), ""Token network already created for this token"");
        tokenNetworkCreated = true;
        TokenNetwork token_network = new TokenNetwork(_token_address, secretRegistryAddress, chainId, settlementTimeoutMin, settlementTimeoutMax, deprecationExecutor);
        token_network_address = address(token_network);
        tokenToTokenNetworks[_token_address] = token_network_address;
        emit TokenNetworkCreated(_token_address, token_network_address);
        return token_network_address;
    }
}

abstract contract TokenNetwork {
    using SafeMath for uint256;

    address public tokenAddress;
    address public secretRegistryAddress;
    uint256 public chainId;
    uint256 public settlementTimeoutMin;
    uint256 public settlementTimeoutMax;
    address public deprecationExecutor;

    constructor(address _token_address, address _secret_registry_address, uint256 _chain_id, uint256 _settlement_timeout_min, uint256 _settlement_timeout_max, address _deprecation_executor) {
        tokenAddress = _token_address;
        secretRegistryAddress = _secret_registry_address;
        chainId = _chain_id;
        settlementTimeoutMin = _settlement_timeout_min;
        settlementTimeoutMax = _settlement_timeout_max;
        deprecationExecutor = _deprecation_executor;
    }
}","[{'function': 'createERC20TokenNetwork', 'complexity': 1}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""deploy"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenNetwork""}, ""name"": ""tokenNetwork"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenNetwork""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenNetwork""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createERC20TokenNetwork', 'complexity': 1}]",4.0,"
pragma solidity ^0.8.0;

import ""./TokenNetwork.sol"";

contract DeployTokenNetwork {
    function deploy(address _tokenAddress) public returns (address) {
        // Create a new instance of the TokenNetwork contract and pass in the address of the deployed token
        TokenNetwork tokenNetwork = new TokenNetwork(_tokenAddress);

        // Return the address of the newly created TokenNetwork contract
        return address(tokenNetwork);
    }
}",1.9892795085906985,deploy,"[{'function': 'deploy', 'complexity': 0}]",1.0,35.0,0.6967507031807131,0.0689339845888274,"pragma solidity ^0.8.0;

import ""./TokenNetwork.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from
import ""openzeppelin/SafeMath.sol"";
contract DeployTokenNetwork is Ownable {
    constructor(address _tokenAddress) Ownable(msg.sender) {
        TokenNetwork tokenNetwork = new TokenNetwork(_tokenAddress);
    }
}"
2003,Refund a given address for all the Ether they have contributed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public userFundedPool;

    modifier isAdmin() {
        require(owner() == msg.sender, ""Caller is not the admin"");
        _;
    }

    modifier isAdminRefundable(address _address) {
        require(_address != address(0), ""Invalid address"");
        _;
    }

    modifier userHasFundedPool(address _address) {
        require(userFundedPool[_address], ""User has not funded the pool"");
        _;
    }

    function refundAddress(address _address) public isAdmin isAdminRefundable(_address) userHasFundedPool(_address) {
        processRefundInternal(_address);
    }

    function processRefundInternal(address _address) internal {
        // Implementation of the refund logic
    }
}","[{'function': 'refundAddress', 'complexity': 0}, {'function': 'processRefundInternal', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""refund"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""recipient""}}, {""type"": ""stringLiteral"", ""value"": ""Only the recipient can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'refundAddress', 'complexity': 0}, {'function': 'processRefundInternal', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract RefundContract {
    using SafeMath for uint256;

    function refund(address payable recipient, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        require(msg.sender == recipient, ""Only the recipient can call this function"");

        recipient.transfer(amount);
    }
}",2.0989675521850586,refund,"[{'function': 'refund', 'complexity': 2}]",3.0,18.0,0.6616852951494563,0.0370814414767151,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is how you import OpenZeppelin contracts

contract RefundContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function refund(address payable recipient, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        require(msg.sender == recipient, ""Only the recipient can call this function"");

        recipient.transfer(amount);
    }
}"
1814,` onlySecurityGuard ` Delays a payment for a set number of seconds,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint securityGuardDelay;
        uint earliestPayTime;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        if (_delay > 10**18) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}","[{'function': 'delayPayment', 'complexity': 0}]",6.0,{},"[{'function': 'delayPayment', 'complexity': 0}]",6.0,"example Solidity smart contract function that delays a payment based on the input parameters:
```
pragma solidity ^0.8.0;

contract PaymentDelay {
    using SafeMath for uint256;

    event DelayedPayment(address indexed from, address indexed to, uint256 amount);

    function delayPayment(uint256 seconds) public payable {
        require(msg.value > 0, ""Invalid payment"");
        require(seconds >= 1, ""Delay must be greater than or equal to 1 second"");

        // Calculate the current timestamp and add the number of seconds to it
        uint256 currentTimestamp = block.timestamp;
        uint256 delayedTimestamp = currentTimestamp.add(seconds);

        // Emit an event with the delayed payment details
        emit DelayedPayment(msg.sender, msg.value, delayedTimestamp);
    }
}",6.43050479888916,delayPayment,"[{'function': 'delayPayment', 'complexity': 2}]",3.0,58.0,0.7290805651714207,0.0309263608330012,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentDelay is Ownable {
    using SafeMath for uint256;

    event DelayedPayment(address indexed from, address indexed to, uint256 amount);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function delayPayment(uint256 seconds) public payable {
        require(msg.value > 0, ""Invalid payment"");
        require(seconds >= 1, ""Delay must be greater than or equal to 1 second"");

        uint256 currentTimestamp = block.timestamp;
        uint256 delayedTimestamp = currentTimestamp.add(seconds);

        emit DelayedPayment(msg.sender, address(this), delayedTimestamp);
    }
}"
4481,This is a private function which should be called from user-implemented external burn function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract NFToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) private _tokenOwner;
    mapping(address => uint256) private _ownedTokensCount;
    mapping(uint256 => address) private _tokenApprovals;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    modifier validNFToken(uint256 tokenId) {
        require(_exists(tokenId), ""NFToken: token does not exist"");
        _;
    }

    function _burn(address _owner, uint256 _tokenId) internal validNFToken(_tokenId) {
        clearApproval(_tokenId);
        removeNFToken(_owner, _tokenId);
        emit Transfer(_owner, address(0), _tokenId);
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        address owner = _tokenOwner[tokenId];
        return owner != address(0);
    }

    function clearApproval(uint256 tokenId) private {
        if (_tokenApprovals[tokenId] != address(0)) {
            delete _tokenApprovals[tokenId];
        }
    }

    function removeNFToken(address owner, uint256 tokenId) internal {
        require(_tokenOwner[tokenId] == owner, ""NFToken: token not owned by owner"");
        delete _tokenOwner[tokenId];
        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);
    }
}","[{'function': '_burn', 'complexity': 0}, {'function': '_exists', 'complexity': 0}, {'function': 'clearApproval', 'complexity': 1}, {'function': 'removeNFToken', 'complexity': 1}]",1.0,{},"[{'function': '_burn', 'complexity': 0}, {'function': '_exists', 'complexity': 0}, {'function': 'clearApproval', 'complexity': 1}, {'function': 'removeNFToken', 'complexity': 1}]",1.0,"pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint256;

    function burn(uint256 amount) public {
        // Additional logic can be added here
    }
}",1.1467292308807373,burn,"[{'function': 'burn', 'complexity': 0}]",1.0,26.0,0.5652440240805204,0.0040353576064913,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    using SafeMath for uint256;
    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    bool public constant INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(OWNER) {
        // Initialize state variables to fixed, safe values
        uint256 public constant DEFAULT_AMOUNT = 1;
        uint256 public constant DEFAULT_VALUE = 1;

        // Initialize bool and string variables
        bool public constant DEFAULT_BOOL = true;
        string public constant DEFAULT_STRING = 'initialized';

        // Initialize bytes32 variable
        bytes32 public constant DEFAULT_BYTES32 = INIT_BYTES32;

        // Call parent contract's constructor
        Ownable(msg.sender);
    }

    function burn(uint256 amount) public {
        // Additional logic can be added here
    }
}"
3728,"Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""MyToken"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0));
        require(_value <= balanceOf[msg.sender]);

        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }
}","[{'function': 'transfer', 'complexity': 1}, {'function': 'approve', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveSpender"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 1}, {'function': 'approve', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract AllowanceMultipleWithdrawals {
    using SafeMath for uint256;

    mapping(address => uint256) public allowances;

    function approveSpender(address _spender, uint256 _value) external returns (bool) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Invalid value"");

        allowances[_spender] = allowances[_spender].add(_value);

        return true;
    }
}",3.2307403087615967,approveSpender,"[{'function': 'approveSpender', 'complexity': 2}]",3.0,23.0,0.875486162788837,0.5105008830372312,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AllowanceMultipleWithdrawals is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public allowances;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveSpender(address _spender, uint256 _value) external returns (bool) {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Invalid value"");

        allowances[_spender] = allowances[_spender].add(_value);

        return true;
    }
}"
213,Get the price of a campaign Based on the Campaign id return the value paid for each proof of attention registered .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdvertisementWrapper {
    using SafeMath for uint256;

    struct CampaignPrice {
        bytes32 bidId;
        uint price;
    }

    mapping(bytes32 => uint) public campaignPrices;

    constructor(CampaignPrice[] memory initialCampaigns) {
        for (uint i = 0; i < initialCampaigns.length; i++) {
            campaignPrices[initialCampaigns[i].bidId] = initialCampaigns[i].price;
        }
    }

    function getPriceOfCampaign(bytes32 bidId) public view returns (uint) {
        return campaignPrices[bidId];
    }
}","[{'function': 'getPriceOfCampaign', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""campaignId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""campaignId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid campaign ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalValue"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proofs""}, ""index"": {""type"": ""Identifier"", ""name"": ""campaignId""}}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalValue""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalValue""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proofs""}, ""index"": {""type"": ""Identifier"", ""name"": ""campaignId""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""value""}], ""names"": []}}}]}}, {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""totalValue""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proofs""}, ""index"": {""type"": ""Identifier"", ""name"": ""campaignId""}}, ""memberName"": ""length""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getPriceOfCampaign', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Campaign {
    using SafeMath for uint256;

    struct ProofOfAttention {
        address sender;
        uint256 value;
    }

    mapping(uint256 => ProofOfAttention[]) public proofs;

    function getPrice(uint256 campaignId) public view returns (uint256) {
        require(campaignId > 0, ""Invalid campaign ID"");

        uint256 totalValue = 0;
        for (uint256 i = 0; i < proofs[campaignId].length; i++) {
            totalValue = totalValue.add(proofs[campaignId][i].value);
        }

        return totalValue / proofs[campaignId].length;
    }
}",3.6718149185180655,getPrice,"[{'function': 'getPrice', 'complexity': 2}]",3.0,41.0,0.7925729700190889,0.0827796596677141,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Campaign is Ownable {
    using SafeMath for uint256;

    struct ProofOfAttention {
        address sender;
        uint256 value;
    }

    mapping(uint256 => ProofOfAttention[]) public proofs;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getPrice(uint256 campaignId) public view returns (uint256) {
        require(campaignId > 0, ""Invalid campaign ID"");

        uint256 totalValue = 0;
        for (uint256 i = 0; i < proofs[campaignId].length; i++) {
            totalValue = totalValue.add(proofs[campaignId][i].value);
        }

        return totalValue / proofs[campaignId].length;
    }
}"
2236,Deposit fees into the vault for a Darknode .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface CompatibleERC20 {
    function safeTransferFromWithFees(address from, address to, uint256 value) external returns (uint256);
}

abstract contract DarknodeDeposit is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(ERC20 => uint256)) public darknodeBalances;

    function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {
        require(msg.sender == address(this));
        require(_token != address(0) || msg.value == _value);
        require(_token != address(0) && msg.value == 0);
        uint256 receivedValue = _value;
        if (_token != address(0)) {
            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);
        }
        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeTransferFromWithFees', 'complexity': 0}, {'function': 'deposit', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""depositFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'safeTransferFromWithFees', 'complexity': 0}, {'function': 'deposit', 'complexity': 6}]",7.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeMath.sol"";

contract DarknodeVault is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public deposits;

    function depositFees(uint256 amount) external onlyOwner {
        require(amount > 0, ""Invalid amount"");
        deposits[msg.sender] = deposits[msg.sender].add(amount);
    }
}",3.556609869003296,depositFees,"[{'function': 'depositFees', 'complexity': 1}]",2.0,50.0,0.6015262674026342,0.006564689518919,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract DarknodeVault is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public deposits;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function depositFees(uint256 amount) external onlyOwner {
        require(amount > 0, ""Invalid amount"");
        deposits[msg.sender] = deposits[msg.sender].add(amount);
    }
}"
3103,Checks whether redemption is permitted for a participant,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RedemptionPermitWrapper is Ownable {
    using SafeMath for uint256;

    function isRedemptionPermitted(address ofParticipant, uint256 shareQuantity, uint256 receiveQuantity) public view returns (bool) {
        return true;
    }
}","[{'function': 'isRedemptionPermitted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""canRedemptionBePermitted"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_redemptionAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_account""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid account""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_redemptionAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid redemption amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Participant""}, ""name"": ""participant"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""participants""}, ""index"": {""type"": ""Identifier"", ""name"": ""_account""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""participant""}, ""memberName"": ""isEligible""}, ""isPrefix"": True}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalRedemptionAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""participant""}, ""memberName"": ""redemptionAmount""}, {""type"": ""Identifier"", ""name"": ""_redemptionAmount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""totalRedemptionAmount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""participant""}, ""memberName"": ""account""}, ""memberName"": ""balance""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isRedemptionPermitted', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Redemption {
    using SafeMath for uint256;

    struct Participant {
        address account;
        bool isEligible;
        uint256 redemptionAmount;
    }

    mapping(address => Participant) public participants;

    function canRedemptionBePermitted(address _account, uint256 _redemptionAmount) public view returns (bool) {
        require(_account != address(0), ""Invalid account"");
        require(_redemptionAmount > 0, ""Invalid redemption amount"");

        Participant memory participant = participants[_account];

        if (!participant.isEligible) {
            return false;
        }

        uint256 totalRedemptionAmount = SafeMath.add(participant.redemptionAmount, _redemptionAmount);

        if (totalRedemptionAmount > participant.account.balance) {
            return false;
        }

        return true;
    }
}",4.675134658813477,canRedemptionBePermitted,"[{'function': 'canRedemptionBePermitted', 'complexity': 5}]",5.0,43.0,0.7623999293259808,0.1294258651572332,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Redemption is Ownable {
    using SafeMath for uint256;

    struct Participant {
        address account;
        bool isEligible;
        uint256 redemptionAmount;
    }

    mapping(address => Participant) public participants;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            participants[addr] = Participant({account: addr, isEligible: true, redemptionAmount: 1});
        }
    }

    function canRedemptionBePermitted(address _account, uint256 _redemptionAmount) public view returns (bool) {
        require(_account != address(0), ""Invalid account"");
        require(_redemptionAmount > 0, ""Invalid redemption amount"");

        Participant memory participant = participants[_account];

        if (!participant.isEligible) {
            return false;
        }

        uint256 totalRedemptionAmount = SafeMath.add(participant.redemptionAmount, _redemptionAmount);

        if (totalRedemptionAmount > participant.account.balance) {
            return false;
        }

        return true;
    }
}"
5733,Function which decodes bytes32 to array of integers,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DecodeAssetsWrapper {
    using SafeMath for uint256;

    function decodeAssets(bytes32[] memory _potentialAssets) public pure returns (uint[] memory assets) {
        require(_potentialAssets.length > 0);

        uint[] memory assetsCopy = new uint[](_potentialAssets.length * 10);
        uint numberOfAssets = 0;

        for (uint j = 0; j < _potentialAssets.length; j++) {
            uint input;
            bytes32 pot = _potentialAssets[j];
            assembly {
                input := pot
            }

            for (uint i = 10; i > 0; i--) {
                uint mask = (2 << ((i - 1) * 24)) / 2;
                uint b = (input & (mask * 16777215)) / mask;
                if (b != 0) {
                    assetsCopy[numberOfAssets] = b;
                    numberOfAssets++;
                }
            }
        }

        assets = new uint[](numberOfAssets);
        for (uint i = 0; i < numberOfAssets; i++) {
            assets[i] = assetsCopy[i];
        }
    }
}","[{'function': 'decodeAssets', 'complexity': 8}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""decodeBytes32"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""input"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""result"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""4"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""4"", ""subdenomination"": None}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""result""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""safeMul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""input""}, {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""8"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""i""}}], ""isArray"": False}}], ""names"": []}}}]}}, {""type"": ""Identifier"", ""name"": ""result""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'decodeAssets', 'complexity': 8}]",6.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function decodeBytes32(bytes32 input) public pure returns (uint256[] memory) {
        uint256[] memory result = new uint256[](4);
        for (uint256 i = 0; i < 4; i++) {
            result[i] = SafeMath.safeMul(input, 10 ** (8 * i));
        }
        return result;
    }
}",2.696297168731689,decodeBytes32,"[{'function': 'decodeBytes32', 'complexity': 1}]",2.0,93.0,0.5643145621334074,0.0470891783555106,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract MyContract is Ownable {
    using SafeMath for uint256;

    function decodeBytes32(bytes32 input) public pure returns (uint256[] memory) {
        uint256[] memory result = new uint256[](4);
        for (uint256 i = 0; i < 4; i++) {
            result[i] = SafeMath.safeMul(input, 10 ** (8 * i));
        }
        return result;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
5459,Begins the token sale for this token instance,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale is Ownable {
    using SafeMath for uint256;

    function initializeTokenSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) public onlyOwner {
        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);
    }
}","[{'function': 'initializeTokenSale', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""beginSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can start the sale""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""SaleStarted""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'initializeTokenSale', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract TokenSale {
    using SafeMath for uint256;

    address public owner;
    uint256 public totalSupply;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
        totalSupply = 1000000000;
    }

    function beginSale() external {
        require(msg.sender == owner, ""Only the contract owner can start the sale"");
        balances[owner] = totalSupply;
        emit SaleStarted();
    }
}",4.121737718582153,beginSale,"[{'function': 'beginSale', 'complexity': 1}]",2.0,24.0,0.6504196518158742,0.0345358686706421,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    uint256 public totalSupply = 1000000000;
    mapping(address => uint256) public balances;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables is already handled in the base class uint256 public totalSupply;

 constructor
    }

    function beginSale() external {
        require(msg.sender == owner, ""Only the contract owner can start the sale"");
        balances[owner] = totalSupply;
        emit SaleStarted();
    }
}"
6434,Set current preICO price in wei for one metadollar,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public preICOprice;

    constructor() Ownable() {}

    function setPreICOPrice(uint256 priceForPreIcoInWei) public isOwner {
        require(priceForPreIcoInWei > 0, ""The price for pre-ICO should be greater than zero"");
        require(preICOprice != priceForPreIcoInWei, ""The price for pre-ICO has not changed"");
        preICOprice = priceForPreIcoInWei;
        updatePrices();
    }
}","[{'function': 'setPreICOPrice', 'complexity': 2}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPreIcoPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_preIcoPriceInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_preIcoPriceInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid pre-ICO price""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""preIcoPriceInWei""}, ""right"": {""type"": ""Identifier"", ""name"": ""_preIcoPriceInWei""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPreICOPrice', 'complexity': 2}]",5.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract Metadollar {
    using SafeMath for uint256;

    // State variables
    uint256 public preIcoPriceInWei;

    function setPreIcoPrice(uint256 _preIcoPriceInWei) external {
        require(_preIcoPriceInWei > 0, ""Invalid pre-ICO price"");
        preIcoPriceInWei = _preIcoPriceInWei;
    }
}",4.52994441986084,setPreIcoPrice,"[{'function': 'setPreIcoPrice', 'complexity': 1}]",2.0,11.0,0.8782358801773449,0.0309760891989927,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract Metadollar is Ownable {
    using SafeMath for uint256;

    // State variables
    uint256 public preIcoPriceInWei;

    constructor() Ownable(msg.sender) {
        preIcoPriceInWei = 1; // Set to a non-zero, safe value
    }

    function setPreIcoPrice(uint256 _preIcoPriceInWei) external {
        require(_preIcoPriceInWei > 0, ""Invalid pre-ICO price"");
        preIcoPriceInWei = _preIcoPriceInWei;
    }
}"
30,Called in order to get the number of members on the platform,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Define membersArray as a state variable
    address[] public membersArray;

    function getMembersArrayLength() public view returns (uint256) {
        return membersArray.length;
    }
}","[{'function': 'getMembersArrayLength', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getMemberCount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""members""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getMembersArrayLength', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function getMemberCount() public view returns (uint256) {
        return members.length;
    }
}",1.3586511611938477,getMemberCount,"[{'function': 'getMemberCount', 'complexity': 0}]",1.0,0.0,0.841104222078778,0.708339753228812,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public constant DEFAULT_MEMBER_COUNT = 1;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        members.length = DEFAULT_MEMBER_COUNT;
        address_ = DEFAULT_ADDRESS;
        isInitialized = DEFAULT_BOOL;
        name_ = DEFAULT_STRING;
        symbol_ = DEFAULT_BYTES32;
    }

    uint256 public membersLength;
    address public address_;
    bool public isInitialized;
    string public name_;
    bytes32 public symbol_;

    function getMemberCount() public view returns (uint256) {
        return members.length;
    }
}"
3380,Count the number of validators defined by the jurisdiction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorCounter {
    using SafeMath for uint256;

    address[] private _validatorAccounts;

    function countValidators() external view returns (uint256) {
        return _validatorAccounts.length;
    }
}","[{'function': 'countValidators', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""countValidators"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_jurisdictionAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""jurisdictions""}, ""index"": {""type"": ""Identifier"", ""name"": ""_jurisdictionAddress""}}, ""memberName"": ""validators""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'countValidators', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract ValidatorCounter {
    using SafeMath for uint256;

    struct Jurisdiction {
        address[] validators;
    }

    mapping(address => Jurisdiction) public jurisdictions;

    function countValidators(address _jurisdictionAddress) public view returns (uint256) {
        return jurisdictions[_jurisdictionAddress].validators.length;
    }
}",2.060198783874512,countValidators,"[{'function': 'countValidators', 'complexity': 0}]",1.0,5.0,0.8387043748430276,0.4792365811426396,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ValidatorCounter is Ownable {
    using SafeMath for uint256;

    struct Jurisdiction {
        address[] validators;
    }

    mapping(address => Jurisdiction) public jurisdictions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            jurisdictions[addr] = Jurisdiction({validators: new address[](1)});
        }
    }

    function countValidators(address _jurisdictionAddress) public view returns (uint256) {
        return jurisdictions[_jurisdictionAddress].validators.length;
    }
}"
5188,allows to retreive multiple exchange rates in once call,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchangeRate {
    function getExchangeRate(address numeratorToken, address denominatorToken) external view returns (uint256);
    function getTimestamp() external view returns (uint256);
}

abstract contract ExchangeRates is Ownable {
    using SafeMath for uint256;

    IExchangeRate public exchangeRateContract;

    constructor(address _exchangeRateAddress) {
        exchangeRateContract = IExchangeRate(_exchangeRateAddress);
    }

    function getExchangeRates(address[] memory numeratorTokens, address[] memory denominatorTokens) public view returns (uint256[] memory rateFractions, uint256[] memory timestamps) {
        require(numeratorTokens.length > 0 && denominatorTokens.length > 0);
        require(numeratorTokens.length == denominatorTokens.length, ""Lengths must be equal"");

        rateFractions = new uint256[](numeratorTokens.length * denominatorTokens.length);
        timestamps = new uint256[](numeratorTokens.length * denominatorTokens.length);

        for (uint256 i = 0; i < numeratorTokens.length; i++) {
            address numeratorToken = numeratorTokens[i];
            for (uint256 j = 0; j < denominatorTokens.length; j++) {
                address denominatorToken = denominatorTokens[j];
                uint256 rateFraction = exchangeRateContract.getExchangeRate(numeratorToken, denominatorToken);
                uint256 timestamp = exchangeRateContract.getTimestamp();
                rateFractions[i * denominatorTokens.length + j] = rateFraction;
                timestamps[i * denominatorTokens.length + j] = timestamp;
            }
        }
    }
}","[{'function': 'getTimestamp', 'complexity': 0}, {'function': 'getExchangeRates', 'complexity': 6}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""getExchangeRates"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""exchangeIds"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""exchangeIds""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No exchange IDs provided""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""rates"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""exchangeIds""}, ""memberName"": ""length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""exchangeIds""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rates""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getExchangeRate""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""exchangeIds""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}}]}}, {""type"": ""Identifier"", ""name"": ""rates""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getTimestamp', 'complexity': 0}, {'function': 'getExchangeRates', 'complexity': 6}]",6.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract ExchangeRates {
    using SafeMath for uint256;

    function getExchangeRates(uint256[] calldata exchangeIds) external view returns (uint256[] memory) {
        require(exchangeIds.length > 0, ""No exchange IDs provided"");

        uint256[] memory rates = new uint256[](exchangeIds.length);

        for (uint256 i = 0; i < exchangeIds.length; i++) {
            rates[i] = getExchangeRate(exchangeIds[i]);
        }

        return rates;
    }

    function getExchangeRate(uint256 exchangeId) public view returns (uint256) {
        // Additional logic can be added here to retrieve the exchange rate based on the provided exchange ID
        return 100;
    }
}",4.780633449554443,getExchangeRates,"[{'function': 'getExchangeRates', 'complexity': 2}, {'function': 'getExchangeRate', 'complexity': 0}]",3.0,93.0,0.655629847034169,0.1099502862422011,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ExchangeRates is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        exchangeRate = 100;
    }

    function getExchangeRates(uint256[] calldata exchangeIds) external view returns (uint256[] memory) {
        require(exchangeIds.length > 0, ""No exchange IDs provided"");

        uint256[] memory rates = new uint256[](exchangeIds.length);

        for (uint256 i = 0; i < exchangeIds.length; i++) {
            rates[i] = getExchangeRate(exchangeIds[i]);
        }

        return rates;
    }

    function getExchangeRate(uint256 exchangeId) public view returns (uint256) {
        // Additional logic can be added here to retrieve the exchange rate based on the provided exchange ID
        return exchangeRate;
    }

    uint256 private exchangeRate = 100;
}"
316,send ` _value ` token to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    address[] public tokenHolders;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        emit LogForkAnnounced(name, url, blockNumber);
    }
}","[{'function': 'approve', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 0}, {'function': 'transfer', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    IERC20 public token;

    function sendToken(address _to, uint256 _value) external {
        require(_value > 0, ""Invalid value"");
        require(_to != address(0), ""Invalid recipient"");
        require(token.balanceOf(msg.sender) >= _value, ""Insufficient balance"");

        token.transferFrom(msg.sender, _to, _value);
    }
}",3.095202922821045,sendToken,"[{'function': 'sendToken', 'complexity': 3}]",4.0,29.0,0.6430684491213179,0.3986357128268013,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/security/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 public token;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(DEFAULT_BOOL) {
        token = IERC20(DEFAULT_ADDRESS);
    }

    function sendToken(address _to, uint256 _value) external {
        require(_value > 0, ""Invalid value"");
        require(_to != address(0), ""Invalid recipient"");
        require(token.balanceOf(msg.sender) >= _value, ""Insufficient balance"");

        token.transferFrom(msg.sender, _to, _value);
    }
}"
4609,"Add beneficiaries to the contract , allowing them to withdraw tokens .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingContract is Ownable {
    using SafeMath for uint256;

    struct Info {
        bool known;
        uint256 startTime;
        uint256 totalAmount;
        uint256 releaseTime;
    }

    mapping(address => Info) private _info;

    function addBeneficiary(address beneficiary, uint256 startTime, uint256 releaseTime, uint256 amount) external onlyOwner {
        require(_info[beneficiary].known == false, ""This address is already known to the contract."");
        require(releaseTime > startTime, ""Release time must be later than the start time."");
        require(releaseTime > block.timestamp, ""End of vesting period must be somewhere in the future."");

        Info storage info = _info[beneficiary];
        info.startTime = startTime;
        info.totalAmount = amount;
        info.releaseTime = releaseTime;
        info.known = true;
    }
}","[{'function': 'addBeneficiary', 'complexity': 3}]",4.0,{},"[{'function': 'addBeneficiary', 'complexity': 3}]",4.0,"contract BeneficiaryContract {
    using SafeMath for uint256;

    struct Beneficiary {
        address _address;
        uint256 _amount;
    }

    mapping (address => Beneficiary) public beneficiaries;

    function addBeneficiary(address _beneficiary, uint256 _amount) public {
        require(_amount > 0);

        beneficiaries[_beneficiary]._address = _beneficiary;
        beneficiaries[_beneficiary]._amount = beneficiaries[_beneficiary]._amount.add(_amount);
    }

    function withdrawBenefits() public {
        Beneficiary storage beneficiary = beneficiaries[msg.sender];

        require(beneficiary._address != address(0));

        uint256 amount = beneficiary._amount;
        beneficiary._amount = 0;

        payable(msg.sender).transfer(amount);
    }
}",4.621711015701294,withdrawBenefits,"[{'function': 'addBeneficiary', 'complexity': 1}, {'function': 'withdrawBenefits', 'complexity': 1}]",2.0,63.0,0.6126714514746295,0.0077312176408048,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BeneficiaryContract is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        address _address;
        uint256 _amount;
    }

    mapping(address => Beneficiary) public beneficiaries;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            beneficiaries[addr]._address = addr;
            beneficiaries[addr]._amount = 1 ether; // Set to a non-zero value
        }
    }

    function addBeneficiary(address _beneficiary, uint256 _amount) public {
        require(_amount > 0);
        beneficiaries[_beneficiary]._address = _beneficiary;
        beneficiaries[_beneficiary]._amount = beneficiaries[_beneficiary]._amount.add(_amount);
    }

    function withdrawBenefits() public {
        Beneficiary storage beneficiary = beneficiaries[msg.sender];
        require(beneficiary._address != address(0));
        uint256 amount = beneficiary._amount;
        beneficiary._amount = 0;
        payable(msg.sender).transfer(amount);
    }
}"
5346,You must send some ETH to cover the oraclize_query fees,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    enum Stage { ToInitialize, Waiting, Running, Ended }

    uint256 public startTime;
    uint256 public endTime;
    Token public token;
    uint256 public intervalUpdate;
    Stage public currentStage = Stage.ToInitialize;
    uint256 public constant MAX_TOKENS = 10**28; // Example value, adjust as needed

    constructor(address _token) {
        require(_token != address(0));
        token = Token(_token);
    }

    function initializeCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _intervalUpdate) public payable onlyOwner mustBeAtStage(Stage.ToInitialize) {
        require(_startTime >= block.timestamp);
        require(_endTime >= _startTime);
        require(_token != address(0));
        require(msg.value > 0);
        require(isContract(_token) == true);
        require(_intervalUpdate >= 5);

        startTime = _startTime;
        endTime = _endTime;
        intervalUpdate = _intervalUpdate;
        currentStage = Stage.Waiting;
        updateEthRateWithDelay(startTime - (intervalUpdate + 30));
        emit LogCrowdsaleInit();
        assert(token.balanceOf(address(this)) == MAX_TOKENS);
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    modifier mustBeAtStage(Stage requiredStage) {
        require(currentStage == requiredStage, ""Must be at the specified stage"");
        _;
    }

    function updateEthRateWithDelay(uint256 delayTime) internal {
        // Implementation of the delay logic
    }

    event LogCrowdsaleInit();
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'initializeCrowdsale', 'complexity': 7}, {'function': 'isContract', 'complexity': 0}, {'function': 'updateEthRateWithDelay', 'complexity': 0}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""queryOraclize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_queryId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_data"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""oraclize_getPrice""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""URL""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient ETH balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""oraclize_query""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_queryId""}, {""type"": ""stringLiteral"", ""value"": ""URL""}, {""type"": ""Identifier"", ""name"": ""_data""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'initializeCrowdsale', 'complexity': 7}, {'function': 'isContract', 'complexity': 0}, {'function': 'updateEthRateWithDelay', 'complexity': 0}]",8.0,"pragma solidity ^0.8.0;

import ""https://github.com/oraclize/ethereum-api/oraclizeAPI.sol"";

contract MyContract {
    using SafeMath for uint256;

    function queryOraclize(uint256 _queryId, string memory _data) public payable {
        require(msg.value >= oraclize_getPrice(""URL"", _data), ""Insufficient ETH balance"");
        oraclize_query(_queryId, ""URL"", _data);
    }
}",2.608790874481201,queryOraclize,"[{'function': 'queryOraclize', 'complexity': 1}]",2.0,80.0,0.3231686515701059,0.0127395377359907,"pragma solidity ^0.8.0;

import ""https://github.com/oraclize/ethereum-api/oraclizeAPI.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Oraclize, Ownable {
    using SafeMath for uint256;

    constructor() public Oraclize(msg.sender) {
        // Initialization of state variables
        _queryId = 1;
        _data = ""initialized"";
        owner = msg.sender;
        address1 = address(0x111);
        address2 = address(0x222);
        address3 = address(0x333);
    }

    uint256 private _queryId;
    string private _data;
    address private address1;
    address private address2;
    address private address3;

    function queryOraclize(uint256 _queryId, string memory _data) public payable {
        require(msg.value >= oraclize_getPrice(""URL"", _data), ""Insufficient ETH balance"");
        oraclize_query(_queryId, ""URL"", _data);
    }
}"
2424,Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeToken {
    function changeController(address _newController) external;
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    constructor() {}

    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) public onlyOwner returns (MiniMeToken) {
        MiniMeToken newToken = MiniMeToken(_parentToken).cloneTokenWithDetails(_snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled);
        newToken.changeController(msg.sender);
        return newToken;
    }
}","[{'function': 'changeController', 'complexity': 0}, {'function': 'createCloneToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCloneToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_controller"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Token""}, ""name"": ""clone"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Token""}}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""clone""}, ""memberName"": ""setController""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_controller""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changeController', 'complexity': 0}, {'function': 'createCloneToken', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function createCloneToken(address _controller) public returns (bool) {
        // Create new token with new functionalities
        Token clone = new Token();

        // Set controller of the clone token to the msg.sender
        clone.setController(_controller);

        return true;
    }
}",2.068469285964966,createCloneToken,"[{'function': 'createCloneToken', 'complexity': 0}]",1.0,23.0,0.6627610812421745,0.08405957314708,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    function createCloneToken(address _controller) public returns (bool) {
        // Create new token with new functionalities
        Token clone = new Token();

        // Set controller of the clone token to the msg.sender
        clone.setController(_controller);

        return true;
    }
}

contract Token is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 constructor() public {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
        totalSupply_ = 1; // Set to 1 (never 0)
        balances[owner] = 1; // Set balance of owner to 1
    }

    uint256 public totalSupply_;
    mapping(address => uint256) public balances;

    function setController(address _controller) public {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    address public controller;
}"
474,Burns the coins held by the sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function burn(uint256 _value) public whenNotPaused {
        super.burn(_value);
    }
}","[{'function': 'burn', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnCoins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}, ""memberName"": ""burnFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract CoinBurner {
    using SafeMath for uint256;

    function burnCoins(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        // Burn the coins held by the sender
        address sender = msg.sender;
        uint256 balance = IERC20(sender).balanceOf(sender);
        require(balance >= amount, ""Insufficient funds"");
        IERC20(sender).burnFrom(sender, amount);
    }
}",2.642439126968384,burnCoins,"[{'function': 'burnCoins', 'complexity': 2}]",3.0,32.0,0.5871896789293235,0.0212693758607391,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CoinBurner is Ownable {
    using SafeMath for uint256;

    // Fixed, safe values
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';
    uint256 public constant DEFAULT_UINT = 1;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe values
        _setAddress(DEFAULT_ADDRESS);
        _setBool(DEFAULT_BOOL);
        _setBytes32(DEFAULT_BYTES32);
        _setString(DEFAULT_STRING);
        _setUint(DEFAULT_UINT);
    }

    function burnCoins(uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        // Burn the coins held by the sender
        address sender = msg.sender;
        uint256 balance = IERC20(sender).balanceOf(sender);
        require(balance >= amount, ""Insufficient funds"");
        IERC20(sender).burnFrom(sender, amount);
    }
}"
1413,Overwrite leaderboard name and desctiption as owner only,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BoardManager is Ownable {
    using SafeMath for uint256;

    struct Board {
        bytes32 boardName;
        string boardDescription;
        address boardOwner;
    }

    mapping(bytes32 => Board) public boards;

    function changeBoardMetadata(bytes32 boardHash, bytes32 name, string memory boardDescription) public onlyOwner returns (bool) {
        require(boards[boardHash].boardOwner == msg.sender);
        boards[boardHash].boardName = name;
        boards[boardHash].boardDescription = boardDescription;
        return true;
    }
}","[{'function': 'changeBoardMetadata', 'complexity': 1}]",2.0,{},"[{'function': 'changeBoardMetadata', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""./Leaderboard.sol"";

contract Leaderboard {
    using SafeMath for uint256;

    struct LeaderboardEntry {
        address playerAddress;
        uint256 score;
    }

    mapping(address => LeaderboardEntry) public leaderboard;

    function overwriteLeaderboardNameAndDescriptionAsOwner(string memory _name, string memory _description) public onlyOwner {
        // Additional logic can be added here
    }
}",2.4051966667175293,overwriteLeaderboardNameAndDescriptionAsOwner,"[{'function': 'overwriteLeaderboardNameAndDescriptionAsOwner', 'complexity': 0}]",1.0,38.0,0.5855890578382563,0.0434807361154529,"pragma solidity ^0.8.0;

import ""./Leaderboard.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Leaderboard is Ownable {
    using SafeMath for uint256;

    struct LeaderboardEntry {
        address playerAddress;
        uint256 score;
    }

    mapping(address => LeaderboardEntry) public leaderboard;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            leaderboard[addr] = LeaderboardEntry({playerAddress: addr, score: uint256(i)});
        }
    }

    function overwriteLeaderboardNameAndDescriptionAsOwner(string memory _name, string memory _description) public onlyOwner {
        // Additional logic can be added here
    }
}"
6348,"Helps to generate Collectibles/Tokens/Asset and transfer to ETH Cards , which can be redeemed using our web-app.The generation of an asset if limited via the generationSeasonController","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ETHCardCollectible is Ownable {
    using SafeMath for uint256;

    uint8 public teamId;
    uint8 public posId;
    uint256 public attributes;
    address public owner;
    uint256 public gameId;
    uint256 public playerOverrideId;
    uint256 public mlbPlayerId;
    uint256 public rewardsRedeemed;
    address public managerPrimary;
    bool public paused = false;

    constructor(address _managerPrimary) {
        managerPrimary = _managerPrimary;
    }

    function createETHCardCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) external canCreate whenNotPaused returns (uint256) {
        address nftOwner = _owner;
        if (nftOwner == address(0)) {
            nftOwner = managerPrimary;
        }
        rewardsRedeemed++;
        uint32 _sequenceId = getSequenceId(_teamId);
        uint256 assetDetails = uint256(uint64(now));
        assetDetails |= uint256(_sequenceId) << 64;
        assetDetails |= uint256(_teamId) << 96;
        assetDetails |= uint256(_posId) << 104;
        uint256[5] memory _nftData = [assetDetails, _attributes, _gameId, _playerOverrideId, _mlbPlayerId];
        return _createNFTCollectible(_teamId, _attributes, nftOwner, 2, _nftData);
    }

    function getSequenceId(uint8 _teamId) internal pure returns (uint32) {
        // Implementation of getSequenceId logic
        return uint32(_teamId);
    }

    function _createNFTCollectible(uint8 _teamId, uint256 _attributes, address _owner, uint256 _type, uint256[5] memory _nftData) internal returns (uint256) {
        // Implementation of create NFT logic
        return 0;
    }

    modifier canCreate() {
        require(msg.sender == owner || msg.sender == managerPrimary, ""Not authorized to create collectible"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }
}","[{'function': 'createETHCardCollectible', 'complexity': 1}, {'function': 'getSequenceId', 'complexity': 0}, {'function': '_createNFTCollectible', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""generateAsset"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_asset""}], ""names"": []}], ""names"": []}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10000"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Maximum supply reached""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_asset""}], ""names"": []}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokenId""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createETHCardCollectible', 'complexity': 1}, {'function': 'getSequenceId', 'complexity': 0}, {'function': '_createNFTCollectible', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

contract AssetGeneration {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public isOwner;

    constructor() public {
        owner = msg.sender;
        isOwner[msg.sender] = true;
    }

    modifier onlyOwner() {
        require(isOwner[msg.sender], ""Only the contract owner can call this function"");
        _;
    }

    function generateAsset(uint256 amount) public onlyOwner {
        require(amount > 0, ""Invalid amount"");
        uint256 totalSupply = IERC721(address(_asset)).totalSupply();
        require(totalSupply + amount <= 10000, ""Maximum supply reached"");
        for (uint256 i = 0; i < amount; i++) {
            uint256 tokenId = totalSupply.add(i);
            IERC721(_asset).mint(msg.sender, tokenId);
        }
    }
}",4.869708776473999,generateAsset,"[{'function': 'generateAsset', 'complexity': 3}]",4.0,69.0,0.4687625376457353,0.0218116482599028,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetGeneration is Ownable {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public isOwner;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        owner = msg.sender;
        isOwner[msg.sender] = true;
    }

    modifier onlyOwner() {
        require(isOwner[msg.sender], ""Only the contract owner can call this function"");
        _;
    }

    function generateAsset(uint256 amount) public onlyOwner {
        require(amount > 0, ""Invalid amount"");
        uint256 totalSupply = IERC721(address(_asset)).totalSupply();
        require(totalSupply + amount <= 10000, ""Maximum supply reached"");
        for (uint256 i = 0; i < amount; i++) {
            uint256 tokenId = totalSupply.add(i);
            IERC721(_asset).mint(msg.sender, tokenId);
        }
    }
}"
6764,"This method can be called by authorized persons only , and can issue a refund of the fee to the ` origin ` address who paid the fee for ` who ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => address[]) public s_paid;
    uint256 public fee;

    modifier only_delegate() {
        require(hasRole(keccak256(""DELEGATE""), msg.sender), ""Only delegate can call this function"");
        _;
    }

    function revoke(address who, address origin) payable external only_delegate {
        require(msg.value == fee, ""Incorrect fee amount"");
        bool found = false;
        for (uint i = 0; i < s_paid[who].length; i++) {
            if (s_paid[who][i] != origin) {
                continue;
            }
            found = true;
            uint lastIndex = s_paid[who].length.sub(1);
            if (i != lastIndex) {
                s_paid[who][i] = s_paid[who][lastIndex];
            }
            s_paid[who].pop();
            break;
        }
        require(found, ""Origin not found"");
        origin.transfer(msg.value);
    }
}","[{'function': 'revoke', 'complexity': 9}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""refundFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""origin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""who"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""origin""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""who""}}}, {""type"": ""stringLiteral"", ""value"": ""Only authorized persons can call this method""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""10000000000000000"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""receiver"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""origin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""receiver""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fee""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'revoke', 'complexity': 9}]",6.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function refundFee(address origin, address who) public {
        require(msg.sender == origin || msg.sender == who, ""Only authorized persons can call this method"");
        uint256 fee = 10000000000000000; // 0.01 ETH
        address payable receiver = payable(origin);
        receiver.transfer(fee);
    }
}",2.787349939346313,refundFee,"[{'function': 'refundFee', 'complexity': 2}]",3.0,53.0,0.6766973318148873,0.0262775419969216,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        someUint = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        someAddress = address(uint160(uint256(keccak256('address1'))));

        // bool: Set to true
        someBool = true;

        // string: Set to 'initialized'
        someString = ""initialized"";

        // bytes32: Set to bytes32('init')
        someBytes32 = bytes32(keccak256(""init""));
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function refundFee(address origin, address who) public {
        require(msg.sender == origin || msg.sender == who, ""Only authorized persons can call this method"");
        uint256 fee = 10000000000000000; // 0.01 ETH
        address payable receiver = payable(origin);
        receiver.transfer(fee);
    }
}"
5397,Transfers tokens held by timelock to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function safeTransfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenRelease is Ownable {
    using SafeMath for uint;

    uint public releaseTime;
    uint public current_month;
    uint public month = 1 months;
    uint public twenty_percent_of_amount;
    address public beneficiary;
    IERC20 public token;

    constructor(uint _releaseTime, uint _twenty_percent_of_amount, address _beneficiary, address _token) {
        releaseTime = _releaseTime;
        current_month = 1;
        twenty_percent_of_amount = _twenty_percent_of_amount;
        beneficiary = _beneficiary;
        token = IERC20(_token);
    }

    function release() public {
        require(now >= releaseTime, ""Release time not yet reached"");
        assert(current_month <= 5);
        uint diff = now - releaseTime;
        if (diff > month) {
            releaseTime = now;
        } else {
            releaseTime = now.add(month.sub(diff));
        }
        current_month++;
        token.safeTransfer(beneficiary, twenty_percent_of_amount);
    }
}","[{'function': 'safeTransfer', 'complexity': 0}, {'function': 'release', 'complexity': 5}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""releaseTime""}}, {""type"": ""stringLiteral"", ""value"": ""Timelock: tokens not released yet""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'safeTransfer', 'complexity': 0}, {'function': 'release', 'complexity': 5}]",7.0,"
pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin-solidity/contracts/utils/SafeMath.sol"";

contract Timelock {
    using SafeMath for uint256;

    IERC20 public token;
    address public beneficiary;
    uint256 public releaseTime;

    constructor(IERC20 _token, address _beneficiary, uint256 _releaseTime) {
        token = _token;
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
    }

    function transferTokens() public {
        require(block.timestamp >= releaseTime, ""Timelock: tokens not released yet"");
        uint256 amount = token.balanceOf(address(this));
        token.transfer(beneficiary, amount);
    }
}",4.47184681892395,transferTokens,"[{'function': 'transferTokens', 'complexity': 1}]",2.0,25.0,0.6704342491848858,0.1311299995726338,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin-solidity/contracts/utils/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Timelock is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address public beneficiary;
    uint256 public releaseTime;

    mapping(address => uint256) public balanceOf;

 constructor(IERC20 _token, address _beneficiary, uint256 _releaseTime) Ownable(msg.sender) {
        token = _token;
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
    }

    function transferTokens() public {
        require(block.timestamp >= releaseTime, ""Timelock: tokens not released yet"");
        uint256 amount = token.balanceOf(address(this));
        token.transfer(beneficiary, amount);
    }
}"
4047,Checks if the order given offchain coincides with the order of the actual previously calculated points in the smart contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum pointsValidationState { NotStarted, LimitCalculated, OrderChecked }
    pointsValidationState public pValidationState;
    uint256 public winnerCounter;
    uint256 public pointsLimit;
    mapping(uint256 => uint256) public tokenToPointsMap;
    uint256[] private sortedWinners;

    constructor() {
        pValidationState = pointsValidationState.NotStarted;
    }

    function checkOrder(uint32[] memory sortedChunk) external onlyOwner checkState(pointsValidationState.LimitCalculated) {
        require(sortedChunk.length + sortedWinners.length <= winnerCounter);

        for (uint256 i = 0; i < sortedChunk.length - 1; i++) {
            uint256 id = sortedChunk[i];
            uint256 sigId = sortedChunk[i + 1];
            require(tokenToPointsMap[id] > tokenToPointsMap[sigId] || (tokenToPointsMap[id] == tokenToPointsMap[sigId] && id < sigId));
        }

        if (sortedWinners.length != 0) {
            uint256 id2 = sortedWinners[sortedWinners.length - 1];
            uint256 sigId2 = sortedChunk[0];
            require(tokenToPointsMap[id2] > tokenToPointsMap[sigId2] || (tokenToPointsMap[id2] == tokenToPointsMap[sigId2] && id2 < sigId2));
        }

        for (uint256 j = 0; j < sortedChunk.length; j++) {
            sortedWinners.push(sortedChunk[j]);
        }

        if (sortedWinners.length == winnerCounter) {
            require(sortedWinners[sortedWinners.length - 1] == pointsLimit);
            pValidationState = pointsValidationState.OrderChecked;
        }
    }

    modifier checkState(pointsValidationState expectedState) {
        require(pValidationState == expectedState, ""Invalid state"");
        _;
    }
}","[{'function': 'checkOrder', 'complexity': 12}]",13.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkOrder"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""offchainOrder"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""actualPoints"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offchainOrder""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""actualPoints""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid order length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offchainOrder""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offchainOrder""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""actualPoints""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}, ""FalseBody"": None}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'checkOrder', 'complexity': 12}]",13.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function checkOrder(uint256[] memory offchainOrder, uint256[] memory actualPoints) public view returns (bool) {
        require(offchainOrder.length == actualPoints.length, ""Invalid order length"");

        for (uint256 i = 0; i < offchainOrder.length; i++) {
            if (offchainOrder[i] != actualPoints[i]) {
                return false;
            }
        }

        return true;
    }
}",2.9877169132232666,checkOrder,"[{'function': 'checkOrder', 'complexity': 4}]",4.0,74.0,0.6786433208017434,0.0630955411669031,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function checkOrder(uint256[] memory offchainOrder, uint256[] memory actualPoints) public view returns (bool) {
        require(offchainOrder.length == actualPoints.length, ""Invalid order length"");

        for (uint256 i = 0; i < offchainOrder.length; i++) {
            if (offchainOrder[i] != actualPoints[i]) {
                return false;
            }
        }

        return true;
    }
}"
527,The value in HAV for a given amount of USD,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PriceOracle {
    function price() external view returns (uint);
}

abstract contract USDtoHAVWrapper is Ownable {
    using SafeMath for uint256;

    PriceOracle public oracle;

    constructor(address _oracle) {
        oracle = PriceOracle(_oracle);
    }

    function safeDiv_dec(uint usd_dec, uint price) internal pure returns (uint) {
        require(price > 0, ""SafeMath: division by zero"");
        return usd_dec.div(price);
    }

    function USDtoHAV(uint usd_dec) public view priceNotStale returns (uint) {
        uint price = oracle.price();
        require(price > 0, ""Price is stale or incorrect"");
        return safeDiv_dec(usd_dec, price);
    }

    modifier priceNotStale() {
        require(oracle.price() != 0, ""Price is not available or has expired"");
        _;
    }
}","[{'function': 'price', 'complexity': 0}, {'function': 'safeDiv_dec', 'complexity': 1}, {'function': 'USDtoHAV', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getHavValue"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""usdAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""havValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""usdAmount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""havRate""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'price', 'complexity': 0}, {'function': 'safeDiv_dec', 'complexity': 1}, {'function': 'USDtoHAV', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract HavValue {
    using SafeMath for uint256;

    function getHavValue(uint256 usdAmount) public view returns (uint256 havValue) {
        return usdAmount.mul(10**18).div(havRate);
    }
}",3.45916748046875,getHavValue,"[{'function': 'getHavValue', 'complexity': 0}]",1.0,15.0,0.6502554934188508,0.0434068068041903,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of adding Ownable functionality

contract HavValue is Ownable {
    using SafeMath for uint256;

    uint256 public constant HAV_RATE = 10**18; // Fixed value for havRate
    uint256 private havRate;

    constructor() {
        // Initialize state variables with safe, non-corner-case values
        havRate = 1; // Set to a fixed, non-zero value
        initializeOwnable(); // Properly initialize Ownable
    }

    function getHavValue(uint256 usdAmount) public view returns (uint256 havValue) {
        return usdAmount.mul(HAV_RATE).div(havRate);
    }
}"
3318,Return hash containing all of the information about the burnCarbonDollar ( ) metatransaction,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MetaBurnHashWrapper is Ownable {
    using SafeMath for uint256;

    function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), ""metaBurnCarbonDollar"", _stablecoin, _amount, _nonce, _reward));
    }
}","[{'function': 'metaBurnHash', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnCarbonDollar"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""hash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""hash""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'metaBurnHash', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract CarbonDollarBurner {
    using SafeMath for uint256;

    function burnCarbonDollar(address sender, address recipient, uint256 amount) public returns (bytes32) {
        require(sender != address(0), ""Invalid sender"");
        require(recipient != address(0), ""Invalid recipient"");

        bytes32 hash = keccak256(abi.encodePacked(sender, recipient, amount));
        return hash;
    }
}",2.500577688217163,burnCarbonDollar,"[{'function': 'burnCarbonDollar', 'complexity': 2}]",3.0,25.0,0.6940107261027811,0.1528510540852385,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract CarbonDollarBurner {
    using SafeMath for uint256;

    // Initialize state variables with fixed, safe values
    address public constant sender = 0x1111111111111111111111111111111111111111; // Replace with actual value
    address public constant recipient = 0x2222222222222222222222222222222222222222; // Replace with actual value
    uint256 public constant amount = 1;
    bool public initialized = true;
    bytes32 public hash;

    constructor() Ownable(msg.sender) {
        // Initialize state variables in the constructor
        sender = 0x1111111111111111111111111111111111111111; // Replace with actual value
        recipient = 0x2222222222222222222222222222222222222222; // Replace with actual value
        amount = 1;
        initialized = true;
    }

    function burnCarbonDollar(address _sender, address _recipient, uint256 _amount) public returns (bytes32) {
        require(_sender != address(0), ""Invalid sender"");
        require(_recipient != address(0), ""Invalid recipient"");

        bytes32 hash = keccak256(abi.encodePacked(_sender, _recipient, _amount));
        return hash;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address public owner;

    constructor(address _owner) {
        owner = _owner;
    }

    function transferOwnership(address newOwner) public {
        require(msg.sender == owner, ""Only the current owner can transfer ownership"");
        owner = newOwner;
    }
}"
1663,Access point for the oracle to update the price of havvens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public price;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 days; // Example value, adjust as needed

    event PriceUpdated(uint newPrice, uint timeSent);

    function updatePrice(uint newPrice, uint timeSent) external onlyOwner {
        require(lastPriceUpdateTime < timeSent && timeSent < now.add(ORACLE_FUTURE_LIMIT), ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        price = newPrice;
        lastPriceUpdateTime = timeSent;
        emit PriceUpdated(newPrice, timeSent);
    }
}","[{'function': 'updatePrice', 'complexity': 2}]",3.0,{},"[{'function': 'updatePrice', 'complexity': 2}]",3.0,"
contract Havvens {
    using SafeMath for uint;

    struct Price {
        uint256 value;
    }

    mapping(address => Price) public prices;

    function updatePrice(uint256 _value, address _oracle) external {
        require(_value > 0, ""Invalid price"");
        require(prices[_oracle].value == 0, ""Oracle already updated price"");

        prices[_oracle] = Price({ value: _value });
    }
}",2.230131387710572,updatePrice,"[{'function': 'updatePrice', 'complexity': 2}]",3.0,35.0,0.764068419467454,0.0433710311822415,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Havvens is Ownable {
    using SafeMath for uint256;

    struct Price {
        uint256 value;
    }

    mapping(address => Price) public prices;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            prices[addr] = Price({ value: uint256(i) });
        }
    }

    function updatePrice(uint256 _value, address _oracle) external {
        require(_value > 0, ""Invalid price"");
        require(prices[_oracle].value == 0, ""Oracle already updated price"");

        prices[_oracle] = Price({ value: _value });
    }
}"
6383,Approve address to become creator of that pack,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetPackApproval {
    using SafeMath for uint256;

    struct AssetPack {
        address creator;
    }

    mapping(uint => AssetPack) public assetPacks;
    mapping(uint => address) public approvedTakeover;

    function approveTakeover(uint _assetPackId, address _newCreator) public {
        require(assetPacks[_assetPackId].creator == msg.sender);
        approvedTakeover[_assetPackId] = _newCreator;
    }
}","[{'function': 'approveTakeover', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveCreator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""creator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""creator""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""packs""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""memberName"": ""isApproved""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""creator""}, {""type"": ""Identifier"", ""name"": ""id""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approveTakeover', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

contract PackCreator {
    struct Pack {
        uint256 id;
        address creator;
        string name;
        string description;
        uint256 price;
        bool isApproved;
    }

    mapping(uint256 => Pack) public packs;

    function approveCreator(uint256 id, address creator) external {
        require(msg.sender == creator);
        packs[id].isApproved = true;
        emit Approval(creator, id);
    }
}",2.840972423553467,approveCreator,"[{'function': 'approveCreator', 'complexity': 1}]",2.0,10.0,0.7470957957198088,0.0540177816113921,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PackCreator is Ownable {
    struct Pack {
        uint256 id;
        address creator;
        string name;
        string description;
        uint256 price;
        bool isApproved;
    }

    mapping(uint256 => Pack) public packs;

    event Approval(address indexed creator, uint256 indexed id);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            packs[i] = Pack({
                id: i,
                creator: address(uint160(uint256(keccak256(abi.encodePacked(""creator"", i)))),
                name: 'PackName',
                description: 'Description of the pack',
                price: 1 ether, // Set to a fixed value that is never zero or corner-case
                isApproved: false
            });
        }
    }

    function approveCreator(uint256 id, address creator) external {
        require(msg.sender == creator);
        packs[id].isApproved = true;
        emit Approval(creator, id);
    }
}"
5701,Returns the division of two numbers Function used for division operations inside the smartcontract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DivisionWrapper is Ownable {
    using SafeMath for uint256;

    function division(uint numerator, uint denominator) public view onlyOwner returns (uint result) {
        require(denominator != 0, ""Division by zero"");
        return numerator.div(denominator);
    }
}","[{'function': 'division', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""divide"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""a""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'division', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract Division {
    using SafeMath for uint256;

    function divide(uint256 a, uint256 b) public pure returns (uint256) {
        return a.div(b);
    }
}",1.9615378379821773,divide,"[{'function': 'divide', 'complexity': 0}]",1.0,8.0,0.6216369673754294,0.0430480778142067,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Division is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are already initialized by the parent contract (Ownable) and library usage.
    }

    function divide(uint256 a, uint256 b) public pure returns (uint256) {
        require(b > 0, ""Division by zero""); // Adding a simple check to avoid division by zero
        return a.div(b);
    }
}"
2851,Function used by the creator to set the presale limits,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PresaleAmountLimits {
    using SafeMath for uint256;

    function setPresaleAmountLimits(uint256 _minPresaleAmount, uint256 _maxPresaleAmount) public pure {
        require(_minPresaleAmount > 0, ""Minimum presale amount must be greater than 0"");
        require(_maxPresaleAmount > 0, ""Maximum presale amount must be greater than 0"");
        require(_minPresaleAmount <= _maxPresaleAmount, ""Minimum presale amount must be less than or equal to maximum presale amount"");
    }
}","[{'function': 'setPresaleAmountLimits', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setLimit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_creator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Limit""}, ""name"": ""_limit"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_creator""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""limits""}, ""index"": {""type"": ""Identifier"", ""name"": ""_creator""}}, ""memberName"": ""maxSupply""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Only the creator or an existing limit can be updated""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""limits""}, ""index"": {""type"": ""Identifier"", ""name"": ""_creator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_limit""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPresaleAmountLimits', 'complexity': 3}]",4.0,"
pragma solidity ^0.8.0;

contract PresaleLimits {
    using SafeMath for uint256;

    struct Limit {
        uint256 maxSupply;
        uint256 minPurchaseAmount;
        uint256 maxPurchaseAmount;
    }

    mapping(address => Limit) public limits;

    function setLimit(address _creator, Limit memory _limit) external {
        require(_creator == msg.sender || limits[_creator].maxSupply > 0, ""Only the creator or an existing limit can be updated"");
        limits[_creator] = _limit;
    }
}",3.1770708560943604,setLimit,"[{'function': 'setLimit', 'complexity': 2}]",3.0,19.0,0.5313147901537579,0.0258182848472015,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PresaleLimits is Ownable {
    using SafeMath for uint256;

    struct Limit {
        uint256 maxSupply;
        uint256 minPurchaseAmount;
        uint256 maxPurchaseAmount;
    }

    mapping(address => Limit) public limits;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            limits[addr] = Limit({
                maxSupply: 1, // Set to 1 (never 0)
                minPurchaseAmount: 1, // Set to 1 (never 0)
                maxPurchaseAmount: 1 // Set to 1 (never 0)
            });
        }
    }

    function setLimit(address _creator, Limit memory _limit) external {
        require(_creator == msg.sender || limits[_creator].maxSupply > 0, ""Only the creator or an existing limit can be updated"");
        limits[_creator] = _limit;
    }
}"
5928,Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Authorizable is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public mAuthorized;

    event AuthorizedOperator(address indexed operator, address indexed owner);

    function authorizeOperator(address _operator) public override onlyOwner {
        require(_operator != msg.sender, ""The operator must be different from the sender."");
        mAuthorized[_operator][msg.sender] = true;
        emit AuthorizedOperator(_operator, msg.sender);
    }
}","[{'function': 'authorizeOperator', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""authorizeOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_senders"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can authorize an operator""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_senders""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_senders""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}, {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'authorizeOperator', 'complexity': 1}]",3.0,"example Solidity smart contract function that adheres to the given code summary:
```
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol"";

contract TokenManager {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _token) public {
        token = IERC20(_token);
    }

    function authorizeOperator(address _operator, address[] memory _senders) external {
        require(msg.sender == owner(), ""Only the contract owner can authorize an operator"");

        for (uint256 i = 0; i < _senders.length; i++) {
            token.approve(_operator, SafeMath.mul(token.balanceOf(_senders[i]), 10**18));
        }
    }
}",9.082250833511353,authorizeOperator,"[{'function': 'authorizeOperator', 'complexity': 2}]",3.0,32.0,0.8692684852079416,0.126215468738912,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenManager is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    mapping(address => uint256) public balanceOf;

 constructor(address _token) {
        initialize(_token);
    }

    function initialize(address _token) internal {
        require(_token != address(0), ""Invalid token address"");
        token = IERC20(_token);
    }

    function authorizeOperator(address _operator, address[] memory _senders) external onlyOwner {
        for (uint256 i = 0; i < _senders.length; i++) {
            token.approve(_operator, SafeMath.mul(token.balanceOf(_senders[i]), 10**18));
        }
    }
}"
1383,Performs allowance transfer of asset balance between holders .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IAsset {
    function __transferFromWithReference(address _from, address _to, uint256 _value, string memory _reference, address _sender) external returns (bool);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    IAsset public asset;

    constructor(address _assetAddress) {
        asset = IAsset(_assetAddress);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return asset.__transferFromWithReference(_from, _to, _value, """", msg.sender);
        }
        return false;
    }
}","[{'function': '__transferFromWithReference', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowanceTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""From address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""To address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fromBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""toBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""fromBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""fromBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""toBalance""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": False}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '__transferFromWithReference', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract AssetTransfer {
    using SafeMath for uint256;

    function allowanceTransfer(address from, address to, uint256 amount) public returns (bool) {
        require(from != address(0), ""From address cannot be zero"");
        require(to != address(0), ""To address cannot be zero"");
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 fromBalance = balanceOf[from];
        uint256 toBalance = balanceOf[to];

        if (fromBalance >= amount) {
            balanceOf[from] = fromBalance.sub(amount);
            balanceOf[to] = toBalance.add(amount);
            return true;
        } else {
            return false;
        }
    }
}",4.0488362312316895,allowanceTransfer,"[{'function': 'allowanceTransfer', 'complexity': 4}]",5.0,37.0,0.726728917738537,0.1359932599078454,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is for Ownable contract

contract AssetTransfer is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[owner()] = 1 ether; // Set initial balance to 1 ether for the owner
    }

    function allowanceTransfer(address from, address to, uint256 amount) public returns (bool) {
        require(from != address(0), ""From address cannot be zero"");
        require(to != address(0), ""To address cannot be zero"");
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 fromBalance = balanceOf[from];
        uint256 toBalance = balanceOf[to];

        if (fromBalance >= amount) {
            balanceOf[from] = fromBalance.sub(amount);
            balanceOf[to] = toBalance.add(amount);
            return true;
        } else {
            return false;
        }
    }
}"
5667,Returns the address currently assigned ownership of a given token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract {
    using SafeMath for uint256;

    address[] public tokenIndexToOwner;

    function ownerOf(uint _tokenId) external view returns (address) {
        require(tokenIndexToOwner[_tokenId] != address(0));
        return tokenIndexToOwner[_tokenId];
    }
}","[{'function': 'ownerOf', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getOwnerOfToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, ""memberName"": ""ownerOf""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'ownerOf', 'complexity': 1}]",2.0,"
function getOwnerOfToken(address _token) public view returns (address) {
    return IERC721(_token).ownerOf();
}",0.6603879928588867,getOwnerOfToken,"[{'function': 'getOwnerOfToken', 'complexity': 0}]",1.0,10.0,0.7732227011686666,0.2417955457996045,"contract MyContract {
    address private constant _INITIAL_ADDRESS = 0x1111111111111111111111111111111111111111;
    uint256 private constant _INITIAL_UINT256 = 1;
    bool private constant _INITIAL_BOOL = true;
    string private constant _INITIAL_STRING = 'initialized';
    bytes32 private constant _INITIAL_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize state variables
        _owner = msg.sender;
        _tokenBalance = 0;
        _tokenName = 'MyToken';
    }

    address public owner;
    uint256 public tokenBalance;
    string public tokenName;

    function getOwnerOfToken(address _token) public view returns (address) {
        return IERC721(_token).ownerOf();
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;

    constructor(address _owner) {
        // Initialize state variable
        _owner = _owner;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}"
5392,"Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract LoanContract is Ownable {
    using SafeMath for uint256;

    struct Loan {
        address lender;
        address approvedTransfer;
    }

    mapping(uint256 => Loan) public loans;
    mapping(address => uint256) public lendersBalance;

    event Transfer(address indexed from, address indexed to, uint256 index);

    function transfer(address to, uint256 index) public returns (bool) {
        Loan storage loan = loans[index];
        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);
        require(to != address(0));
        loan.lender = to;
        loan.approvedTransfer = address(0);
        lendersBalance[msg.sender] = lendersBalance[msg.sender].sub(1);
        lendersBalance[to] = lendersBalance[to].add(1);
        emit Transfer(loan.lender, to, index);
        return true;
    }
}","[{'function': 'transfer', 'complexity': 3}]",4.0,{},"[{'function': 'transfer', 'complexity': 3}]",4.0,"
contract LoanTransfer {
    enum Status { LENT, APPROVED }

    struct Loan {
        address lender;
        uint256 amount;
        Status status;
    }

    mapping(address => Loan) public loans;

    function transferLoan(address _lender, uint256 _amount, address _newLender) external {
        require(loans[_lender].status == Status.LENT, ""Loan is not lent"");
        require(_amount <= loans[_lender].amount, ""Insufficient amount"");

        if (msg.sender != loans[_lender].lender) {
            require(loans[_lender].status == Status.APPROVED && msg.sender == loans[_lender].approvedLender, ""Only approved lenders can transfer the loan"");
        }

        loans[_newLender] = Loan({
            lender: _newLender,
            amount: _amount,
            status: Status.LENT
        });
    }
}",4.687743902206421,transferLoan,"[{'function': 'transferLoan', 'complexity': 5}]",6.0,82.0,0.6998840440204414,0.0660622078200307,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LoanTransfer is Ownable {
    enum Status { LENT, APPROVED }

    struct Loan {
        address lender;
        uint256 amount;
        Status status;
    }

    mapping(address => Loan) public loans;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            loans[addr] = Loan({
                lender: addr,
                amount: uint256(i),
                status: Status.LENT
            });
        }
    }

    function transferLoan(address _lender, uint256 _amount, address _newLender) external {
        require(loans[_lender].status == Status.LENT, ""Loan is not lent"");
        require(_amount <= loans[_lender].amount, ""Insufficient amount"");

        if (msg.sender != loans[_lender].lender) {
            require(loans[_lender].status == Status.APPROVED && msg.sender == loans[_lender].approvedLender, ""Only approved lenders can transfer the loan"");
        }

        loans[_newLender] = Loan({
            lender: _newLender,
            amount: _amount,
            status: Status.LENT
        });
    }
}"
6100,Allows a grant recipient to claim their vested tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenVesting is Ownable {
    using SafeMath for uint256;

    struct Grant {
        uint256 yearsClaimed;
        uint256 totalClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    IERC20 public token;

    event GrantTokensClaimed(address indexed recipient, uint256 amount);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function calculateGrantClaim(address _recipient) internal view returns (uint256 yearsVested, uint256 amountVested) {
        // Implementation of the calculation logic for calculating vested tokens
        // This is a placeholder and should be replaced with actual implementation
        yearsVested = 0; // Example value
        amountVested = 0; // Example value
    }

    function claimVestedTokens(address _recipient) external {
        uint256 yearsVested;
        uint256 amountVested;
        (yearsVested, amountVested) = calculateGrantClaim(_recipient);
        require(amountVested > 0, ""amountVested is 0"");
        Grant storage tokenGrant = tokenGrants[_recipient];
        tokenGrant.yearsClaimed = yearsVested;
        tokenGrant.totalClaimed = tokenGrant.totalClaimed.add(amountVested);
        require(token.transfer(_recipient, amountVested), ""no tokens"");
        emit GrantTokensClaimed(_recipient, amountVested);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'calculateGrantClaim', 'complexity': 0}, {'function': 'claimVestedTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimVestedTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Grant""}, ""name"": ""grant"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""grants""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingStart""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingEnd""}}}, {""type"": ""stringLiteral"", ""value"": ""Grant has not started or has ended""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""vestedAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingStart""}}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingEnd""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestingStart""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""vestedAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to claim""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""grant""}, ""memberName"": ""vestedAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""vestedAmount""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'calculateGrantClaim', 'complexity': 0}, {'function': 'claimVestedTokens', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract TokenGrant {
    using SafeMath for uint256;

    struct Grant {
        address recipient;
        uint256 amount;
        uint256 vestingStart;
        uint256 vestingEnd;
        uint256 vestedAmount;
    }

    mapping(address => Grant) public grants;

    function claimVestedTokens() external {
        Grant storage grant = grants[msg.sender];
        require(grant.vestingStart <= block.timestamp && block.timestamp <= grant.vestingEnd, ""Grant has not started or has ended"");
        uint256 vestedAmount = grant.amount.mul(block.timestamp - grant.vestingStart).div(grant.vestingEnd - grant.vestingStart);
        require(vestedAmount > 0, ""No tokens to claim"");
        grant.vestedAmount += vestedAmount;
    }
}",4.49147891998291,claimVestedTokens,"[{'function': 'claimVestedTokens', 'complexity': 3}]",4.0,46.0,0.8793874866919604,0.0942114948167702,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and that you have an Ownable contract defined elsewhere

contract TokenGrant is Ownable {
    using SafeMath for uint256;

    struct Grant {
        address recipient;
        uint256 amount;
        uint256 vestingStart;
        uint256 vestingEnd;
        uint256 vestedAmount;
    }

    mapping(address => Grant) public grants;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')

        grants[msg.sender] = Grant({
            recipient: msg.sender,
            amount: 1,
            vestingStart: block.timestamp,
            vestingEnd: block.timestamp + 1 weeks, // Example: vesting period of 1 week
            vestedAmount: 0
        });
    }

    function claimVestedTokens() external {
        Grant storage grant = grants[msg.sender];
        require(grant.vestingStart <= block.timestamp && block.timestamp <= grant.vestingEnd, ""Grant has not started or has ended"");
        uint256 vestedAmount = grant.amount.mul(block.timestamp - grant.vestingStart).div(grant.vestingEnd - grant.vestingStart);
        require(vestedAmount > 0, ""No tokens to claim"");
        grant.vestedAmount += vestedAmount;
    }
}"
949,Emits ERC20 Approval event on this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function emitApprove(address _from, address _spender, uint _value) public onlyChronoBankPlatform {
        emit Approval(_from, _spender, _value);
    }
}","[{'function': 'emitApprove', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'emitApprove', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
contract MyContract {
    using SafeMath for uint256;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function approve(uint256 amount) public {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        _allowances[msg.sender][msg.sender].add(amount);
        emit Approval(msg.sender, msg.sender, amount);
    }
}",2.880352020263672,approve,"[{'function': 'approve', 'complexity': 1}]",2.0,28.0,0.6671005039785773,0.0595533061435797,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _balances[msg.sender] = 1000;
        for (uint256 i = 0; i < 3; i++) {
            if (i == 0) _allowances[address(this)][address(this)] = 1;
            else if (i == 1) _allowances[msg.sender][msg.sender] = 1;
            else if (i == 2) _balances[address(this)] = 1;
        }
    }

    function approve(uint256 amount) public {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        _allowances[msg.sender][msg.sender].add(amount);
        emit Approval(msg.sender, msg.sender, amount);
    }
}"
6735,Makes checkmark and deposits tokens on profiterole account to pay them later as bonuses for Treasury shares holders .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Treasury {
    function addDistributionPeriod() external;
}

abstract contract BonusDistributor is Ownable {
    using SafeMath for uint256;

    ERC20Interface public bonusToken;
    address public wallet;
    mapping(uint => Deposit) public distributionDeposits;
    uint public firstDepositDate;
    uint public lastDepositDate;
    bytes32 constant PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE = 0x0;
    bytes32 constant PROFITEROLE_ERROR_TRANSFER_ERROR = 0x1;
    uint constant OK = 0;

    struct Deposit {
        uint amount;
        uint nextDepositDate;
        uint claimedAmount;
    }

    event DepositPendingAdded(uint indexed amount, address indexed depositor, uint indexed timestamp);

    modifier onlyDistributionSource() {
        require(msg.sender == wallet, ""Only the distribution source can call this function"");
        _;
    }

    constructor(address _bonusToken, address _wallet) {
        bonusToken = ERC20Interface(_bonusToken);
        wallet = _wallet;
    }

    function distributeBonuses(uint _amount) public onlyDistributionSource returns (uint) {
        ERC20Interface _bonusToken = ERC20Interface(bonusToken);
        if (_bonusToken.allowance(msg.sender, address(this)) < _amount) {
            return uint(_emitError(PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE));
        }
        if (!_bonusToken.transferFrom(msg.sender, wallet, _amount)) {
            return uint(_emitError(PROFITEROLE_ERROR_TRANSFER_ERROR));
        }
        if (firstDepositDate == 0) {
            firstDepositDate = block.timestamp;
        }
        uint _lastDepositDate = lastDepositDate;
        if (_lastDepositDate != 0) {
            distributionDeposits[_lastDepositDate].nextDepositDate = block.timestamp;
        }
        lastDepositDate = block.timestamp;
        distributionDeposits[block.timestamp] = Deposit(_amount, 0, 0);
        Treasury(treasury).addDistributionPeriod();
        emit DepositPendingAdded(_amount, msg.sender, block.timestamp);
        return OK;
    }

    function _emitError(bytes32 errorCode) internal pure returns (bytes4) {
        return bytes4(errorCode);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'addDistributionPeriod', 'complexity': 0}, {'function': 'distributeBonuses', 'complexity': 5}, {'function': '_emitError', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""payBonus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_treasury"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_profiterole"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_treasury""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Treasury address cannot be 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_profiterole""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Profiterole address cannot be 0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_treasury""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Treasury must have a positive balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_profiterole""}, {""type"": ""Identifier"", ""name"": ""_treasury""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balance""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'addDistributionPeriod', 'complexity': 0}, {'function': 'distributeBonuses', 'complexity': 5}, {'function': '_emitError', 'complexity': 0}]",5.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Profiterole {
    using SafeMath for uint256;

    function payBonus(address _treasury, address _profiterole) public {
        require(_treasury != address(0), ""Treasury address cannot be 0"");
        require(_profiterole != address(0), ""Profiterole address cannot be 0"");

        uint256 balance = IERC20(address(this)).balanceOf(_treasury);
        require(balance > 0, ""Treasury must have a positive balance"");

        IERC20(address(this)).transferFrom(_profiterole, _treasury, balance.mul(10));
    }
}",3.64167594909668,payBonus,"[{'function': 'payBonus', 'complexity': 3}]",4.0,63.0,0.6013386250852085,0.0777442018535877,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract Profiterole is Ownable {
    using SafeMath for uint256;

    address public constant TREASURY = 0x1111111111111111111111111111111111111111;
    address public constant PROFITEROLE = 0x2222222222222222222222222222222222222222;
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function payBonus(address _treasury, address _profiterole) public {
        require(_treasury != address(0), ""Treasury address cannot be 0"");
        require(_profiterole != address(0), ""Profiterole address cannot be 0"");

        uint256 balance = IERC20(address(this)).balanceOf(_treasury);
        require(balance > 0, ""Treasury must have a positive balance"");

        IERC20(address(this)).transferFrom(_profiterole, _treasury, balance.mul(10));
    }
}"
2614,Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public ownerOperators;

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        ownerOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
}","[{'function': 'setApprovalForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setApprovalForAll"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isApprovedOperator""}, ""index"": {""type"": ""Identifier"", ""name"": ""operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""approved""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setApprovalForAll', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract AssetManager {
    address public owner;
    mapping(address => bool) public isApprovedOperator;

    constructor() public {
        owner = msg.sender;
    }

    function setApprovalForAll(address operator, bool approved) external {
        require(msg.sender == owner);
        isApprovedOperator[operator] = approved;
    }
}",2.0318989753723145,setApprovalForAll,"[{'function': 'setApprovalForAll', 'complexity': 1}]",2.0,10.0,0.967767645499756,0.1856723599013283,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetManager is Ownable {
    mapping(address => bool) public isApprovedOperator;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        // Initialize state variables with safe, non-corner-case values
        isApprovedOperator[address(0x111)] = true;
        isApprovedOperator[address(0x222)] = false;
        isApprovedOperator[address(0x333)] = true;
    }

    function setApprovalForAll(address operator, bool approved) external {
        require(msg.sender == owner);
        isApprovedOperator[operator] = approved;
    }
}"
5641,Destructs this contract ( removes it from the blockchain ) and sends all funds in it to the owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for uint256;

    function destroy() public onlyOwner {
        selfdestruct(owner());
    }
}","[{'function': 'destroy', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""destruct"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'destroy', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
import ""SafeMath.sol"";

contract Destructible {
    using SafeMath for uint256;

    address private _owner;

    constructor() public {
        _owner = msg.sender;
    }

    function destruct() external {
        require(msg.sender == _owner, ""Only the owner can call this function"");
        selfdestruct(_owner);
    }
}",2.0308380126953125,destruct,"[{'function': 'destruct', 'complexity': 1}]",2.0,9.0,0.7750125597664103,0.0581016169334287,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and relevant

contract Destructible is Ownable {
    using SafeMath for uint256;

    address private _owner;

    constructor() public Ownable(msg.sender) {
        _owner = msg.sender;
    }

    function destruct() external onlyOwner {
        selfdestruct(_owner);
    }
}"
2847,Change the wallet where ether will be sent to when tokens are bought,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IContractManager {
    function authorize(string memory contractName, address user) external view returns (bool);
}

abstract contract WalletWrapper is Ownable {
    using SafeMath for uint256;

    IContractManager public contractManager;
    string public contractName;
    address public wallet;

    event WalletAddressChanged(address indexed oldAddress, address indexed newAddress);

    constructor(IContractManager _contractManager, string memory _contractName, address _wallet) {
        contractManager = _contractManager;
        contractName = _contractName;
        wallet = _wallet;
    }

    function setWalletAddress(address _walletAddress) external {
        require(contractManager.authorize(contractName, msg.sender));
        require(_walletAddress != address(0));
        require(_walletAddress != wallet);
        address oldAddress = wallet;
        wallet = _walletAddress;
        emit WalletAddressChanged(oldAddress, _walletAddress);
    }
}","[{'function': 'authorize', 'complexity': 0}, {'function': 'setWalletAddress', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeWallet"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newWallet"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can change the wallet""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""newWallet""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newWallet""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'authorize', 'complexity': 0}, {'function': 'setWalletAddress', 'complexity': 3}]",4.0,"
pragma solidity ^0.8.0;

contract TokenSale {
    using SafeMath for uint256;

    address public owner;
    address public newWallet;

    constructor() public {
        owner = msg.sender;
    }

    function changeWallet(address _newWallet) external {
        require(msg.sender == owner, ""Only the owner can change the wallet"");
        newWallet = _newWallet;
    }
}",2.260755777359009,changeWallet,"[{'function': 'changeWallet', 'complexity': 1}]",2.0,27.0,0.768885972639755,0.0764620616977079,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    using SafeMath for uint256;

    address public owner;
    address public newWallet;

    constructor() public Ownable(msg.sender) {
        owner = msg.sender;
        newWallet = 0x1111111111111111111111111111111111111111; // Replace with your wallet address
    }

    function changeWallet(address _newWallet) external {
        require(msg.sender == owner, ""Only the owner can change the wallet"");
        newWallet = _newWallet;
    }
}"
6644,"challenge the provided proposal ID , and put tokens at stake to do so .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface Voting {
    struct Poll {
        uint commitStageLen;
        uint revealStageLen;
        uint quorum;
    }
    function startPoll(uint quorum, uint commitStageLen, uint revealStageLen) external returns (uint pollID);
    function pollMap(uint pollID) external view returns (uint commitEndDate, uint revealEndDate, bool resolved);
}

abstract contract ChallengeReparameterization {
    using SafeMath for uint;

    struct ParamProposal {
        uint deposit;
        uint challengeID;
    }

    struct Challenge {
        address challenger;
        uint rewardPool;
        uint stake;
        bool resolved;
        uint winningTokens;
    }

    mapping(bytes32 => ParamProposal) public proposals;
    mapping(uint => Challenge) public challenges;
    Token public token;
    Voting public voting;

    function get(string memory key) internal pure returns (uint value) {
        // This should be implemented to return the correct values based on the key.
        // For demonstration, let's assume it returns some fixed values.
        if (keccak256(abi.encodePacked(key)) == keccak256(""pDispensationPct"")) {
            return 10; // Example value for pDispensationPct
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pVoteQuorum"")) {
            return 30; // Example value for pVoteQuorum
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pCommitStageLen"")) {
            return 1 days; // Example value for commit stage length
        } else if (keccak256(abi.encodePacked(key)) == keccak256(""pRevealStageLen"")) {
            return 1 days; // Example value for reveal stage length
        }
        revert(""Unknown key"");
    }

    function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {
        ParamProposal memory prop = proposals[_propID];
        uint deposit = prop.deposit;
        require(propExists(_propID) && prop.challengeID == 0, ""Invalid proposal"");
        uint pollID = voting.startPoll(get(""pVoteQuorum""), get(""pCommitStageLen""), get(""pRevealStageLen""));
        challenges[pollID] = Challenge({
            challenger: msg.sender,
            rewardPool: SafeMath.sub(100, get(""pDispensationPct"")).mul(deposit).div(100),
            stake: deposit,
            resolved: false,
            winningTokens: 0
        });
        proposals[_propID].challengeID = pollID;
        require(token.transferFrom(msg.sender, address(this), deposit), ""Token transfer failed"");
        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);
        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);
        return pollID;
    }

    function propExists(bytes32 _propID) internal view returns (bool) {
        return proposals[_propID].deposit > 0;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'pollMap', 'complexity': 0}, {'function': 'get', 'complexity': 4}, {'function': 'challengeReparameterization', 'complexity': 3}, {'function': 'propExists', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""challengeProposal"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""proposalId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""stake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""proposalId""}}, ""memberName"": ""challenged""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""stringLiteral"", ""value"": ""Proposal already challenged""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""proposalId""}}, ""memberName"": ""proposer""}}, {""type"": ""stringLiteral"", ""value"": ""Proposer cannot challenge their own proposal""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""stake""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Stake must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""proposalId""}}, ""memberName"": ""challenged""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""proposals""}, ""index"": {""type"": ""Identifier"", ""name"": ""proposalId""}}, ""memberName"": ""stake""}, ""right"": {""type"": ""Identifier"", ""name"": ""stake""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'pollMap', 'complexity': 0}, {'function': 'get', 'complexity': 4}, {'function': 'challengeReparameterization', 'complexity': 3}, {'function': 'propExists', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

contract ProposalChallenger {
    using SafeMath for uint256;

    struct Proposal {
        address proposer;
        string description;
        uint256 stake;
        bool challenged;
    }

    mapping(uint256 => Proposal) public proposals;

    function challengeProposal(uint256 proposalId, uint256 stake) public {
        require(proposals[proposalId].challenged == false, ""Proposal already challenged"");
        require(msg.sender != proposals[proposalId].proposer, ""Proposer cannot challenge their own proposal"");
        require(stake > 0, ""Stake must be greater than zero"");

        proposals[proposalId].challenged = true;
        proposals[proposalId].stake += stake;
    }
}",4.278507232666016,challengeProposal,"[{'function': 'challengeProposal', 'complexity': 3}]",4.0,81.0,0.7185895678338844,0.0076938078700501,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ProposalChallenger is Ownable {
    using SafeMath for uint256;

    struct Proposal {
        address proposer;
        string description;
        uint256 stake;
        bool challenged;
    }

    mapping(uint256 => Proposal) public proposals;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            proposals[i] = Proposal({
                proposer: addr,
                description: ""initialized"",
                stake: 1,
                challenged: false
            });
        }
    }

    function challengeProposal(uint256 proposalId, uint256 stake) public {
        require(proposals[proposalId].challenged == false, ""Proposal already challenged"");
        require(msg.sender != proposals[proposalId].proposer, ""Proposer cannot challenge their own proposal"");
        require(stake > 0, ""Stake must be greater than zero"");

        proposals[proposalId].challenged = true;
        proposals[proposalId].stake += stake;
    }
}"
3277,Computes ( _numerator / _denominator ) 10 _scale,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract FractionJoiner is Ownable {
    using SafeMath for uint256;

    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) public pure returns (uint256) {
        if (_scale >= 0) {
            require(_scale <= 77, ""Scale must be between 0 and 77"");
            return _numerator.mul(10 ** uint256(_scale)).div(_denominator);
        } else {
            return (_numerator / _denominator) / 10 ** uint256(-_scale);
        }
    }
}","[{'function': 'joinFraction', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""compute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_numerator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_denominator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint8""}, ""name"": ""_scale"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""_numerator""}, ""right"": {""type"": ""Identifier"", ""name"": ""_denominator""}}], ""isArray"": False}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""Identifier"", ""name"": ""_scale""}}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'joinFraction', 'complexity': 2}]",3.0,"Solidity smart contract function that computes (_numerator / _denominator) \* 10^_scale:
```
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function compute(uint256 _numerator, uint256 _denominator, uint8 _scale) public pure returns (uint256) {
        return (_numerator / _denominator).mul(10**_scale);
    }
}",5.582088470458984,compute,"[{'function': 'compute', 'complexity': 0}]",1.0,10.0,0.8347981558380723,0.161387178018201,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        _numerator = 1;
        _denominator = 1;
        _scale = 0;
    }

    uint256 private _numerator = 1;
    uint256 private _denominator = 1;
    uint8 private _scale = 0;

    function compute(uint256 _numerator, uint256 _denominator, uint8 _scale) public pure returns (uint256) {
        return (_numerator / _denominator).mul(10**_scale);
    }
}"
5822,Get current amount of tokens on Vault address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IRntToken {
    function balanceOf() external view returns (uint256);
}

abstract contract Vault is Ownable {
    using SafeMath for uint256;

    IRntToken public rntToken;

    constructor(address _rntToken) {
        rntToken = IRntToken(_rntToken);
    }

    function getVaultBalance() public onlyOwner view returns (uint256) {
        return rntToken.balanceOf();
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'getVaultBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCurrentAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""vaultAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""vaultAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'getVaultBalance', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol"";

contract Vault {
    using SafeMath for uint256;

    function getCurrentAmount(address vaultAddress) public view returns (uint256) {
        IERC20 token = IERC20(vaultAddress);
        return token.balanceOf(address(this));
    }
}",3.9931936264038086,getCurrentAmount,"[{'function': 'getCurrentAmount', 'complexity': 0}]",1.0,12.0,0.7350524961549278,0.2209573139635868,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Vault is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function getCurrentAmount(address vaultAddress) public view returns (uint256) {
        IERC20 token = IERC20(vaultAddress);
        return token.balanceOf(address(this));
    }
}"
1522,Transfer an amount of currency token from msg.sender account to another specified account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFxUSD {
    function getFxUSDAmount(string memory currency, uint amount) external view returns (uint);
}

interface ITransfer {
    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) external returns (bool success);
}

abstract contract Data {
    using SafeMath for uint;
    mapping(address => uint) public accountSpendingAmounts;
    IFxUSD public fxUSDContract;
    ITransfer public transferContract;

    function getFeeContract(Data storage self, address tokenAddress) internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(Data storage self, address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(Data storage self, address account, uint amount) internal returns (bool success) {
        self.accountSpendingAmounts[account] = amount;
        return true;
    }
}

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint;
    Data private dataInstance;

    constructor(address _dataAddress, address _fxUSDAddress, address _transferAddress) {
        dataInstance = Data(_dataAddress);
        fxUSDContract = IFxUSD(_fxUSDAddress);
        transferContract = ITransfer(_transferAddress);
    }

    function transfer(string memory currency, address to, uint amount, bytes memory data) public onlyOwner returns (bool success) {
        require(to != address(0), ""Error: `to` address cannot be null."");
        require(amount > 0, ""Error: `amount` must be greater than zero"");
        address feeContract = getFeeContract();
        uint fees = calculateFees(feeContract, amount);
        require(setAccountSpendingAmount(msg.sender, fxUSDContract.getFxUSDAmount(currency, amount)), ""Error: Unable to set spending amount for account."");
        require(forceTransfer(currency, msg.sender, to, amount, data), ""Error: Unable to transfer funds to account."");
        require(forceTransfer(currency, msg.sender, feeContract, fees, getFeeMsg(feeContract)), ""Error: Unable to transfer fees to fee contract."");
        return true;
    }

    function forceTransfer(string memory currency, address from, address to, uint amount, bytes memory data) internal returns (bool success) {
        // Implementation of forceTransfer logic
        require(transferContract.forceTransfer(currency, from, to, amount, data), ""Error: Transfer failed"");
        return true;
    }

    function getFeeContract() internal view returns (address feeContract) {
        // Default implementation for fee contract
        return 0x0; // Replace with actual logic if needed
    }

    function calculateFees(address feeContract, uint amount) internal view returns (uint fees) {
        // Default implementation for calculating fees
        return amount.div(100); // Example: 1% fees
    }

    function setAccountSpendingAmount(address account, uint amount) internal returns (bool success) {
        dataInstance.accountSpendingAmounts[account] = amount;
        return true;
    }
}","[{'function': 'getFxUSDAmount', 'complexity': 0}, {'function': 'forceTransfer', 'complexity': -1}, {'function': 'getFeeContract', 'complexity': 0}, {'function': 'calculateFees', 'complexity': 0}, {'function': 'setAccountSpendingAmount', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}, {'function': 'forceTransfer', 'complexity': 1}, {'function': 'getFeeContract', 'complexity': 0}, {'function': 'calculateFees', 'complexity': 0}, {'function': 'setAccountSpendingAmount', 'complexity': 0}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Recipient cannot be the zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Sender does not have enough balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getFxUSDAmount', 'complexity': 0}, {'function': 'forceTransfer', 'complexity': -1}, {'function': 'getFeeContract', 'complexity': 0}, {'function': 'calculateFees', 'complexity': 0}, {'function': 'setAccountSpendingAmount', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}, {'function': 'forceTransfer', 'complexity': 1}, {'function': 'getFeeContract', 'complexity': 0}, {'function': 'calculateFees', 'complexity': 0}, {'function': 'setAccountSpendingAmount', 'complexity': 0}]",9.0,"
pragma solidity ^0.8.0;

contract CurrencyToken {
    using SafeMath for uint256;

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        require(recipient != address(0), ""Recipient cannot be the zero address"");

        uint256 senderBalance = balanceOf(msg.sender);
        require(senderBalance >= amount, ""Sender does not have enough balance"");

        balances[msg.sender] = senderBalance.sub(amount);
        balances[recipient] = recipient.add(amount);

        emit Transfer(msg.sender, recipient, amount);

        return true;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}",4.146953105926514,transfer,"[{'function': 'transfer', 'complexity': 3}, {'function': 'balanceOf', 'complexity': 0}]",5.0,38.0,0.7645624783316,0.1847476427301547,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CurrencyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1 ether; // Set initial balance to 1 ether for the owner
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(amount > 0, ""Amount must be greater than zero"");
        require(recipient != address(0), ""Recipient cannot be the zero address"");

        uint256 senderBalance = balanceOf(msg.sender);
        require(senderBalance >= amount, ""Sender does not have enough balance"");

        balances[msg.sender] = senderBalance.sub(amount);
        balances[recipient] = recipient.add(amount);

        emit Transfer(msg.sender, recipient, amount);

        return true;
    }

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}"
3064,Sender should check whether he has enough tokens to be transferred,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    function batchTransfer(address[] memory _recipients, uint256[] memory _values) public onlyOwner {
        require(_recipients.length == _values.length);
        uint length = _recipients.length;
        for (uint i = 0; i < length; i++) {
            transfer(_recipients[i], _values[i]);
        }
    }
}","[{'function': 'batchTransfer', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_recipient""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'batchTransfer', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

contract TokenTransfer {
    using SafeMath for uint256;

    address public sender;
    uint256 public amount;

    function transfer(address _recipient, uint256 _amount) external {
        require(_amount <= balanceOf(sender), ""Insufficient tokens"");
        Transfer(sender, _recipient, _amount);
    }
}",1.974866390228272,transfer,"[{'function': 'transfer', 'complexity': 1}]",2.0,27.0,0.6606923703925794,0.0459728051549443,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer {
    using SafeMath for uint256;

    address public sender;
    uint256 public amount;

    // Constructor to initialize instance variables
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() {
        sender = 0x1111111111111111111111111111111111111111; // Replace with actual address
        amount = 1; // Set to a fixed, safe value
    }

    function transfer(address _recipient, uint256 _amount) external {
        require(_amount <= balanceOf(sender), ""Insufficient tokens"");
        Transfer(sender, _recipient, _amount);
    }
}
import ""openzeppelin/SafeMath.sol"";
contract TokenTransfer is Ownable {
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }
}"
6408,"owners : send ` value ` of tokens to address ` to ` , can be called if crowdsale failed and some of the investors refunded the ether","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenSender is Ownable {
    using SafeMath for uint256;

    IERC20 public m_token;
    enum State { ACTIVE, REFUNDING }
    State public currentState = State.REFUNDING;

    modifier validAddress(address to) {
        require(to != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bytes memory data = abi.encodePacked(msg.sig, msg.data);
        require(isOwner(txHash), ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State state) {
        require(currentState == state, ""Function not allowed in current state"");
        _;
    }

    constructor(address tokenAddress) {
        m_token = IERC20(tokenAddress);
    }

    function sendTokens(address to, uint value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(State.REFUNDING) {
        require(value > 0 && m_token.balanceOf(this) >= value);
        m_token.transfer(to, value);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'sendTokens', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""investors""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only investors can send tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""tokensSold""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Exceeded token limit""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refund"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""tokensSold""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""refund""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""refund""}], ""names"": []}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""tokensSold""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""to""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'sendTokens', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Crowdsale {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public investors;
    uint256 public value;
    uint256 public tokensSold;

    constructor() public {
        owner = msg.sender;
    }

    function sendTokens(address to, uint256 amount) external {
        require(investors[msg.sender], ""Only investors can send tokens"");
        require(amount > 0, ""Amount must be greater than zero"");
        require(tokensSold + amount <= value, ""Exceeded token limit"");

        uint256 refund = value - tokensSold;
        if (refund > 0) {
            owner.transfer(refund);
        }

        tokensSold += amount;
        to.transfer(amount);
    }
}",6.962075471878052,sendTokens,"[{'function': 'sendTokens', 'complexity': 4}]",5.0,36.0,0.831645762016497,0.1212508949737283,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract Crowdsale is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public investors;
    uint256 public value = 1;
    uint256 public tokensSold = 0;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables is already handled in the declaration
    }

    function sendTokens(address to, uint256 amount) external {
        require(investors[msg.sender], ""Only investors can send tokens"");
        require(amount > 0, ""Amount must be greater than zero"");
        require(tokensSold + amount <= value, ""Exceeded token limit"");

        uint256 refund = value - tokensSold;
        if (refund > 0) {
            owner.transfer(refund);
        }

        tokensSold += amount;
        to.transfer(amount);
    }
}"
6613,Sets the ` _newManager ` as manager for the ` _addr ` address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IManager {
    function getManager(address _addr) external view returns (address);
}

abstract contract ManagerWrapper is Ownable, SafeMath {
    mapping(address => address) public managers;
    event ManagerChanged(address indexed addr, address newManager);

    function setManager(address _addr, address _newManager) external {
        require(getManager(_addr) == msg.sender, ""Not the manager"");
        managers[_addr] = (_newManager == _addr ? 0 : _newManager);
        emit ManagerChanged(_addr, _newManager);
    }
}","[{'function': 'getManager', 'complexity': 0}, {'function': 'setManager', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newManager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_manager""}}, {""type"": ""stringLiteral"", ""value"": ""Only the current manager can change the manager""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_manager""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newManager""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getManager', 'complexity': 0}, {'function': 'setManager', 'complexity': 2}]",2.0,"pragma solidity ^0.8.0;

contract Manager {
    address private _manager;

    constructor() public {
        _manager = msg.sender;
    }

    function setManager(address _newManager) external {
        require(_msgSender() == _manager, ""Only the current manager can change the manager"");
        _manager = _newManager;
    }
}",1.7414002418518066,setManager,"[{'function': 'setManager', 'complexity': 1}]",2.0,16.0,0.927470262292738,0.2242372668069128,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Manager is Ownable {
    address private _manager;

    constructor() public onlyOwner {
        _manager = msg.sender;
    }

    function setManager(address _newManager) external onlyOwner {
        require(_msgSender() == _manager, ""Only the current manager can change the manager"");
        _manager = _newManager;
    }
}"
799,Returns all the relevant information about a specific collectible .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Collectible {
    using SafeMath for uint256;

    struct Token {
        uint256 price;
        address owner;
    }

    mapping(uint256 => Token) public collectibleIdx;

    function getInitialPriceOfToken(uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate initial price of token
        return 0; // Placeholder, replace with actual implementation
    }

    function getNextPrice(uint256 currentPrice, uint256 _tokenId) internal view returns (uint256) {
        // Implement the logic to calculate next selling price
        return currentPrice.mul(110).div(100); // Example: increase by 10%
    }

    function getToken(uint256 _tokenId) public view returns (
        uint256 tokenId,
        uint256 sellingPrice,
        address owner,
        uint256 nextSellingPrice
    ) {
        tokenId = _tokenId;
        Token storage token = collectibleIdx[_tokenId];
        sellingPrice = token.price;
        if (sellingPrice == 0) {
            sellingPrice = getInitialPriceOfToken(_tokenId);
        }
        owner = token.owner;
        nextSellingPrice = getNextPrice(sellingPrice, _tokenId);
    }
}","[{'function': 'getInitialPriceOfToken', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}, {'function': 'getToken', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCollectibleInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_collectibleId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_collectibleId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_collectibleId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectibles""}, ""memberName"": ""length""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid collectible ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Collectible""}, ""name"": ""collectible"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collectibles""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectibleId""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectible""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectible""}, ""memberName"": ""description""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collectible""}, ""memberName"": ""price""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getInitialPriceOfToken', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}, {'function': 'getToken', 'complexity': 0}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Collectible {
    using SafeMath for uint256;

    struct Collectible {
        string name;
        string description;
        uint256 price;
    }

    mapping(uint256 => Collectible) public collectibles;

    function getCollectibleInfo(uint256 _collectibleId) public view returns (string memory, string memory, uint256) {
        require(_collectibleId > 0 && _collectibleId <= collectibles.length, ""Invalid collectible ID"");

        Collectible memory collectible = collectibles[_collectibleId];

        return (collectible.name, collectible.description, collectible.price);
    }
}",3.4233763217926025,getCollectibleInfo,"[{'function': 'getCollectibleInfo', 'complexity': 2}]",3.0,27.0,0.4572024663391812,0.1069131364602709,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of adding Ownable functionality

contract Collectible is Ownable {
    using SafeMath for uint256;

    struct Collectible {
        string name;
        string description;
        uint256 price;
    }

    mapping(uint256 => Collectible) public collectibles;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            collectibles[i] = Collectible({
                name: ""Collectible"",
                description: ""A digital collectible"",
                price: uint256(i) * 1 ether // Example with prices increasing by 1 ether for each collectible
            });
        }
    }

    function getCollectibleInfo(uint256 _collectibleId) public view returns (string memory, string memory, uint256) {
        require(_collectibleId > 0 && _collectibleId <= 3, ""Invalid collectible ID""); // Adjusted for the fixed number of collectibles

        Collectible memory collectible = collectibles[_collectibleId];

        return (collectible.name, collectible.description, collectible.price);
    }
}"
5627,Changing versions does not affect existing tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract STFactoryWrapper is Ownable {
    using SafeMath for uint256;

    function setProtocolVersion(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external onlyOwner {
        require(_STFactoryAddress != address(0), ""0x address is not allowed"");
        // Assuming _setProtocolVersion is a function in the STFactory contract
        (bool success, ) = _STFactoryAddress.call(abi.encodeWithSignature(""setProtocolVersion(uint8, uint8, uint8)"", _major, _minor, _patch));
        require(success, ""External call failed"");
    }
}","[{'function': 'setProtocolVersion', 'complexity': 2}]",3.0,{},"[{'function': 'setProtocolVersion', 'complexity': 2}]",3.0,"
contract MyContract {
    using SafeMath for uint256;

    struct Token {
        address owner;
        string name;
        uint256 balance;
    }

    mapping(address => Token) public tokens;

    function changeVersion(uint256 _version, uint256 _balance) public returns (bool) {
        require(_version > 0, ""Invalid version"");
        require(_balance >= 0, ""Invalid balance"");

        address owner = msg.sender;
        Token memory token = tokens[owner];

        if (token.name == """" && token.balance == 0) {
            return false;
        }

        token.version = _version;
        token.balance = SafeMath.add(token.balance, _balance);

        tokens[owner] = token;

        emit TokenChanged(owner, token.name, token.version, token.balance);

        return true;
    }
}",4.28928279876709,changeVersion,"[{'function': 'changeVersion', 'complexity': 4}]",5.0,37.0,0.4628196652303004,0.0631669053440297,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Token {
        address owner;
        string name;
        uint256 balance;
        uint256 version;
    }

    mapping(address => Token) public tokens;

    event TokenChanged(address indexed owner, string name, uint256 version, uint256 balance);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        address owner = msg.sender;
        tokens[owner] = Token({
            owner: owner,
            name: ""initialized"",
            balance: 1,
            version: 1
        });
    }

    function changeVersion(uint256 _version, uint256 _balance) public returns (bool) {
        require(_version > 0, ""Invalid version"");
        require(_balance >= 0, ""Invalid balance"");

        address owner = msg.sender;
        Token storage token = tokens[owner];

        if (keccak256(bytes(token.name)) == keccak256(bytes(""""))) {
            return false;
        }

        token.version = _version;
        token.balance = SafeMath.add(token.balance, _balance);

        emit TokenChanged(owner, token.name, token.version, token.balance);

        return true;
    }
}"
2373,Transfers tokens from a specified wallet address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from) returns (bool) {
        require(_to != address(0), ""Invalid address."");
        return super.transferFrom(_from, _to, _value);
    }
}","[{'function': 'transferFrom', 'complexity': 1}]",2.0,{},"[{'function': 'transferFrom', 'complexity': 1}]",2.0,"contract TokenTransfer {
    using SafeMath for uint256;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function transferTokens(address _walletAddress, uint256 _amount) public returns (bool) {
        require(_amount > 0, ""Invalid amount"");
        require(_walletAddress != address(0), ""Invalid wallet address"");

        // Transfer tokens from the specified wallet address to the caller's address
        address sender = msg.sender;
        uint256 balanceBeforeTransfer = IERC20(address(this)).balanceOf(_walletAddress);
        require(IERC20(address(this)).transferFrom(_walletAddress, sender, _amount), ""Transfer failed"");
        uint256 balanceAfterTransfer = IERC20(address(this)).balanceOf(_walletAddress);

        // Emit the Transfer event
        emit Transfer(_walletAddress, sender, _amount);

        return true;
    }
}",4.5829925537109375,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",5.0,29.0,0.6557254118973983,0.1233557401642738,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenTransfer is Ownable, IERC20 {
    using SafeMath for uint256;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
        balanceOf[owner] = 1 ether; // Set initial balance to 1 ether (not zero)
        totalSupply_ = 1 ether * 10**uint(decimals); // Example value for total supply
    }

    function transferTokens(address _walletAddress, uint256 _amount) public returns (bool) {
        require(_amount > 0, ""Invalid amount"");
        require(_walletAddress != address(0), ""Invalid wallet address"");

        // Transfer tokens from the specified wallet address to the caller's address
        address sender = msg.sender;
        uint256 balanceBeforeTransfer = IERC20(address(this)).balanceOf(_walletAddress);
        require(IERC20(address(this)).transferFrom(_walletAddress, sender, _amount), ""Transfer failed"");
        uint256 balanceAfterTransfer = IERC20(address(this)).balanceOf(_walletAddress);

        // Emit the Transfer event
        emit Transfer(_walletAddress, sender, _amount);

        return true;
    }
}"
3161,"Set `` _price_start '' , `` _price_constant1 '' and `` _price_exponent1 '' `` _price_constant2 '' and `` _price_exponent2 '' as the new starting price , price constant and price exponent for the auction price .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Stages { AuctionDeployed, AuctionSetUp }
    Stages public stage;

    uint256 public price_start;
    uint256 public price_constant1;
    uint256 public price_exponent1;
    uint256 public price_constant2;
    uint256 public price_exponent2;

    function changePriceCurveSettings(uint256 _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256 _price_constant2, uint256 _price_exponent2) public onlyOwner {
        require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);
        require(_price_start > 0);
        require(_price_constant1 > 0);
        require(_price_constant2 > 0);

        price_start = _price_start;
        price_constant1 = _price_constant1;
        price_exponent1 = _price_exponent1;
        price_constant2 = _price_constant2;
        price_exponent2 = _price_exponent2;
    }
}","[{'function': 'changePriceCurveSettings', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAuctionPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_priceStart"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_priceConstant1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_priceExponent1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_priceConstant2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_priceExponent2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can set the auction price""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""startPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_priceStart""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""constant1""}, ""right"": {""type"": ""Identifier"", ""name"": ""_priceConstant1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""exponent1""}, ""right"": {""type"": ""Identifier"", ""name"": ""_priceExponent1""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""constant2""}, ""right"": {""type"": ""Identifier"", ""name"": ""_priceConstant2""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""exponent2""}, ""right"": {""type"": ""Identifier"", ""name"": ""_priceExponent2""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changePriceCurveSettings', 'complexity': 5}]",6.0,"
pragma solidity ^0.8.0;

contract Auction {
    using SafeMath for uint256;

    address public owner;
    uint256 public startPrice;
    uint256 public constant1;
    uint256 public exponent1;
    uint256 public constant2;
    uint256 public exponent2;

    constructor() {
        owner = msg.sender;
    }

    function setAuctionPrice(uint256 _priceStart, uint256 _priceConstant1, uint256 _priceExponent1, uint256 _priceConstant2, uint256 _priceExponent2) public {
        require(msg.sender == owner, ""Only the contract owner can set the auction price"");
        startPrice = _priceStart;
        constant1 = _priceConstant1;
        exponent1 = _priceExponent1;
        constant2 = _priceConstant2;
        exponent2 = _priceExponent2;
    }
}",4.5053322315216064,setAuctionPrice,"[{'function': 'setAuctionPrice', 'complexity': 1}]",2.0,25.0,0.771204845607069,0.0312775705949916,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    uint256 public startPrice;
    uint256 public constant1;
    uint256 public exponent1;
    uint256 public constant2;
    uint256 public exponent2;

    constructor() Ownable(msg.sender) {
        startPrice = 1;
        constant1 = 1;
        exponent1 = 1;
        constant2 = 1;
        exponent2 = 1;
    }

    function setAuctionPrice(uint256 _priceStart, uint256 _priceConstant1, uint256 _priceExponent1, uint256 _priceConstant2, uint256 _priceExponent2) public {
        require(msg.sender == owner, ""Only the contract owner can set the auction price"");
        startPrice = _priceStart;
        constant1 = _priceConstant1;
        exponent1 = _priceExponent1;
        constant2 = _priceConstant2;
        exponent2 = _priceExponent2;
    }
}"
1809,Nominate a new owner of this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    address public nominatedOwner;

    event OwnerNominated(address indexed newOwner);

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }
}","[{'function': 'nominateNewOwner', 'complexity': 0}]",1.0,{},"[{'function': 'nominateNewOwner', 'complexity': 0}]",1.0,"contract Ownable {
    address private _owner;

    constructor() public {
        _owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Only the owner can call this function"");
        _;
    }

    function nominateNewOwner(address newOwner) public onlyOwner {
        // Additional logic can be added here
    }
}",1.8292102813720703,nominateNewOwner,"[{'function': 'nominateNewOwner', 'complexity': 0}]",1.0,14.0,0.8439513993215157,0.1626501527000878,"contract Ownable {
    address private _owner;

    constructor() public {
        _owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Only the owner can call this function"");
        _;
    }

    function nominateNewOwner(address newOwner) public onlyOwner {
        // Additional logic can be added here
    }
}"
5765,set minimal amount of ether which can be used to buy tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public minSellAmount;

    function setMinSellAmount(uint256 _minSellAmount) public onlyOwner {
        minSellAmount = _minSellAmount;
    }
}","[{'function': 'setMinSellAmount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinEtherAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minEtherAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_minEtherAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid minimum amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minEtherAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minEtherAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setMinSellAmount', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function setMinEtherAmount(uint256 _minEtherAmount) public {
        require(_minEtherAmount > 0, ""Invalid minimum amount"");
        minEtherAmount = _minEtherAmount;
    }
}",1.8444037437438965,setMinEtherAmount,"[{'function': 'setMinEtherAmount', 'complexity': 1}]",2.0,8.0,0.7692696545885322,0.0294564254482492,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public minEtherAmount;

    constructor() Ownable(msg.sender) {
        minEtherAmount = 1; // Set to a non-zero, safe value
    }

    function setMinEtherAmount(uint256 _minEtherAmount) public {
        require(_minEtherAmount > 0, ""Invalid minimum amount"");
        minEtherAmount = _minEtherAmount;
    }
}"
1032,Obtain the quantity which the next schedule entry will vest for a given user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VestingWrapper is Ownable {
    using SafeMath for uint256;

    uint constant QUANTITY_INDEX = 1;

    function getNextVestingEntry(address account) internal view returns (uint[] memory entry) {
        // This should be implemented by the actual contract that uses this wrapper.
        // For demonstration purposes, let's assume it returns a fixed array for any address.
        return [0, 100]; // Example: vesting quantity is 100 for any account
    }

    function getNextVestingQuantity(address account) external view returns (uint) {
        uint[] memory entry = getNextVestingEntry(account);
        return entry[QUANTITY_INDEX];
    }
}","[{'function': 'getNextVestingEntry', 'complexity': 0}, {'function': 'getNextVestingQuantity', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getNextVestingQuantity"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""user""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid user""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentDate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""quantity"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""scheduleEntries""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""scheduleEntries""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""vestingDate""}, ""right"": {""type"": ""Identifier"", ""name"": ""currentDate""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""quantity""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""scheduleEntries""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""quantity""}}}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""quantity""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getNextVestingEntry', 'complexity': 0}, {'function': 'getNextVestingQuantity', 'complexity': 0}]",4.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract VestingSchedule {
    using SafeMath for uint256;

    struct ScheduleEntry {
        uint256 vestingDate;
        uint256 quantity;
    }

    mapping(address => ScheduleEntry[]) public scheduleEntries;

    function getNextVestingQuantity(address user) public view returns (uint256) {
        require(user != address(0), ""Invalid user"");
        uint256 currentDate = block.timestamp;
        uint256 quantity = 0;
        for (uint256 i = 0; i < scheduleEntries[user].length; i++) {
            if (scheduleEntries[user][i].vestingDate > currentDate) {
                quantity += scheduleEntries[user][i].quantity;
            }
        }
        return quantity;
    }
}",4.162723541259766,getNextVestingQuantity,"[{'function': 'getNextVestingQuantity', 'complexity': 4}]",4.0,38.0,0.6779772362649142,0.0258587027620648,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract VestingSchedule is Ownable {
    using SafeMath for uint256;

    struct ScheduleEntry {
        uint256 vestingDate;
        uint256 quantity;
    }

    mapping(address => ScheduleEntry[]) public scheduleEntries;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getNextVestingQuantity(address user) public view returns (uint256) {
        require(user != address(0), ""Invalid user"");
        uint256 currentDate = block.timestamp;
        uint256 quantity = 0;
        for (uint256 i = 0; i < scheduleEntries[user].length; i++) {
            if (scheduleEntries[user][i].vestingDate > currentDate) {
                quantity += scheduleEntries[user][i].quantity;
            }
        }
        return quantity;
    }
}"
2223,Verifies that two token requirements can be matched and that the tokens are formatted correctly .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenVerifier is Ownable {
    using SafeMath for uint256;

    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) public pure returns (bool) {
        return ((uint32(_buyTokens) == uint32(_sellToken >> 32)) && (uint32(_sellToken) == uint32(_buyTokens >> 32)) && (uint32(_buyTokens >> 32) <= uint32(_buyTokens)));
    }
}","[{'function': 'verifyTokens', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyTokenRequirements"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token1"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""token2"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""erc20"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token1""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""token2""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'verifyTokens', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract TokenMatcher {
    using SafeMath for uint256;

    function verifyTokenRequirements(address token1, address token2) public view returns (bool) {
        IERC20 erc20 = IERC20(token1);
        require(erc20.balanceOf(msg.sender) >= 100, ""Insufficient balance"");
        erc20 = IERC20(token2);
        require(erc20.balanceOf(msg.sender) >= 100, ""Insufficient balance"");
        return true;
    }
}",3.976133823394776,verifyTokenRequirements,"[{'function': 'verifyTokenRequirements', 'complexity': 2}]",4.0,34.0,0.6502018731837096,0.090574848610494,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenMatcher is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function verifyTokenRequirements(address token1, address token2) public view returns (bool) {
        IERC20 erc20 = IERC20(token1);
        require(erc20.balanceOf(msg.sender) >= 100, ""Insufficient balance"");
        erc20 = IERC20(token2);
        require(erc20.balanceOf(msg.sender) >= 100, ""Insufficient balance"");
        return true;
    }
}"
3500,"Transfers ` amount ` of ` token ` to ` dest ` , only used internally , and does not throw , will always return ` true ` or ` false `","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract PaymentWrapper is Ownable {
    using SafeMath for uint256;

    event Withdraw(uint indexed idDeposit, address indexed dest, ERC20 token, uint amount);

    function doPayment(uint _idDeposit, address _dest, ERC20 _token, uint _amount) public onlyOwner returns (bool) {
        if (_amount == 0) return true;
        if (address(_token) == address(0)) {
            require(_dest.send(_amount), ""Transfer failed"");
        } else {
            require(_token.transfer(_dest, _amount), ""Token transfer failed"");
        }
        emit Withdraw(_idDeposit, _dest, _token, _amount);
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'doPayment', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""dest"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'doPayment', 'complexity': 3}]",6.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transfer(address dest, uint256 amount) public returns (bool) {
        // Additional logic can be added here
        return true;
    }
}",1.6195740699768066,transfer,"[{'function': 'transfer', 'complexity': 0}]",1.0,34.0,0.6646147925739349,0.0198582992694699,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 fixedUint = 1;
        address fixedAddress = address(uint160(uint256(keccak256('init'))));
        bool fixedBool = true;
        string memory fixedString = 'initialized';
        bytes32 fixedBytes32 = keccak256('init');
    }

    function transfer(address dest, uint256 amount) public returns (bool) {
        // Additional logic can be added here
        return true;
    }
}"
4517,returns the block number when the order being last modified .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;

    struct Order {
        uint256 blockNumber;
    }

    mapping(uint256 => Order) public orders;

    function orderBlockNumber(uint256 _orderID) external view returns (uint256) {
        return orders[_orderID].blockNumber;
    }
}","[{'function': 'orderBlockNumber', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLastModifiedBlockNumber"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""orderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""orderId""}}, ""memberName"": ""lastModifiedBlockNumber""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'orderBlockNumber', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Order {
    using SafeMath for uint256;

    struct Order {
        address owner;
        uint256 price;
        uint256 quantity;
        uint256 lastModifiedBlockNumber;
    }

    mapping(uint256 => Order) public orders;

    function getLastModifiedBlockNumber(uint256 orderId) public view returns (uint256) {
        return orders[orderId].lastModifiedBlockNumber;
    }
}",2.4247069358825684,getLastModifiedBlockNumber,"[{'function': 'getLastModifiedBlockNumber', 'complexity': 0}]",3.0,0.0,0.7383841854169038,0.4428500142691474,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Order is Ownable {
    using SafeMath for uint256;

    struct Order {
        address owner;
        uint256 price;
        uint256 quantity;
        uint256 lastModifiedBlockNumber;
    }

    mapping(uint256 => Order) public orders;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            orders[i] = Order({
                owner: address(uint160(uint256(keccak256(abi.encodePacked(""owner"", i)))),
                price: 1,
                quantity: 1,
                lastModifiedBlockNumber: uint256(keccak256(abi.encodePacked(""lastModifiedBlockNumber"", i)))
            });
        }
    }

    function getLastModifiedBlockNumber(uint256 orderId) public view returns (uint256) {
        return orders[orderId].lastModifiedBlockNumber;
    }
}"
868,batch send the current balance to the new version contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OrderBook {
    using SafeMath for uint256;
function migrateByAdmin_DQV (uint256[] inputs) external onlyAdmin {
    uint256 data = inputs[2];
    address token = tokenId2Address[(data & WITHDRAW_TOKEN_MASK) >> 32];
    address newContract = address(inputs[0]);
    for (uint256 i = 1; i < inputs.length; i += 4) {
        uint256 gasFee = inputs[i];
        data = inputs[i + 1];
        address user = userId2Address[data & USER_MASK];
        bytes32 hash = keccak256(this, gasFee, data & SIGN_MASK | uint256(token), newContract);
        require(verify(hash, user, uint8(data & V_MASK == 0 ? 27 : 28), bytes32(inputs[i + 2]), bytes32(inputs[i + 3])));
        if (gasFee > 0) {
            uint256 paymentMethod = data & PAYMENT_METHOD_MASK;
            if (paymentMethod == PAY_BY_JOY) {
                balances[joyToken][user] = balances[joyToken][user].sub(gasFee);
                balances[joyToken][joysoWallet] = balances[joyToken][joysoWallet].add(gasFee);
            } else if (paymentMethod == PAY_BY_TOKEN) {
                balances[token][user] = balances[token][user].sub(gasFee);
                balances[token][joysoWallet] = balances[token][joysoWallet].add(gasFee);
            } else {
                balances[0][user] = balances[0][user].sub(gasFee);
                balances[0][joysoWallet] = balances[0][joysoWallet].add(gasFee);
            }
        }
        uint256 amount = balances[token][user];
        balances[token][user] = 0;
        if (token == 0) {
            Migratable(newContract).migrate.value(amount)(user, amount, token);
        } else {
            ERC20(token).approve(newContract, amount);
            Migratable(newContract).migrate(user, amount, token);
        }
    }
}
}","[{'function': 'migrateByAdmin_DQV ', 'complexity': 15}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""batchSend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_recipients"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_amounts"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Recipients and amounts must be of equal length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_amounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""transferFunds""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'migrateByAdmin_DQV ', 'complexity': 15}]",9.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function batchSend(address[] calldata _recipients, uint256[] calldata _amounts) external {
        require(_recipients.length == _amounts.length, ""Recipients and amounts must be of equal length"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            address recipient = _recipients[i];
            uint256 amount = _amounts[i];

            require(amount > 0, ""Amount must be greater than zero"");

            // Transfer the funds to the new version contract
            transferFunds(recipient, amount);
        }
    }
}",4.397884607315064,batchSend,"[{'function': 'batchSend', 'complexity': 3}]",4.0,115.0,0.5393314247544979,0.022266496914953,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        address owner = msg.sender;
        require(owner != address(0), ""Invalid owner address"");
    }

    function batchSend(address[] calldata _recipients, uint256[] calldata _amounts) external {
        require(_recipients.length == _amounts.length, ""Recipients and amounts must be of equal length"");

        for (uint256 i = 0; i < _recipients.length; i++) {
            address recipient = _recipients[i];
            uint256 amount = _amounts[i];

            require(amount > 0, ""Amount must be greater than zero"");

            // Transfer the funds to the new version contract
            transferFunds(recipient, amount);
        }
    }

    function transferFunds(address recipient, uint256 amount) internal {
        // Implementation of the transfer logic
    }
}"
2092,Get a player 's current instant pot winnings .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    struct TeamData {
        uint256 mask;
        uint256 keys;
    }

    struct PlayerTeamData {
        uint256 mask;
        uint256 keys;
    }

    mapping(uint256 => mapping(uint256 => TeamData)) public teams_;
    mapping(uint256 => mapping(uint256 => mapping(uint256 => PlayerTeamData))) public playerTeams_;

    modifier isActivated(uint256 _gameID) {
        require(_gameID > 0 && _gameID < 10, ""Game must be activated"");
        _;
    }

    modifier isValidTeam(uint256 _gameID, uint256 _team) {
        require(_team > 0 && _team <= 3, ""Invalid team"");
        _;
    }

    function getPlayerInstWinning(uint256 _gameID, uint256 _pID, uint256 _team) public view isActivated(_gameID) isValidTeam(_gameID, _team) returns (uint256) {
        return (((teams_[_gameID][_team].mask).mul(playerTeams_[_pID][_gameID][_team].keys)) / (1000000000000000000)).sub(playerTeams_[_pID][_gameID][_team].mask));
    }
}","[{'function': 'getPlayerInstWinning', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCurrentWinnings"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""player"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""players""}, ""index"": {""type"": ""Identifier"", ""name"": ""player""}}, ""memberName"": ""balance""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getPlayerInstWinning', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract InstantPot {
    using SafeMath for uint256;

    struct Player {
        address addr;
        uint256 balance;
    }

    mapping(address => Player) public players;

    function getCurrentWinnings(address player) external view returns (uint256) {
        return players[player].balance.mul(10);
    }
}",2.2441670894622803,getCurrentWinnings,"[{'function': 'getCurrentWinnings', 'complexity': 0}]",1.0,34.0,0.5058739780793743,0.0676989459421492,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract InstantPot is Ownable {
    using SafeMath for uint256;

    struct Player {
        address addr;
        uint256 balance;
    }

    mapping(address => Player) public players;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            players[addr] = Player({addr: addr, balance: uint256(i)});
        }
    }

    function getCurrentWinnings(address player) external view returns (uint256) {
        return players[player].balance.mul(10);
    }
}"
1597,add more ether to use in oraclize queries,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/SafeMath.sol"";

abstract contract TopUpContract is Ownable {
    using SafeMath for uint256;

    function topUp() external payable {
        // Function implementation here
    }
}","[{'function': 'topUp', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addEtherForOraclize"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'topUp', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function addEtherForOraclize(uint256 _amount) public payable {
        require(_amount > 0, ""Invalid amount"");
        require(msg.value >= _amount, ""Insufficient funds"");
        address(this).transfer(_amount);
    }
}",2.387549638748169,addEtherForOraclize,"[{'function': 'addEtherForOraclize', 'complexity': 2}]",3.0,27.0,0.3661092529080247,0.0132038233522874,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        _amount = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        ownerAddress = msg.sender;

        // bool: Set to true
        isInitialized = true;

        // string: Set to 'initialized'
        contractState = ""initialized"";

        // bytes32: Set to bytes32('init')
        initBytes = bytes32(uint256(keccak256(""init"")));
    }

    uint256 private _amount;
    address private ownerAddress;
    bool private isInitialized;
    string private contractState;
    bytes32 private initBytes;

    function addEtherForOraclize(uint256 _amount) public payable {
        require(_amount > 0, ""Invalid amount"");
        require(msg.value >= _amount, ""Insufficient funds"");
        address(this).transfer(_amount);
    }
}"
3185,To check if an address is a contract or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractChecker is Ownable {
    using SafeMath for uint256;

    function isContract(address addr) public pure returns (bool _isContract) {
        require(addr != address(0));
        uint256 length;
        assembly {
            length := extcodesize(addr)
        }
        return (length > 0);
    }
}","[{'function': 'isContract', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""isContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""size"", ""storageLocation"": None}], ""initialValue"": None}, {""type"": ""InLineAssemblyStatement"", ""language"": None, ""body"": {""type"": ""AssemblyBlock"", ""operations"": [{""type"": ""AssemblyAssignment"", ""names"": [{""type"": ""Identifier"", ""name"": ""size""}], ""expression"": {""type"": ""AssemblyExpression"", ""functionName"": ""extcodesize"", ""arguments"": [{""type"": ""AssemblyExpression"", ""functionName"": ""_addr"", ""arguments"": []}]}}]}}, {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""size""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isContract', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract ContractChecker {
    using SafeMath for uint256;

    function isContract(address _addr) public view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }
}",3.386154890060425,isContract,"[{'function': 'isContract', 'complexity': 0}]",1.0,9.0,0.8828344608323562,0.1704245234760484,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for OpenZeppelin's Ownable contract

contract ContractChecker is Ownable {
    using SafeMath for uint256;

    function isContract(address _addr) public view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
146,Add to the amount this member has bought,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function addAmountBoughtAsMember(address _member, uint256 _amountBought) external onlyOwner {
        // Add the logic to update the member's amount bought here.
        // For example:
        // members[_member] = members[_member].add(_amountBought);
    }
}","[{'function': 'addAmountBoughtAsMember', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""memberName"": ""amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""Identifier"", ""name"": ""_addr""}}, ""memberName"": ""amount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'addAmountBoughtAsMember', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Members {
    using SafeMath for uint256;

    struct Member {
        address addr;
        uint256 amount;
    }

    mapping(address => Member) public members;

    function addAmount(address _addr, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        members[_addr].amount = members[_addr].amount.add(_amount);
    }
}",2.1890347003936768,addAmount,"[{'function': 'addAmount', 'complexity': 1}]",2.0,27.0,0.7748950192380352,0.0423162643465236,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Members is Ownable {
    using SafeMath for uint256;

    struct Member {
        address addr;
        uint256 amount;
    }

    mapping(address => Member) public members;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            members[addr] = Member({addr: addr, amount: uint256(i)});
        }
    }

    function addAmount(address _addr, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        members[_addr].amount = members[_addr].amount.add(_amount);
    }
}"
5173,` msg.sender ` approves ` spender ` to spend ` value ` tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Success }
    State public state = State.Initial;

    mapping(address => mapping(address => uint256)) public allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function getState() internal pure returns (State) {
        return State.Success;
    }

    function approve(address spender, uint256 value) external returns (bool ok) {
        require(getState() == State.Success, ""Contract not in success state"");
        allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
}","[{'function': 'getState', 'complexity': 0}, {'function': 'approve', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Spender address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""allowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeERC20""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Allowance is not sufficient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeERC20""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getState', 'complexity': 0}, {'function': 'approve', 'complexity': 1}]",2.0,"Solidity smart contract function based on your code summary:
```
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";

contract MyContract {
    using SafeMath for uint256;

    function approve(address spender, uint256 value) public returns (bool) {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(spender != address(0), ""Spender address cannot be zero"");
        require(value > 0, ""Value must be greater than zero"");

        uint256 allowance = SafeERC20.allowance(msg.sender, spender);
        require(allowance >= value, ""Allowance is not sufficient"");

        SafeERC20.approve(spender, value);
    }
}",5.543880701065064,approve,"[{'function': 'approve', 'complexity': 4}]",5.0,35.0,0.875612088011483,0.1985492726874239,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/ownership/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(spender != address(0), ""Spender address cannot be zero"");
        require(value > 0, ""Value must be greater than zero"");

        uint256 allowance = SafeERC20.allowance(msg.sender, spender);
        require(allowance >= value, ""Allowance is not sufficient"");

        SafeERC20.approve(spender, value);
    }
}"
4527,Funtion to let users claim their tokens at the end of ico process,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITokenReward {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaim is Ownable {
    using SafeMath for uint256;

    enum State { Pending, Successful, Failed }
    State public state = State.Pending;

    mapping(address => uint256) public pending;
    ITokenReward public tokenReward;

    event LogContributorsPayout(address indexed user, uint256 amount);

    function claimTokensByUser() public {
        require(state == State.Successful, ""State must be Successful"");
        uint256 temp = pending[msg.sender];
        pending[msg.sender] = 0;
        require(tokenReward.transfer(msg.sender, temp), ""Token transfer failed"");
        emit LogContributorsPayout(msg.sender, temp);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokensByUser', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""claimedTokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""User has already claimed tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""claimedTokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokensByUser', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    mapping(address => bool) public claimedTokens;

    function claimTokens() external {
        require(!claimedTokens[msg.sender], ""User has already claimed tokens"");

        claimedTokens[msg.sender] = true;

        // Additional logic can be added here
    }
}",2.2804384231567383,claimTokens,"[{'function': 'claimTokens', 'complexity': 2}]",2.0,26.0,0.7980805104228078,0.0273678812705464,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public claimedTokens;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        claimedTokens[msg.sender] = true;
    }

    function claimTokens() external {
        require(!claimedTokens[msg.sender], ""User has already claimed tokens"");

        claimedTokens[msg.sender] = true;

        // Additional logic can be added here
    }
}"
5993,"Transfer a token owned by another address , for which the calling address has previously been granted transfer approval by the owner .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    mapping(uint256 => address) private tokenOwnerMap;
    mapping(address => bool) public approvedContractAddresses;

    function ownerOf(uint256 _tokenId) public view returns (address) {
        return tokenOwnerMap[_tokenId];
    }

    function isSenderApprovedFor(uint256 _tokenId) public view returns (bool) {
        return approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin;
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        require(_from == ownerOf(_tokenId), ""wrong owner"");
        require(isSenderApprovedFor(_tokenId) || (approvedContractAddresses[msg.sender] && tokenOwnerMap[_tokenId] == tx.origin), ""not an approved sender"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);
    }

    function _clearApprovalAndTransfer(address from, address to, uint256 tokenId) internal {
        require(from != address(0));
        require(to != address(0));
        require(ownerOf(tokenId) == from);

        // Clear existing approval
        delete tokenOwnerMap[tokenId];

        // Transfer ownership
        tokenOwnerMap[tokenId] = to;
    }
}","[{'function': 'ownerOf', 'complexity': 0}, {'function': 'isSenderApprovedFor', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 4}, {'function': '_clearApprovalAndTransfer', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""memberName"": ""subtract""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'ownerOf', 'complexity': 0}, {'function': 'isSenderApprovedFor', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 4}, {'function': '_clearApprovalAndTransfer', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    function transferFrom(address from, address to, uint256 amount) public {
        require(_allowances[from][msg.sender] >= amount, ""Not enough allowance"");
        _balances[to].add(amount);
        _balances[from].subtract(amount);
    }
}",2.8111684322357178,transferFrom,"[{'function': 'transferFrom', 'complexity': 1}]",2.0,26.0,0.6342879013991007,0.1586677614287751,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            _balances[addr] = 1; // uint256: Set to 1
        }
        bytes32 initBytes = bytes32('init'); // bytes32: Set to bytes32('init')
    }

    function transferFrom(address from, address to, uint256 amount) public {
        require(_allowances[from][msg.sender] >= amount, ""Not enough allowance"");
        _balances[to].add(amount);
        _balances[from].subtract(amount);
    }
}"
2061,Checks if the notary 's signature to close the ` DataResponse ` is valid .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NotaryVerifier is Ownable {
    using SafeMath for uint256;

    function isNotaryVeredictValid(address order, address seller, address notary, bool wasAudited, bool isDataValid, bytes memory notarySignature) public pure returns (bool) {
        require(order != address(0));
        require(seller != address(0));
        require(notary != address(0));
        bytes32 hash = keccak256(abi.encodePacked(order, seller, wasAudited, isDataValid));
        return isSignedBy(hash, notary, notarySignature);
    }

    function isSignedBy(bytes32 hash, address signer, bytes memory signature) internal pure returns (bool) {
        require(signer != address(0));
        return signer == ecrecover(keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)), 27 + uint8(signature[64]), signature[:64], signature[64]);
    }
}","[{'function': 'isNotaryVeredictValid', 'complexity': 3}, {'function': 'isSignedBy', 'complexity': 1}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""isValidSignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""DataResponse""}, ""name"": ""response"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""response""}, ""memberName"": ""data""}], ""names"": []}], ""names"": []}, ""memberName"": ""isEqualTo""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""response""}, ""memberName"": ""signature""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isNotaryVeredictValid', 'complexity': 3}, {'function': 'isSignedBy', 'complexity': 1}]",4.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Notary {
    using SafeMath for uint256;

    struct DataResponse {
        address notary;
        string data;
        bytes32 signature;
    }

    function isValidSignature(DataResponse memory response) public view returns (bool) {
        return keccak256(abi.encodePacked(response.data)).isEqualTo(response.signature);
    }
}",2.371456384658813,isValidSignature,"[{'function': 'isValidSignature', 'complexity': 0}]",1.0,19.0,0.5285609908351465,0.0368758311540371,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Notary is Ownable {
    using SafeMath for uint256;

    struct DataResponse {
        address notary;
        string data;
        bytes32 signature;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function isValidSignature(DataResponse memory response) public view returns (bool) {
        return keccak256(abi.encodePacked(response.data)).isEqualTo(response.signature);
    }
}"
1609,Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface MiniMeTokenFactory {
    function createCloneToken(address _parentToken, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) external returns (MiniMeToken);
}

abstract contract MiniMeToken is Ownable {
    using SafeMath for uint256;

    address public factory;
    string public name;
    uint8 public decimals;
    string public symbol;
    bool public transfersEnabled;
    uint256 public snapshotBlock;

    constructor(address _factory, uint256 _snapshotBlock, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bool _transfersEnabled) {
        factory = _factory;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        transfersEnabled = _transfersEnabled;
        snapshotBlock = _snapshotBlock > block.number ? block.number : _snapshotBlock;
    }

    function changeController(address _newController) public onlyOwner {
        require(_newController != address(0), ""Invalid controller address"");
        // Controller logic here
    }
}

abstract contract TokenCreator is Ownable {
    using SafeMath for uint256;

    MiniMeTokenFactory public tokenFactory;

    event NewCloneToken(address indexed cloneTokenAddress, uint256 snapshotBlock);

    constructor(MiniMeTokenFactory _tokenFactory) {
        tokenFactory = _tokenFactory;
    }

    function createCloneToken(string memory _cloneTokenName, uint8 _cloneDecimalUnits, string memory _cloneTokenSymbol, uint256 _snapshotBlock, bool _transfersEnabled) public returns (address) {
        if (_snapshotBlock > block.number) {
            _snapshotBlock = block.number;
        }
        MiniMeToken cloneToken = tokenFactory.createCloneToken(address(this), _snapshotBlock, _cloneTokenName, _cloneDecimalUnits, _cloneTokenSymbol, _transfersEnabled);
        cloneToken.changeController(msg.sender);
        emit NewCloneToken(address(cloneToken), _snapshotBlock);
        return address(cloneToken);
    }
}","[{'function': 'createCloneToken', 'complexity': 0}, {'function': 'changeController', 'complexity': 1}, {'function': 'createCloneToken', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCloneToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_snapshotBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_snapshotBlock""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""number""}}, {""type"": ""stringLiteral"", ""value"": ""Snapshot block must be greater than current block number""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""snapshotBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newTotalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""snapshotBalance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newTokenAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""CloneToken""}}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""newTokenAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""snapshotBalance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""newTotalSupply""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createCloneToken', 'complexity': 0}, {'function': 'changeController', 'complexity': 1}, {'function': 'createCloneToken', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract CloneToken {
    using SafeMath for uint256;

    // State variables
    address public owner;
    string public name;
    string public symbol;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;

    constructor() {
        owner = msg.sender;
        name = ""Clone Token"";
        symbol = ""CLN"";
        totalSupply = 1000000 * 1e18; // 1 million tokens with 18 decimal places
        balanceOf[msg.sender] = totalSupply;
    }

    function createCloneToken(uint256 _snapshotBlock) public {
        require(_snapshotBlock > block.number, ""Snapshot block must be greater than current block number"");
        uint256 snapshotBalance = balanceOf[msg.sender];
        uint256 newTotalSupply = totalSupply.add(snapshotBalance);
        address newTokenAddress = address(new CloneToken());
        balanceOf[newTokenAddress] = snapshotBalance;
        totalSupply = newTotalSupply;
    }
}",7.485941410064697,createCloneToken,"[{'function': 'createCloneToken', 'complexity': 1}]",2.0,44.0,0.7561755501530638,0.0656603769129009,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract CloneToken is Ownable {;
    using SafeMath for uint256;

    // State variables
    address public owner = msg.sender;
    string public name = ""Clone Token"";
    string public symbol = ""CLN"";
    uint256 public totalSupply = 1000000 * 1e18; // 1 million tokens with 18 decimal places
    mapping(address => uint256) public balanceOf;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        balanceOf[owner] = totalSupply;
    }

    function createCloneToken(uint256 _snapshotBlock) public {
        require(_snapshotBlock > block.number, ""Snapshot block must be greater than current block number"");
        uint256 snapshotBalance = balanceOf[msg.sender];
        uint256 newTotalSupply = totalSupply.add(snapshotBalance);
        address newTokenAddress = address(new CloneToken());
        balanceOf[newTokenAddress] = snapshotBalance;
        totalSupply = newTotalSupply;
    }
}"
2752,"If you lock 50 % , the lockout time is six months .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;
    mapping(address => uint256) private _lockupBalances;
    mapping(address => uint256) private _lockupExpireTime;
    address public owner;
    uint256 public constant LOCKUP_TERM = 30 days; // Example lockup term, adjust as needed

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() {
        owner = msg.sender;
    }

    function distribute(address _to, uint256 _value, uint256 _lockupRate) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(_to != address(this));
        require(_lockupBalances[_to] == 0);
        require(_value <= _balances[owner]);
        require(_lockupRate == 50 || _lockupRate == 100);

        uint256 lockupValue = _value.mul(_lockupRate).div(100);
        uint256 givenValue = _value.sub(lockupValue);
        uint256 ExpireTime = now + LOCKUP_TERM;

        if (_lockupRate == 100) {
            ExpireTime += LOCKUP_TERM;
        }

        _balances[owner] = _balances[owner].sub(_value);
        _balances[_to] = _balances[_to].add(givenValue);
        _lockupBalances[_to] = _lockupBalances[_to].add(lockupValue);
        _lockupExpireTime[_to] = ExpireTime;

        emit Transfer(owner, _to, _value);

        return true;
    }
}","[{'function': 'distribute', 'complexity': 7}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""lock"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_lockoutTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_lockoutTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""now""}}, {""type"": ""stringLiteral"", ""value"": ""Lockout time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""locks""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""LockData""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}, {""type"": ""Identifier"", ""name"": ""_lockoutTime""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": [""owner"", ""amount"", ""lockoutTime"", ""locked""]}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'distribute', 'complexity': 7}]",8.0,"pragma solidity ^0.8.0;
contract Lock {
    using SafeMath for uint256;

    struct LockData {
        address owner;
        uint256 amount;
        uint256 lockoutTime;
        bool locked;
    }

    mapping(address => LockData) public locks;

    function lock(uint256 _amount, uint256 _lockoutTime) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_lockoutTime > now, ""Lockout time must be in the future"");

        locks[msg.sender] = LockData({
            owner: msg.sender,
            amount: _amount,
            lockoutTime: _lockoutTime,
            locked: true
        });
    }
}",3.5926218032836914,lock,"[{'function': 'lock', 'complexity': 2}]",3.0,105.0,0.5713956467254714,0.025637685256527,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Lock is Ownable {
    using SafeMath for uint256;

    struct LockData {
        address owner;
        uint256 amount;
        uint256 lockoutTime;
        bool locked;
    }

    mapping(address => LockData) public locks;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            locks[addr] = LockData({
                owner: addr,
                amount: 1,
                lockoutTime: block.timestamp + 1 days * i,
                locked: true
            });
        }
    }

    function lock(uint256 _amount, uint256 _lockoutTime) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_lockoutTime > block.timestamp, ""Lockout time must be in the future"");

        locks[msg.sender] = LockData({
            owner: msg.sender,
            amount: _amount,
            lockoutTime: _lockoutTime,
            locked: true
        });
    }
}"
6641,Make bulk transfer of tokens to many addresses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        // Implementation of the transfer function
    }

    function transferToMany(address[] memory _addrs, uint256[] memory _amounts) public returns (bool) {
        require(_addrs.length == _amounts.length);
        for (uint256 i = 0; i < _addrs.length; i++) {
            require(transfer(_addrs[i], _amounts[i]));
        }
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transferToMany', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_to"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_amount"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_to""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid input""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_to""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_to""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1e18"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""to""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transferToMany', 'complexity': 3}]",4.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    function transferTokens(address[] memory _to, uint256[] memory _amount) public {
        require(_to.length == _amount.length, ""Invalid input"");

        for (uint256 i = 0; i < _to.length; i++) {
            address to = _to[i];
            uint256 amount = _amount[i].mul(1e18); // Convert from wei to ether
            require(amount > 0, ""Invalid amount"");
            address(this).transfer(to, amount);
        }
    }
}",3.295003652572632,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}]",4.0,31.0,0.6672124671543047,0.2189062916333633,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function transferTokens(address[] memory _to, uint256[] memory _amount) public {
        require(_to.length == _amount.length, ""Invalid input"");

        for (uint256 i = 0; i < _to.length; i++) {
            address to = _to[i];
            uint256 amount = _amount[i].mul(1e18); // Convert from wei to ether
            require(amount > 0, ""Invalid amount"");
            address(this).transfer(to, amount);
        }
    }
}"
2380,The contract address is always the message sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721ReceiverWrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4) {
        require(_operator == address(this), ""Only this contract can receive ERC721 tokens"");
        require(_data.length > 0, ""Data must be non-empty"");
        require(_from != address(0), ""From address cannot be zero"");
        require(_tokenId > 0, ""Token ID must be greater than zero"");

        // Handle the ERC721 token transfer

        return IERC721Receiver(_operator).onERC721Received.selector;
    }
}","[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'onERC721Received', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Recipient cannot be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'onERC721Received', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;
contract Contract {
    using SafeMath for uint256;

    function transfer(address recipient, uint256 amount) public {
        require(msg.sender == address(this), ""Only the contract can call this function"");
        require(recipient != address(0), ""Recipient cannot be zero address"");

        // Transfer tokens to recipient
        recipient.transfer(amount);
    }
}",2.079672336578369,transfer,"[{'function': 'transfer', 'complexity': 2}]",3.0,25.0,0.5564838216273097,0.1580119239111545,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Contract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transfer(address recipient, uint256 amount) public {
        require(msg.sender == address(this), ""Only the contract can call this function"");
        require(recipient != address(0), ""Recipient cannot be zero address"");

        // Transfer tokens to recipient
        recipient.transfer(amount);
    }
}"
4661,"Sends an ` _amount ` of ` baseToken ` to ` _to ` from this contract , and it can only be called by the contract itself","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

abstract contract WrappedTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 public baseToken;

    constructor(IERC20 _baseToken) {
        baseToken = _baseToken;
    }

    function transfer(address _to, uint256 _amount) external onlyOwner {
        if (address(baseToken) != 0) {
            require(baseToken.transfer(_to, _amount));
        } else {
            require(_to.send(_amount));
        }
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendBaseToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract itself can call this function""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""baseToken"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""baseToken""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function sendBaseToken(address _to, uint256 _amount) public {
        require(msg.sender == address(this), ""Only the contract itself can call this function"");
        // Additional logic can be added here
        IERC20 baseToken = IERC20(address(this));
        baseToken.transfer(_to, _amount);
    }
}",2.7463314533233643,sendBaseToken,"[{'function': 'sendBaseToken', 'complexity': 1}]",2.0,21.0,0.7938355132874201,0.2746269548354371,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/SafeMath.sol"";
import ""openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is SafeERC20, Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function sendBaseToken(address _to, uint256 _amount) public {
        require(msg.sender == address(this), ""Only the contract itself can call this function"");
        // Additional logic can be added here
        IERC20 baseToken = IERC20(address(this));
        baseToken.transfer(_to, _amount);
    }
}"
3343,Allow pre-approved user to take ownership of a token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) public onlyOwner {
        // Implementation of the takeOwnership function
    }
}","[{'function': 'takeOwnership', 'complexity': 0}]",1.0,{},"[{'function': 'takeOwnership', 'complexity': 0}]",1.0,"contract OwnershipTransfer {
    address public owner;
    mapping(address => bool) public approvedUsers;

    constructor() public {
        owner = msg.sender;
    }

    function transferOwnership(address newOwner) public {
        require(approvedUsers[msg.sender], ""Only approved users can transfer ownership"");
        owner = newOwner;
    }
}",1.6674327850341797,transferOwnership,"[{'function': 'transferOwnership', 'complexity': 1}]",2.0,0.0,0.5848144132354972,0.0220238149465866,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OwnershipTransfer is Ownable {
    address public owner;
    mapping(address => bool) public approvedUsers;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function transferOwnership(address newOwner) public {
        require(approvedUsers[msg.sender], ""Only approved users can transfer ownership"");
        owner = newOwner;
    }
}"
6562,Called when ` _owner ` sends ether to the MiniMe Token contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyContract is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) external payable returns (bool) {
        return true;
    }
}","[{'function': 'proxyPayment', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'proxyPayment', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";

contract MiniMeToken {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient"");
        require(_value <= balances[msg.sender], ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}",3.679980754852295,transfer,"[{'function': 'transfer', 'complexity': 2}]",3.0,52.0,0.4899589101834805,0.0302062052524355,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MiniMeToken is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set balance of owner to 1 (never 0)
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0), ""Invalid recipient"");
        require(_value <= balances[msg.sender], ""Insufficient balance"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}"
52,Function to claim any token stuck on contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface token {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    enum State { Initial, Successful }
    State public state = State.Initial;

    address public creator;

    constructor(address _creator) {
        creator = _creator;
    }

    function claimTokens(token _address) public {
        require(state == State.Successful);
        require(msg.sender == creator);
        uint256 remainder = _address.balanceOf(address(this));
        require(_address.transfer(creator, remainder), ""Transfer failed"");
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens to claim""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract TokenClaim {
    using SafeMath for uint;

    function claimToken(address tokenAddress) public {
        IERC20 token = IERC20(tokenAddress);
        uint balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to claim"");
        token.transfer(msg.sender, balance);
    }
}",3.040949583053589,claimToken,"[{'function': 'claimToken', 'complexity': 1}]",2.0,24.0,0.8125191565030627,0.2697929162773373,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenClaim is Ownable {
    using SafeMath for uint;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function claimToken(address tokenAddress) public {
        IERC20 token = IERC20(tokenAddress);
        uint balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to claim"");
        token.transfer(msg.sender, balance);
    }
}"
5414,Performs allowance transfer call on the platform by the name of specified sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ChronoBankPlatform {
    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _smbl, string memory _reference, address _sender) external returns (uint);
}

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint;

    ChronoBankPlatform public chronoBankPlatform;

    constructor(address _chronoBankPlatform) {
        chronoBankPlatform = ChronoBankPlatform(_chronoBankPlatform);
    }

    function __transferFromWithReference(address _from, address _to, uint _value, string memory _reference, address _sender) public onlyOwner {
        require(chronoBankPlatform.proxyTransferFromWithReference(_from, _to, _value, bytes32(""smbl""), _reference, _sender) == 0, ""Transfer failed"");
    }
}","[{'function': 'proxyTransferFromWithReference', 'complexity': 0}, {'function': '__transferFromWithReference', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""allowanceTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Sender cannot be the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Recipient cannot be the zero address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""allowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""allowance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'proxyTransferFromWithReference', 'complexity': 0}, {'function': '__transferFromWithReference', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function allowanceTransfer(address sender, address recipient, uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        require(sender != address(0), ""Sender cannot be the zero address"");
        require(recipient != address(0), ""Recipient cannot be the zero address"");

        uint256 allowance = SafeMath.sub(balances[sender], amount);
        balances[sender] = allowance;
        balances[recipient] = SafeMath.add(balances[recipient], amount);
    }
}",3.4447555541992188,allowanceTransfer,"[{'function': 'allowanceTransfer', 'complexity': 3}]",4.0,52.0,0.5495202576767222,0.0310209853993814,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;
    address public constant DEFAULT_SENDER = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address public constant DEFAULT_RECIPIENT = 0x2222222222222222222222222222222222222222; // Replace with actual address
    uint256 public constant DEFAULT_AMOUNT = 1;

    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        balances[msg.sender] = DEFAULT_AMOUNT;
    }

    function allowanceTransfer(address sender, address recipient, uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");
        require(sender != address(0), ""Sender cannot be the zero address"");
        require(recipient != address(0), ""Recipient cannot be the zero address"");

        uint256 allowance = SafeMath.sub(balances[sender], amount);
        balances[sender] = allowance;
        balances[recipient] = SafeMath.add(balances[recipient], amount);
    }
}"
3148,Finalize the auction - sets the final XCH token price and changes the auction stage after no bids are allowed anymore .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function transfer(address to, uint256 value) external returns (bool);
    function burn(uint256 amount) external;
}

abstract contract AuctionContract is Ownable {
    using SafeMath for uint256;

    enum Stages { NotStarted, AuctionStarted, AuctionEnded, AuctionCanceled }

    TokenInterface public token;
    address public walletAddress;
    uint256 public minPrice;
    uint256 public numTokensAuctioned;
    uint256 public softCap;
    uint256 public receivedWei;
    uint256 public endTime;
    uint256 public finalPrice;
    uint256 public tokenMultiplier;
    Stages public stage;

    event AuctionEnded(uint256 indexed finalPrice);
    event AuctionCanceled();

    constructor(address _token, address _walletAddress, uint256 _minPrice, uint256 _numTokensAuctioned, uint256 _softCap, uint256 _tokenMultiplier) {
        token = TokenInterface(_token);
        walletAddress = _walletAddress;
        minPrice = _minPrice;
        numTokensAuctioned = _numTokensAuctioned;
        softCap = _softCap;
        tokenMultiplier = _tokenMultiplier;
        stage = Stages.NotStarted;
    }

    function price() public view returns (uint256) {
        // Implement the logic to return the current price if needed
        return 0; // Placeholder, replace with actual implementation
    }

    function missingFundsToEndAuction() public view returns (uint256) {
        uint256 requiredWei = softCap;
        uint256 collectedWei = receivedWei;
        if (collectedWei >= requiredWei) {
            return 0;
        } else {
            return requiredWei - collectedWei;
        }
    }

    function finalizeAuction() public atStage(Stages.AuctionStarted) {
        require(price() == minPrice);
        endTime = block.timestamp;
        if (receivedWei < softCap) {
            token.transfer(walletAddress, numTokensAuctioned);
            stage = Stages.AuctionCanceled;
            emit AuctionCanceled();
            return;
        }
        walletAddress.transfer(receivedWei);
        uint256 missingFunds = missingFundsToEndAuction();
        if (missingFunds > 0) {
            uint256 soldTokens = tokenMultiplier.mul(receivedWei).div(price());
            uint256 burnTokens = numTokensAuctioned.sub(soldTokens);
            token.burn(burnTokens);
            numTokensAuctioned -= burnTokens;
        }
        finalPrice = tokenMultiplier.mul(receivedWei).div(numTokensAuctioned);
        stage = Stages.AuctionEnded;
        emit AuctionEnded(finalPrice);
        assert(finalPrice > 0);
    }
}","[{'function': 'burn', 'complexity': 0}, {'function': 'price', 'complexity': 0}, {'function': 'missingFundsToEndAuction', 'complexity': 4}, {'function': 'finalizeAuction', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""finalizeAuction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""auctionEndTime""}}, {""type"": ""stringLiteral"", ""value"": ""Auction not yet ended""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No bids available""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""highestBid"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""memberName"": ""bidAmount""}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""bids""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""bidAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""highestBid""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""highestBid""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""bidAmount""}}}]}, ""FalseBody"": None}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""finalPrice"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""highestBid""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""highestBid""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Finalized""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""finalPrice""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 0}, {'function': 'price', 'complexity': 0}, {'function': 'missingFundsToEndAuction', 'complexity': 4}, {'function': 'finalizeAuction', 'complexity': 4}]",5.0,"
pragma solidity ^0.8.0;

contract Auction {
    using SafeMath for uint256;

    event Finalized(uint256 finalPrice);

    function finalizeAuction() public {
        require(block.timestamp >= auctionEndTime, ""Auction not yet ended"");
        require(bids.length > 0, ""No bids available"");

        uint256 highestBid = bids[0].bidAmount;
        for (uint256 i = 1; i < bids.length; i++) {
            if (bids[i].bidAmount > highestBid) {
                highestBid = bids[i].bidAmount;
            }
        }

        uint256 finalPrice = highestBid.add(highestBid.mul(10).div(100));
        emit Finalized(finalPrice);
    }
}",4.019347667694092,finalizeAuction,"[{'function': 'finalizeAuction', 'complexity': 5}]",5.0,47.0,0.8450972868372,0.0979029027036011,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    using SafeMath for uint256;

    event Finalized(uint256 finalPrice);

    struct Bid {
        address bidder;
        uint256 bidAmount;
    }

    Bid[] public bids;
    uint256 public auctionEndTime;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        auctionEndTime = block.timestamp + 1 days; // Set to a fixed future time
    }

    function finalizeAuction() public {
        require(block.timestamp >= auctionEndTime, ""Auction not yet ended"");
        require(bids.length > 0, ""No bids available"");

        uint256 highestBid = bids[0].bidAmount;
        for (uint256 i = 1; i < bids.length; i++) {
            if (bids[i].bidAmount > highestBid) {
                highestBid = bids[i].bidAmount;
            }
        }

        uint256 finalPrice = highestBid.add(highestBid.mul(10).div(100));
        emit Finalized(finalPrice);
    }
}"
1735,` onlySecurityGuard ` Delays a payment for a set number of seconds,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
        uint earliestPayTime;
        uint securityGuardDelay;
    }

    Payment[] public authorizedPayments;
    uint public maxSecurityGuardDelay;

    modifier onlySecurityGuard() {
        require(msg.sender == owner(), ""Only the security guard can call this function"");
        _;
    }

    function delayPayment(uint _idPayment, uint _delay) public onlySecurityGuard {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if ((p.securityGuardDelay.add(_delay) > maxSecurityGuardDelay) || p.paid || p.canceled) revert();
        p.securityGuardDelay = p.securityGuardDelay.add(_delay);
        p.earliestPayTime = p.earliestPayTime.add(_delay);
    }
}","[{'function': 'delayPayment', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""delayPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_seconds"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'delayPayment', 'complexity': 0}]",5.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract PaymentDelay {
    using SafeMath for uint256;

    function delayPayment(uint256 _seconds) public view returns (bool) {
        // Additional logic can be added here
        return true;
    }
}",4.603137969970703,delayPayment,"[{'function': 'delayPayment', 'complexity': 0}]",1.0,48.0,0.6856853635882009,0.011440920706493,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract PaymentDelay is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender; // Assuming 'owner' is a state variable of type address
        delayDuration = 1 days; // Example value for uint256, set to a fixed value instead of zero or default
    }

    function delayPayment(uint256 _seconds) public view returns (bool) {
        // Additional logic can be added here
        return true;
    }
}"
170,Access point for the oracle to update the prices of havvens / eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent, ""Time must be later than last update"");
        require(timeSent < (block.timestamp + ORACLE_FUTURE_LIMIT), ""Time must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}","[{'function': 'updatePrices', 'complexity': 2}]",3.0,{},"[{'function': 'updatePrices', 'complexity': 2}]",3.0,"
contract Oracle {
    using SafeMath for uint256;

    event PriceUpdated(uint256 indexed _timestamp, uint256 _price);

    function updatePrice() public {
        // Additional logic can be added here
        emit PriceUpdated(block.timestamp, havvensPerEth);
    }
}",1.450026273727417,updatePrice,"[{'function': 'updatePrice', 'complexity': 0}]",1.0,46.0,0.7840812663405966,0.0075930740499381,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Oracle is Ownable {
    using SafeMath for uint256;

    event PriceUpdated(uint256 indexed _timestamp, uint256 _price);

    uint256 public havvensPerEth = 1; // Set to a safe non-zero value

    constructor() Ownable(msg.sender) {
        // Additional initialization logic can be added here
    }

    function updatePrice() public {
        emit PriceUpdated(block.timestamp, havvensPerEth);
    }
}"
5043,This function burns all B2BK tokens on the address that caused this function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed user, uint256 amount);

    function burn() external isFinalized {
        uint256 _balance = balanceOf[msg.sender];
        assert(_balance > 0);
        totalSupply = totalSupply.sub(_balance);
        balanceOf[msg.sender] = 0;
        emit Burn(msg.sender, _balance);
    }
}","[{'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnAllTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_address""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract B2BKToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    function burnAllTokens(address _address) public {
        require(_address != address(0), ""Invalid address"");
        uint256 balance = balances[_address];
        balances[_address] = 0;
        emit Transfer(_address, address(0), balance);
    }
}",2.407122135162353,burnAllTokens,"[{'function': 'burnAllTokens', 'complexity': 1}]",2.0,24.0,0.6750737926139454,0.0546718001681023,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract B2BKToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function burnAllTokens(address _address) public {
        require(_address != address(0), ""Invalid address"");
        uint256 balance = balances[_address];
        balances[_address] = 0;
        emit Transfer(_address, address(0), balance);
    }
}"
3040,This function returns the signature of configure function,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getInitFunction() public pure returns (bytes4) {
        return 0x0;
    }
}","[{'function': 'getInitFunction', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getConfigureSignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""signature"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""signature""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes1""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}}}]}}, {""type"": ""Identifier"", ""name"": ""signature""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'getInitFunction', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function getConfigureSignature(uint256 _value) public pure returns (bytes memory) {
        bytes memory signature = new bytes(_value);
        for (uint256 i = 0; i < _value; i++) {
            signature[i] = bytes1(i);
        }
        return signature;
    }
}",2.293614625930786,getConfigureSignature,"[{'function': 'getConfigureSignature', 'complexity': 1}]",2.0,29.0,0.5106909896479637,0.0937018714776351,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    // Fixed values for initialization
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        _uint256 = 1; // Never set to 0
        _address = DEFAULT_ADDRESS;
        _bool = DEFAULT_BOOL;
        _string = DEFAULT_STRING;
        _bytes32 = DEFAULT_BYTES32;
    }

    uint256 private _uint256;
    address private _address;
    bool private _bool;
    string private _string;
    bytes32 private _bytes32;

    function getConfigureSignature(uint256 _value) public pure returns (bytes memory) {
        bytes memory signature = new bytes(_value);
        for (uint256 i = 0; i < _value; i++) {
            signature[i] = bytes1(i);
        }
        return signature;
    }
}"
4025,Converts WT0 to CarbonUSD for the user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ConversionContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;
    bool public paused = false;

    event ConvertedToCUSD(address indexed user, uint256 amount);

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }

    function _burn(address account, uint256 amount) internal {
        require(balances[account] >= amount, ""Burn amount exceeds balance"");
        balances[account] = balances[account].sub(amount);
    }

    function _mintCUSD(address account, uint256 amount) internal {
        balances[account] = balances[account].add(amount);
    }

    function convertWT(uint256 _amount) public whenNotPaused requiresPermission {
        require(balanceOf(msg.sender) >= _amount, ""Conversion amount should be less than balance"");
        _burn(msg.sender, _amount);
        _mintCUSD(msg.sender, _amount);
        emit ConvertedToCUSD(msg.sender, _amount);
    }

    modifier requiresPermission() {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""Caller is not authorized"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': '_burn', 'complexity': 1}, {'function': '_mintCUSD', 'complexity': 0}, {'function': 'convertWT', 'complexity': 2}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""convertWT0ToCarbonUSD"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""wt0Amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""wt0Amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""ether""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': '_burn', 'complexity': 1}, {'function': '_mintCUSD', 'complexity': 0}, {'function': 'convertWT', 'complexity': 2}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract CarbonUSD {
    using SafeMath for uint256;

    function convertWT0ToCarbonUSD(uint256 wt0Amount) public view returns (uint256) {
        return wt0Amount.mul(1 ether).div(10 ** 18);
    }
}",1.919114589691162,convertWT0ToCarbonUSD,"[{'function': 'convertWT0ToCarbonUSD', 'complexity': 0}]",1.0,30.0,0.6712832267135077,0.0248247781843232,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming Ownable is imported correctly

contract CarbonUSD is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender; // Address set to placeholder value 0x1111111111111111111111111111111111111111
        initialized = true; // bool set to true
        tokenName = 'MyToken'; // string set to 'initialized'
        initBytes32 = bytes32('init'); // bytes32 set to bytes32('init')
    }

    function convertWT0ToCarbonUSD(uint256 wt0Amount) public pure returns (uint256) {
        return wt0Amount.mul(1 ether).div(10 ** 18);
    }
}"
281,Announces intent to cancel tokens using ` slowCancel `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Offer {
        address maker;
        uint256 availableAmount;
    }

    mapping(bytes32 => Offer) public offers;
    mapping(bytes32 => uint256) public announcedCancellations;
    uint256 public cancelAnnounceDelay;

    event CancelAnnounce(address indexed maker, bytes32 indexed offerHash, uint256 canCancelAt);

    function announceCancel(bytes32 _offerHash) external {
        Offer memory offer = offers[_offerHash];
        require(offer.maker == msg.sender, ""Invalid sender"");
        require(offer.availableAmount > 0, ""Offer already cancelled"");
        uint256 canCancelAt = block.timestamp + cancelAnnounceDelay;
        announcedCancellations[_offerHash] = canCancelAt;
        emit CancelAnnounce(offer.maker, _offerHash, canCancelAt);
    }
}","[{'function': 'announceCancel', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""slowCancel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""value""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'announceCancel', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

contract CancelTokens {
    using SafeMath for uint256;

    struct Token {
        address owner;
        uint256 value;
    }

    mapping(address => Token) public tokens;

    function slowCancel(uint256 _amount, address _owner) external {
        require(_amount > 0, ""Invalid amount"");
        require(_owner != address(0), ""Invalid owner"");

        uint256 balance = tokens[_owner].value.add(_amount);
        require(balance <= tokens[_owner].value, ""Insufficient funds"");

        tokens[_owner].value = balance;
    }
}",3.060177803039551,slowCancel,"[{'function': 'slowCancel', 'complexity': 3}]",4.0,30.0,0.5808399784554473,0.1164323510910969,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CancelTokens is Ownable {
    using SafeMath for uint256;

    struct Token {
        address owner;
        uint256 value;
    }

    mapping(address => Token) public tokens;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            tokens[addr] = Token({owner: addr, value: uint256(i)});
        }
    }

    function slowCancel(uint256 _amount, address _owner) external {
        require(_amount > 0, ""Invalid amount"");
        require(_owner != address(0), ""Invalid owner"");

        uint256 balance = tokens[_owner].value.add(_amount);
        require(balance <= tokens[_owner].value, ""Insufficient funds"");

        tokens[_owner].value = balance;
    }
}"
5915,This is public rather than external so we can call super.unpause without using an expensive CALL .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool private paused = false;

    modifier whenPaused() {
        require(paused, ""Contract must be paused"");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyCEO whenPaused {
        require(saleAuction != address(0));
        require(siringAuction != address(0));
        require(geneScience != address(0));
        require(lottery != address(0));
        require(variation != address(0));
        require(newContractAddress == address(0));
        super.unpause();
    }
}","[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""unpause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 6}]",7.0,"
pragma solidity ^0.8.0;

contract Pausable {
    bool private _paused = false;

    modifier whenNotPaused() {
        require(!_paused, ""Contract is paused"");
        _;
    }

    function unpause() public onlyOwner whenNotPaused {
        _paused = false;
    }
}",1.6326935291290283,unpause,"[{'function': 'unpause', 'complexity': 0}]",1.0,49.0,0.7890488204597189,0.0021377631861455,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Pausable is Ownable {
    bool private _paused = false;

    modifier whenNotPaused() {
        require(!_paused, ""Contract is paused"");
        _;
    }

    function unpause() public onlyOwner whenNotPaused {
        _paused = false;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract PausableWithInitialization is Pausable {
    constructor() {
        _paused = true; // Set to true initially, as per the initialization rules.
        initializeOwnable(); // Initialize Ownable with msg.sender
    }

    function initializeOwnable() internal {
        Ownable.__Ownable_init();
        Ownable._transferOwnership(msg.sender);
    }
}"
1091,"owners : send ` value ` of ether to address ` to ` , can be called if crowdsale succeeded","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IContract {
    function balanceOf(address account) external view returns (uint256);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    event EtherSent(address indexed to, uint256 value);

    struct State {
        bool succeeded;
    }

    mapping(bytes32 => bool) private manyOwners;
    mapping(address => State) public states;

    modifier validAddress(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    modifier onlyManyOwners(bytes32 txHash) {
        bool allowed = manyOwners[txHash];
        require(allowed, ""Only many owners can call this function"");
        _;
    }

    modifier requiresState(State memory state) {
        require(state.succeeded, ""Function cannot be called in current state"");
        _;
    }

    function sendEther(address to, uint256 value) external validAddress(to) onlyManyOwners(keccak256(msg.data)) requiresState(states[msg.sender]) {
        require(value > 0 && address(this).balance >= value, ""Insufficient balance"");
        (bool success,) = to.call{value: value}("""");
        require(success, ""Transfer failed"");
        emit EtherSent(to, value);
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'sendEther', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Address not whitelisted""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1000"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Minimum contribution of 1 ETH required""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""to"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""uint160""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""to""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'sendEther', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract Crowdsale is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    function buyTokens() public payable {
        require(whitelist[msg.sender], ""Address not whitelisted"");
        require(msg.value >= 1000, ""Minimum contribution of 1 ETH required"");
        uint256 tokens = msg.value.div(10); // 1 ETH = 10 tokens
        address payable to = address(uint160(owner()));
        to.transfer(msg.value);
    }
}",4.6101179122924805,buyTokens,"[{'function': 'buyTokens', 'complexity': 2}]",4.0,42.0,0.5369291403731209,0.0806241363472057,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract Crowdsale is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public whitelist;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        whitelist[msg.sender] = true;
    }

    function buyTokens() public payable {
        require(whitelist[msg.sender], ""Address not whitelisted"");
        require(msg.value >= 1000, ""Minimum contribution of 1 ETH required"");
        uint256 tokens = msg.value.div(10); // 1 ETH = 10 tokens
        address payable to = address(uint160(owner()));
        to.transfer(msg.value);
    }
}"
2215,Notifies the controller about an approval allowing the controller to react if desired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApprovalWrapper {
    using SafeMath for uint256;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool) {
        require(_amount.add(1).sub(1) == _amount, ""SafeMath: addition overflow"");
        require(_owner != address(0), ""_owner is zero address"");
        require(_spender != address(0), ""_spender is zero address"");

        emit Approval(_owner, _spender, _amount);

        return true;
    }
}","[{'function': 'onApprove', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""notifyApproval"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_controller""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Controller must be set""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onApprove', 'complexity': 3}]",4.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract ApprovalNotifier {
    using SafeMath for uint256;

    address private _controller;

    event Approval(address indexed approver, uint256 indexed amount);

    constructor(address controller) public {
        _controller = controller;
    }

    function notifyApproval(uint256 amount) external {
        require(_controller != address(0), ""Controller must be set"");
        emit Approval(msg.sender, amount);
    }
}",2.5573601722717285,notifyApproval,"[{'function': 'notifyApproval', 'complexity': 1}]",3.0,32.0,0.7384844086094117,0.0765567239896179,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ApprovalNotifier is Ownable {
    using SafeMath for uint256;

    address private _controller;

    event Approval(address indexed approver, uint256 indexed amount);

    constructor(address controller) Ownable() {
        _controller = controller;
    }

    function notifyApproval(uint256 amount) external {
        require(_controller != address(0), ""Controller must be set"");
        emit Approval(msg.sender, amount);
    }
}"
5767,Withdraws tokens other than DGZ to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function anyTokenWithdrawal(address _address, uint _amount) public onlyOwner {
        require(_address != address(tokenReward), ""Cannot withdraw from the reward token."");
        StandardToken token = StandardToken(_address);
        token.transfer(beneficiary, _amount);
        TokensWithdrawn(beneficiary, _address, _amount);
    }
}","[{'function': 'anyTokenWithdrawal', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_beneficiary""}, {""type"": ""Identifier"", ""name"": ""totalAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'anyTokenWithdrawal', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract Withdrawal {
    using SafeMath for uint256;

    function withdraw(address payable _beneficiary, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");

        // Calculate the total amount of tokens to be withdrawn
        uint256 totalAmount = _amount.add(fee);

        // Transfer the tokens to the beneficiary
        address(this).transfer(_beneficiary, totalAmount);
    }
}",2.697606086730957,withdraw,"[{'function': 'withdraw', 'complexity': 1}]",2.0,14.0,0.774176260929439,0.0531244064985578,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract Withdrawal is Ownable {
    using SafeMath for uint256;

    uint256 public fee = 1; // Fixed safe non-corner-case value

    constructor() Ownable(msg.sender) {
        // No need to initialize _beneficiary or _amount as they are not state variables in this context
    }

    function withdraw(address payable _beneficiary, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");

        // Calculate the total amount of tokens to be withdrawn
        uint256 totalAmount = _amount.add(fee);

        // Transfer the tokens to the beneficiary
        address(this).transfer(_beneficiary, totalAmount);
    }
}"
3863,Claim token after token sale based on stake .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EthealTokenWrapper {
    using SafeMath for uint256;

    address public ethealController;
    mapping(address => uint256) public stakes;
    uint256 public rate;
    uint256 public tokenBalance;
    bool public paused = false;

    event TokenClaimed(address indexed sender, address indexed beneficiary, uint256 stake, uint256 tokens);

    modifier afterSaleSuccess() {
        // Assuming some condition for sale success is checked here.
        require(true, ""Sale must have succeeded"");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function claimTokenFor(address _beneficiary) public afterSaleSuccess whenNotPaused {
        uint256 stake = stakes[_beneficiary];
        require(stake > 0);
        stakes[_beneficiary] = 0;
        uint256 tokens = stake.mul(rate);
        tokenBalance = tokenBalance.sub(tokens);
        ethealController.call(abi.encodeWithSignature(""addHodlerStake(address,uint256)"", _beneficiary, tokens.mul(2)));
        require(ethealController.call(abi.encodeWithSignature(""ethealToken()"")).delegatecall(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _beneficiary, tokens)));
        emit TokenClaimed(msg.sender, _beneficiary, stake, tokens);
    }
}","[{'function': 'claimTokenFor', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakers""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""isClaimed""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Stake already claimed""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakers""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""stakedAmount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakers""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""isClaimed""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimedToken""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokenAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'claimTokenFor', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

contract TokenSale {
    using SafeMath for uint256;

    struct Staker {
        address addr;
        uint256 stakedAmount;
        bool isClaimed;
    }

    mapping(address => Staker) public stakers;

    function claimToken() public {
        require(!stakers[msg.sender].isClaimed, ""Stake already claimed"");

        uint256 tokenAmount = stakers[msg.sender].stakedAmount.mul(100); // 100 tokens per ETH staked
        stakers[msg.sender].isClaimed = true;

        emit ClaimedToken(msg.sender, tokenAmount);
    }

    event ClaimedToken(address indexed _staker, uint256 _tokenAmount);
}",3.808328151702881,claimToken,"[{'function': 'claimToken', 'complexity': 2}]",2.0,65.0,0.7490799380216276,0.0120659657548006,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    using SafeMath for uint256;

    struct Staker {
        address addr;
        uint256 stakedAmount;
        bool isClaimed;
    }

    mapping(address => Staker) public stakers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            stakers[addr] = Staker({addr: addr, stakedAmount: 1, isClaimed: false});
        }
    }

    function claimToken() public {
        require(!stakers[msg.sender].isClaimed, ""Stake already claimed"");

        uint256 tokenAmount = stakers[msg.sender].stakedAmount.mul(100); // 100 tokens per ETH staked
        stakers[msg.sender].isClaimed = true;

        emit ClaimedToken(msg.sender, tokenAmount);
    }

    event ClaimedToken(address indexed _staker, uint256 _tokenAmount);
}"
6728,Used by a controller to execute a forced transfer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event ForceTransfer(address indexed sender, address indexed from, address indexed to, uint256 value, bool verified, bytes log);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function forceTransfer(address _from, address _to, uint256 _value, bytes memory _data, bytes memory _log) public onlyController {
        require(_to != address(0));
        require(_value <= balances[_from]);
        bool verified = _updateTransfer(_from, _to, _value, _data);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit ForceTransfer(msg.sender, _from, _to, _value, verified, _log);
        emit Transfer(_from, _to, _value);
    }

    function _updateTransfer(address _from, address _to, uint256 _value, bytes memory _data) internal returns (bool) {
        // Implement the logic for updating transfer here
        return true; // Placeholder
    }
}","[{'function': 'forceTransfer', 'complexity': 2}, {'function': '_updateTransfer', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""forceTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'forceTransfer', 'complexity': 2}, {'function': '_updateTransfer', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Controller {
    using SafeMath for uint256;

    function forceTransfer(address payable recipient, uint256 amount) public {
        require(msg.sender == owner);
        recipient.transfer(amount);
    }
}",1.7044885158538818,forceTransfer,"[{'function': 'forceTransfer', 'complexity': 1}]",3.0,60.0,0.7537499169881917,0.0137429923346669,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your environment

contract Controller is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function forceTransfer(address payable recipient, uint256 amount) public {
        require(msg.sender == owner());
        recipient.transfer(amount);
    }
}"
691,Determine if a validator at account ` validator ` is able to issue attributes of the type with ID ` attributeTypeID ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Validator {
    using SafeMath for uint256;

    function canIssueAttributeType(address validator, uint256 attributeTypeID) external view returns (bool) {
        require(validator != address(0), ""Invalid validator address"");
        require(attributeTypeID > 0, ""Invalid attribute type ID"");
        return true;
    }
}","[{'function': 'canIssueAttributeType', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""canIssueAttribute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""attributeTypeID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""hasRole""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""VALIDATOR_ROLE""}, {""type"": ""Identifier"", ""name"": ""validator""}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""isValidAttributeType""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""attributeTypeID""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'canIssueAttributeType', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR"");

    function canIssueAttribute(address validator, uint256 attributeTypeID) external view returns (bool) {
        return hasRole(VALIDATOR_ROLE, validator) && isValidAttributeType(attributeTypeID);
    }

    function isValidAttributeType(uint256 attributeTypeID) internal pure returns (bool) {
        // Additional logic can be added here to check if the attribute type ID is valid
        return true;
    }
}",7.535252094268799,isValidAttributeType,"[{'function': 'canIssueAttribute', 'complexity': 0}, {'function': 'isValidAttributeType', 'complexity': 0}]",1.0,12.0,0.7494847283104706,0.1324779434586988,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract MyContract is AccessControl {
    using SafeMath for uint256;

    bytes32 public constant VALIDATOR_ROLE = keccak256(""VALIDATOR"");

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function canIssueAttribute(address validator, uint256 attributeTypeID) external view returns (bool) {
        return hasRole(VALIDATOR_ROLE, validator) && isValidAttributeType(attributeTypeID);
    }

    function isValidAttributeType(uint256 attributeTypeID) internal pure returns (bool) {
        // Additional logic can be added here to check if the attribute type ID is valid
        return true;
    }
}"
876,Initialize Finance app for Vault at ` _vault ` with period length of ` @ transformTime ( _periodDuration ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

interface Vault {
    function isContract() external view returns (bool);
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool inactive;
    }

    Vault public vault;
    Settings public settings;
    mapping(uint => Payment) public payments;
    uint public paymentsNextIndex;
    uint public transactionsNextIndex;

    event Initialized();

    error VaultNotContract(string message);
    error InitPeriodTooShort(string message);

    constructor() {
        settings.periodDuration = 0;
    }

    function initialize(Vault _vault, uint64 _periodDuration) external onlyOwner {
        require(_vault.isContract(), ""ERROR_VAULT_NOT_CONTRACT"");
        vault = _vault;
        if (_periodDuration < 1 days) revert InitPeriodTooShort(""ERROR_INIT_PERIOD_TOO_SHORT"");
        settings.periodDuration = _periodDuration;
        payments[0].inactive = true;
        paymentsNextIndex = 1;
        transactionsNextIndex = 1;
        _newPeriod(getTimestamp64());
    }

    function getTimestamp64() internal view returns (uint64) {
        return uint64(block.timestamp);
    }

    struct Settings {
        uint64 periodDuration;
    }
}","[{'function': 'isContract', 'complexity': 0}, {'function': 'initialize', 'complexity': 1}, {'function': 'getTimestamp64', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeFinanceApp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_vault"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_vault""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid vault""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid period duration""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Vault""}, ""name"": ""vault"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vaults""}, ""index"": {""type"": ""Identifier"", ""name"": ""_vault""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""vault""}, ""memberName"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""vault""}, ""memberName"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""vault""}, ""memberName"": ""periodDuration""}, ""right"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isContract', 'complexity': 0}, {'function': 'initialize', 'complexity': 1}, {'function': 'getTimestamp64', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol"";

contract FinanceApp {
    using SafeMath for uint256;

    struct Vault {
        address owner;
        uint256 balance;
        uint256 periodDuration;
    }

    mapping(address => Vault) public vaults;

    function initializeFinanceApp(address _vault, uint256 _periodDuration) external {
        require(_vault != address(0), ""Invalid vault"");
        require(_periodDuration > 0, ""Invalid period duration"");

        Vault storage vault = vaults[_vault];
        vault.owner = msg.sender;
        vault.balance = 0;
        vault.periodDuration = _periodDuration;
    }
}",6.382397174835205,initializeFinanceApp,"[{'function': 'initializeFinanceApp', 'complexity': 2}]",3.0,31.0,0.8277118083187865,0.0497758962858302,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract FinanceApp is Ownable {
    using SafeMath for uint256;

    struct Vault {
        address owner;
        uint256 balance;
        uint256 periodDuration;
    }

    mapping(address => Vault) public vaults;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function initializeFinanceApp(address _vault, uint256 _periodDuration) external {
        require(_vault != address(0), ""Invalid vault"");
        require(_periodDuration > 0, ""Invalid period duration"");

        Vault storage vault = vaults[_vault];
        vault.owner = msg.sender;
        vault.balance = 0;
        vault.periodDuration = _periodDuration;
    }
}"
2491,Enables token holders to transfer their tokens freely if true,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    bool public transfersEnabled;

    function enableTransfers(bool _transfersEnabled) public onlyOwner {
        transfersEnabled = _transfersEnabled;
    }
}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""enableFreeTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can enable free transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""freeTransferEnabled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'enableTransfers', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract MyContract {
    // State variables
    bool public freeTransferEnabled = false;

    // Functions
    function enableFreeTransfer() external {
        require(msg.sender == owner, ""Only the contract owner can enable free transfer"");
        freeTransferEnabled = true;
    }

    function disableFreeTransfer() external {
        require(msg.sender == owner, ""Only the contract owner can disable free transfer"");
        freeTransferEnabled = false;
    }
}",2.423672914505005,enableFreeTransfer,"[{'function': 'enableFreeTransfer', 'complexity': 1}, {'function': 'disableFreeTransfer', 'complexity': 1}]",2.0,11.0,0.7701545370857714,0.0113716819348752,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    // State variables
    bool public freeTransferEnabled = false;

    // Constructor
    constructor() Ownable(msg.sender) {
        // Initialize state variables to fixed, safe, non-corner-case values
        freeTransferEnabled = true; // Set to true instead of false as per the initialization rules
    }

    // Functions
    function enableFreeTransfer() external {
        require(msg.sender == owner(), ""Only the contract owner can enable free transfer"");
        freeTransferEnabled = true;
    }

    function disableFreeTransfer() external {
        require(msg.sender == owner(), ""Only the contract owner can disable free transfer"");
        freeTransferEnabled = false;
    }
}"
1924,Create ` mintedAmount ` tokens and send it to ` target `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    address private _crowdsaleAgent;

    modifier onlyCrowdsaleAgent() {
        require(_crowdsaleAgent == msg.sender, ""Only crowdsale agent can call this function"");
        _;
    }

    constructor(address crowdsaleAgent) {
        _crowdsaleAgent = crowdsaleAgent;
    }

    function mintToken(address target, uint256 mintedAmount) public onlyCrowdsaleAgent {
        balanceOf[target] = balanceOf[target].add(mintedAmount);
        totalSupply = totalSupply.add(mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
}","[{'function': 'mintToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""mintedAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""mintedAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Mint amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""target""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Target address cannot be zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalSupply""}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""target""}}, {""type"": ""Identifier"", ""name"": ""mintedAmount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'mintToken', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function mint(uint256 mintedAmount, address payable target) public {
        require(mintedAmount > 0, ""Mint amount must be greater than zero"");
        require(target != address(0), ""Target address cannot be zero"");

        uint256 totalSupply = SafeMath.add(totalSupply, mintedAmount);
        balances[target] = SafeMath.add(balances[target], mintedAmount);
    }
}",2.8590548038482666,mint,"[{'function': 'mint', 'complexity': 2}]",3.0,30.0,0.7331506899770537,0.1235214833275987,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        totalSupply = 1000000000000000000; // Set to a fixed value
        balances[msg.sender] = 1000; // Initialize with a non-zero value
    }

    function mint(uint256 mintedAmount, address payable target) public {
        require(mintedAmount > 0, ""Mint amount must be greater than zero"");
        require(target != address(0), ""Target address cannot be zero"");

        totalSupply = SafeMath.add(totalSupply, mintedAmount);
        balances[target] = SafeMath.add(balances[target], mintedAmount);
    }
}"
2485,"if there is an unresolvable problem , users can call to this function to get a refund .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256[]) public ownedTokens;
    uint256 public constant STARTING_PRICE = 1 ether; // Example value, adjust as needed

    modifier hasFinalized() {
        require(finalized, ""Function can only be called after the event has finalized"");
        _;
    }

    bool public finalized = true; // Set to false if there's an initialization phase or other conditions

    function emergencyWithdraw() external hasFinalized {
        uint256 balance = STARTING_PRICE.mul(ownedTokens[msg.sender].length);
        delete ownedTokens[msg.sender];
        msg.sender.transfer(balance);
    }
}","[{'function': 'emergencyWithdraw', 'complexity': 0}]",1.0,{},"[{'function': 'emergencyWithdraw', 'complexity': 0}]",1.0,"
contract Refund {
    using SafeMath for uint256;

    function refund(uint256 amount) public payable returns (bool) {
        require(msg.sender == owner, ""Only the owner can call this function"");
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 balance = address(this).balance;
        if (balance < amount) {
            return false;
        }

        msg.sender.transfer(amount);
        return true;
    }
}",2.447542190551758,refund,"[{'function': 'refund', 'complexity': 3}]",4.0,27.0,0.4725789611132335,0.026473268008963,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Refund is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function refund(uint256 amount) public payable returns (bool) {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 balance = address(this).balance;
        if (balance < amount) {
            return false;
        }

        msg.sender.transfer(amount);
        return true;
    }
}"
1164,Allows recovery addresses to trigger the recovery process for an Identity .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract IdentityRecovery {
    using SafeMath for uint256;

    struct RecoveryLog {
        uint timestamp;
        bytes32 membersHash;
    }

    struct AssociatedAddresses {
        address[] members;
    }

    struct Identity {
        AssociatedAddresses associatedAddresses;
    }

    mapping(uint => Identity) public identityDirectory;
    mapping(uint => RecoveryLog) public recoveryLogs;
    mapping(uint => address) public recoveryAddressChangeLogs;
    uint8 private constant RECOVERY_PERMISSION = 27;

    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp) public {
        require(_identityExists(ein), ""Identity does not exist."");
        require(_hasIdentity(newAssociatedAddress, false), ""New associated address is not a valid identity."");
        require(canRecover(ein), ""Cannot trigger recovery yet."");
        require(isSigned(newAssociatedAddress, keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), ""I authorize being added to this Identity via recovery."", ein, newAssociatedAddress, timestamp))), ""Permission denied."");
        require(canChangeRecoveryAddress(ein) || msg.sender == recoveryAddressChangeLogs[ein], ""Only the current or previously removed recovery address can trigger recovery."");

        Identity storage _identity = identityDirectory[ein];
        recoveryLogs[ein] = RecoveryLog(block.timestamp, keccak256(abi.encodePacked(_identity.associatedAddresses.members)));
        emit RecoveryTriggered(msg.sender, ein, _identity.associatedAddresses.members, newAssociatedAddress);
        resetIdentityData(_identity, msg.sender, false);
        addAssociatedAddress(ein, newAssociatedAddress);
    }

    function _identityExists(uint ein) internal view returns (bool) {
        return address(uint160(uint256(keccak256(abi.encodePacked(""identity"", ein)))) % 10**40) != address(0);
    }

    function _hasIdentity(address addr, bool isRecoveryAddress) internal view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function canRecover(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function isSigned(address signer, bytes32 hash) internal pure returns (bool) {
        require(signer != address(0), ""ECDSA: invalid signature"");
        return signer == ecrecover(hash, v, r, s);
    }

    function canChangeRecoveryAddress(uint ein) public view returns (bool) {
        // Implementation omitted for brevity
        return true;
    }

    function resetIdentityData(Identity storage identity, address newOwner, bool isRecoveryAddress) internal {
        // Implementation omitted for brevity
    }

    function addAssociatedAddress(uint ein, address newAssociatedAddress) internal {
        // Implementation omitted for brevity
    }

    event RecoveryTriggered(address indexed initiator, uint indexed ein, address[] members, address newAssociatedAddress);
}","[{'function': 'triggerRecovery', 'complexity': 6}, {'function': '_identityExists', 'complexity': 0}, {'function': '_hasIdentity', 'complexity': 0}, {'function': 'canRecover', 'complexity': 0}, {'function': 'isSigned', 'complexity': 1}, {'function': 'canChangeRecoveryAddress', 'complexity': 0}, {'function': 'resetIdentityData', 'complexity': 0}, {'function': 'addAssociatedAddress', 'complexity': 0}]",8.0,{},"[{'function': 'triggerRecovery', 'complexity': 6}, {'function': '_identityExists', 'complexity': 0}, {'function': '_hasIdentity', 'complexity': 0}, {'function': 'canRecover', 'complexity': 0}, {'function': 'isSigned', 'complexity': 1}, {'function': 'canChangeRecoveryAddress', 'complexity': 0}, {'function': 'resetIdentityData', 'complexity': 0}, {'function': 'addAssociatedAddress', 'complexity': 0}]",8.0,"contract Recovery {
    using SafeMath for uint256;

    struct Identity {
        address owner;
        bool isRecoverable;
        mapping(address => bool) recoveryAllowed;
    }

    function recoverIdentity(uint256 identityId, address newOwner) public {
        require(identityId > 0, ""Invalid identity ID"");
        require(newOwner != address(0), ""New owner cannot be the zero address"");

        Identity memory identity = identities[identityId];
        require(identity.isRecoverable == true, ""Identity is not recoverable"");
        require(identity.recoveryAllowed[msg.sender] == true, ""Sender is not allowed to initiate recovery"");

        // Additional logic can be added here
    }
}",3.461942434310913,recoverIdentity,"[{'function': 'recoverIdentity', 'complexity': 4}]",5.0,121.0,0.664222064849867,0.0495458950720763,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Recovery is Ownable {
    using SafeMath for uint256;

    struct Identity {
        address owner;
        bool isRecoverable;
        mapping(address => bool) recoveryAllowed;
    }

    uint256 public constant MAX_IDENTITY_ID = 3; // Fixed number of identities
    mapping(uint256 => Identity) public identities;

    constructor() Ownable(msg.sender) {
        for (uint256 i = 1; i <= MAX_IDENTITY_ID; i++) {
            identities[i] = Identity({
                owner: address(0),
                isRecoverable: false,
                recoveryAllowed: new mapping(address => bool)(address(0))
            });
        }
    }

    function recoverIdentity(uint256 identityId, address newOwner) public {
        require(identityId > 0 && identityId <= MAX_IDENTITY_ID, ""Invalid identity ID"");
        require(newOwner != address(0), ""New owner cannot be the zero address"");

        Identity storage identity = identities[identityId];
        require(identity.isRecoverable == true, ""Identity is not recoverable"");
        require(identity.recoveryAllowed[msg.sender] == true, ""Sender is not allowed to initiate recovery"");

        // Additional logic can be added here
    }
}"
461,Checks whether a contract implements an ERC165 interface or not without using nor updating the cache .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool);
}

abstract contract ImplementsERC165InterfaceNoCache is Ownable {
    using SafeMath for uint256;

    bytes4 constant ERC165ID = 0x01ffc9a7;
    bytes4 constant INVALID_ID = 0xffffffff;

    function noThrowCall(address _contract, bytes4 _interfaceId) internal view returns (uint256 success, uint256 result) {
        (success, result) = address(_contract).staticcall(abi.encodeWithSelector(ERC165.supportsInterface.selector, _interfaceId));
    }

    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        uint256 success;
        uint256 result;
        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, INVALID_ID);
        if (success == 0 || result != 0) {
            return false;
        }
        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }
        return false;
    }
}","[{'function': 'supportsInterface', 'complexity': 0}, {'function': 'noThrowCall', 'complexity': 0}, {'function': 'implementsERC165InterfaceNoCache', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""implementsInterface"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""contractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": ""interfaceId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC165""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contractAddress""}], ""names"": []}, ""memberName"": ""supportsInterface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""interfaceId""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'supportsInterface', 'complexity': 0}, {'function': 'noThrowCall', 'complexity': 0}, {'function': 'implementsERC165InterfaceNoCache', 'complexity': 6}]",7.0,"pragma solidity ^0.8.0;

import ""./ERC165.sol"";
import ""./SafeMath.sol"";

contract MyContract {
    function implementsInterface(address contractAddress, bytes4 interfaceId) public view returns (bool) {
        return ERC165(contractAddress).supportsInterface(interfaceId);
    }
}",1.7251856327056885,implementsInterface,"[{'function': 'implementsInterface', 'complexity': 0}]",1.0,55.0,0.7382759119340869,0.0212303458090529,"pragma solidity ^0.8.0;

import ""./ERC165.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract {
    // Fixed, safe values for instance variables
    uint256 public constant _INITIAL_VALUE = 1;
    address public constant _DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant _DEFAULT_BOOL = true;
    string public constant _DEFAULT_STRING = 'initialized';
    bytes32 public constant _DEFAULT_BYTES32 = bytes32('init');

    constructor() {
        // Initialize state variables using fixed, safe values
        uint256(uint256) = _INITIAL_VALUE;
        address(address) = _DEFAULT_ADDRESS;
        bool(bool) = _DEFAULT_BOOL;
        string(string) = _DEFAULT_STRING;
        bytes32(bytes32) = _DEFAULT_BYTES32;

        // Invoke parent contract constructors (if applicable)
        constructor() Ownable(msg.sender);
    }

    function implementsInterface(address contractAddress, bytes4 interfaceId) public view returns (bool) {
        return ERC165(contractAddress).supportsInterface(interfaceId);
    }
}"
3202,Retreive account ID associated with a user 's address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public accountByAddress;

    function accountIdForAddress(address _address) public view returns (uint256) {
        require(addressBelongsToAccount(_address));
        return accountByAddress[_address];
    }

    function addressBelongsToAccount(address _address) internal view virtual returns (bool);
}","[{'function': 'accountIdForAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAccountId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_userAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'accountIdForAddress', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function getAccountId(address _userAddress) public view returns (uint256) {
        // Additional logic can be added here
        return 0;
    }
}",1.6092922687530518,getAccountId,"[{'function': 'getAccountId', 'complexity': 0}]",1.0,9.0,0.7084719565892136,0.3332777555865795,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        accountId = 1;
        userAddress1 = address(0x111);
        userAddress2 = address(0x222);
        userAddress3 = address(0x333);
        isInitialized = true;
        tokenName = ""MyToken"";
    }

    uint256 public accountId;
    address public userAddress1;
    address public userAddress2;
    address public userAddress3;
    bool public isInitialized;
    bytes32 public constant INITIALIZED_VALUE = keccak256(""init"");
    string public tokenName;

    function getAccountId(address _userAddress) public view returns (uint256) {
        // Additional logic can be added here
        return 0;
    }
}"
5007,Get the index of PixelCon ` ( _tokenId ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function getTokenIndex(uint256 _tokenId) public view returns (uint64) {
        require(_tokenId != 0, ""Invalid token ID"");
        // Assuming the logic to retrieve the index is implemented here.
        return uint64(_tokenId);
    }
}","[{'function': 'getTokenIndex', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PixelCon""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}, ""memberName"": ""index""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getTokenIndex', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./PixelCon.sol"";
import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract PixelConIndexer {
    using SafeMath for uint256;

    function getIndex(uint256 _tokenId) public view returns (uint256) {
        return PixelCon(_tokenId).index();
    }
}",3.1182315349578857,getIndex,"[{'function': 'getIndex', 'complexity': 0}]",1.0,8.0,0.7949854192630632,0.1992433113726454,"pragma solidity ^0.8.0;

import ""./PixelCon.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PixelConIndexer is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function getIndex(uint256 _tokenId) public view returns (uint256) {
        return PixelCon(_tokenId).index();
    }
}"
1993,Throws if ` _tokenId ` is not a valid NFT .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrappedToken is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public idToApprovals;

    function getApproved(uint256 _tokenId) public view validNFToken(_tokenId) returns (address) {
        return idToApprovals[_tokenId];
    }
}","[{'function': 'getApproved', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferNFT"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token ID""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC721""}, ""name"": ""nft"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nft""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No NFTs available for transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nft""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_tokenId""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getApproved', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC721/IERC721.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transferNFT(uint256 _tokenId, address _to) public {
        require(_tokenId > 0, ""Invalid token ID"");
        require(_to != address(0), ""Invalid recipient"");
        IERC721 nft = IERC721(msg.sender);
        uint256 balance = nft.balanceOf(address(this));
        require(balance > 0, ""No NFTs available for transfer"");
        nft.transferFrom(address(this), _to, _tokenId);
    }
}",4.568902492523193,transferNFT,"[{'function': 'transferNFT', 'complexity': 3}]",5.0,47.0,0.5298324221555498,0.0216892342846057,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC721/IERC721.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        tokenId = 1;
        toAddress = address(0x111);
        nftContract = IERC721(address(0x222));
    }

    uint256 public tokenId;
    address public toAddress;
    IERC721 public nftContract;

    function transferNFT() public {
        require(tokenId > 0, ""Invalid token ID"");
        require(toAddress != address(0), ""Invalid recipient"");
        uint256 balance = nftContract.balanceOf(address(this));
        require(balance > 0, ""No NFTs available for transfer"");
        nftContract.transferFrom(address(this), toAddress, tokenId);
    }
}"
3377,Check the total supply of the token ~ ERC-20 Standard,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 internal totalSupply_;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    constructor(uint256 totalSupply, string memory _name, string memory _symbol, uint8 _decimals) {
        totalSupply_ = totalSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() external constant returns (uint256) {
        return totalSupply_;
    }
}","[{'function': 'totalSupply', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkTotalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'totalSupply', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    function checkTotalSupply(address tokenAddress) public view returns (uint256) {
        IERC20 token = IERC20(tokenAddress);
        return token.totalSupply();
    }
}",2.153450965881348,checkTotalSupply,"[{'function': 'checkTotalSupply', 'complexity': 0}]",1.0,10.0,0.7264752841869984,0.1633647013102316,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/security/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    uint256 public totalSupply;
    address public tokenAddress;

    constructor() Ownable(msg.sender) {
        // Initialize instance variables
        totalSupply = 1000000000000000000; // Set to a fixed value (never 0)
        tokenAddress = 0x1111111111111111111111111111111111111111; // Use a fixed address value
    }

    function checkTotalSupply(address _tokenAddress) public view returns (uint256) {
        IERC20 token = IERC20(_tokenAddress);
        return token.totalSupply();
    }
}"
1589,Transfer Spork tokens from ` msg.sender ` to another account .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract ERC20 is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        if (balances[_to].add(_amount).lte(balances[_to])) return false;
        if (balances[msg.sender].lt(_amount)) return false;
        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'transfer', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'transfer', 'complexity': 0}]",3.0,"
pragma solidity ^0.8.0;

contract SporkToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    function transfer(address recipient, uint256 amount) public {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
    }
}",2.40885591506958,transfer,"[{'function': 'transfer', 'complexity': 1}]",2.0,28.0,0.8165506609269025,0.0848721634138372,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SporkToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set balance to 1 for the owner
    }

    function transfer(address recipient, uint256 amount) public {
        require(balances[msg.sender] >= amount, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
    }
}"
1356,Set value for Uint associated with bytes32 id key,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint) public uIntStorage;

    function setUint(bytes32 _key, uint _value) public onlyOwner returns (bool success) {
        require(msg.sender == owner(), ""Only the contract owner can call this function."");
        uIntStorage[_key] = _value;
        return true;
    }

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(""ROLE_PLATFORM_OPERATIVE_REPRESENTATIVE"") {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'setUint', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setValue"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""values""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}, ""right"": {""type"": ""Identifier"", ""name"": ""value""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setUint', 'complexity': 1}, {'function': 'announceFork', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint;

    mapping(bytes32 => uint) public values;

    function setValue(bytes32 id, uint value) external {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        values[id] = value;
    }
}",1.738102674484253,setValue,"[{'function': 'setValue', 'complexity': 1}]",2.0,26.0,0.2498819971815485,0.0268150439145161,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => uint) public values;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        values[bytes32('init')] = 1;
    }

    function setValue(bytes32 id, uint value) external {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        values[id] = value;
    }
}"
232,get token price in cents depending on the current date,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;
    address private constant ROLE_PLATFORM_OPERATIVE = 0x0; // Placeholder for platform operator representative role

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function getPrice() public view returns (uint) {
        for (uint i = c_priceChangeDates.length - 2; i > 0; i--) {
            if (getTime() >= c_priceChangeDates[i]) {
                return c_tokenPrices[i];
            }
        }
        return c_tokenPrices[0];
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public only(ROLE_PLATFORM_OPERATIVE) {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'getPrice', 'complexity': 3}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_date"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numDays"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""_date""}, ""right"": {""type"": ""Identifier"", ""name"": ""START_DATE""}}], ""isArray"": False}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenPrice"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""TOKEN_PRICE""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""numDays""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""tokenPrice""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getPrice', 'complexity': 3}, {'function': 'announceFork', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

contract TokenPrice {
    using SafeMath for uint256;

    // Function to get the token price in cents based on the current date
    function getTokenPrice(uint256 _date) public view returns (uint256) {
        // Calculate the number of days since the start date
        uint256 numDays = (_date - START_DATE).div(1 days);

        // Calculate the token price based on the number of days
        uint256 tokenPrice = TOKEN_PRICE.mul(numDays);

        return tokenPrice;
    }
}",2.8610143661499023,getTokenPrice,"[{'function': 'getTokenPrice', 'complexity': 0}]",1.0,34.0,0.6707163711601223,0.0849929673436453,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenPrice is Ownable {
    using SafeMath for uint256;

    // Constants
    uint256 public constant START_DATE = 1672531200; // Example start date, adjust as needed
    uint256 public constant TOKEN_PRICE = 100; // Example token price in cents, adjust as needed

    // Constructor
    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        START_DATE = 1672531200;
        TOKEN_PRICE = 100;
    }

    // Function to get the token price in cents based on the current date
    function getTokenPrice(uint256 _date) public view returns (uint256) {
        // Calculate the number of days since the start date
        uint256 numDays = (_date - START_DATE).div(1 days);

        // Calculate the token price based on the number of days
        uint256 tokenPrice = TOKEN_PRICE.mul(numDays);

        return tokenPrice;
    }
}"
5169,Set the Havven contract that the issuance controller uses to issue Havvens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HavvenWrapper is Ownable {
    using SafeMath for uint256;

    Havven public havven;

    event HavvenUpdated(Havven indexed newHavven);

    function setHavven(Havven _havven) external onlyOwner {
        havven = _havven;
        emit HavvenUpdated(_havven);
    }
}","[{'function': 'setHavven', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""issueHavvens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""havven""}, ""memberName"": ""issue""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setHavven', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./Havven.sol"";
import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract IssuanceController {
    using SafeMath for uint256;

    Havven public havven;

    constructor(address _havven) {
        havven = Havven(_havven);
    }

    function issueHavvens() external {
        havven.issue();
    }
}",2.246238946914673,issueHavvens,"[{'function': 'issueHavvens', 'complexity': 0}]",1.0,10.0,0.6689353657285565,0.065661245036134,"pragma solidity ^0.8.0;

import ""./Havven.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract IssuanceController is Ownable {
    using SafeMath for uint256;

    Havven public havven;

    constructor(address _havven) Ownable(msg.sender) {
        havven = Havven(_havven);
    }

    function issueHavvens() external {
        havven.issue();
    }
}"
277,sell new tokens during the round 0 all except logo,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public halted = false;
    mapping(address => bool) public signers;

    function setHalted(bool _halted) external onlyOwner {
        halted = _halted;
    }

    function addSigner(address signer) external onlyOwner {
        signers[signer] = true;
    }

    function removeSigner(address signer) external onlyOwner {
        signers[signer] = false;
    }

    function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    modifier notHalted() {
        require(!halted, ""Contract is halted"");
        _;
    }

    function buy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB, uint8 v, bytes32 r, bytes32 s) public notHalted() payable {
        address recoveredSigner = verify(keccak256(abi.encodePacked(msg.sender)), v, r, s);
        require(signers[recoveredSigner] == true);
        require(msg.value > 0);
        internalBuy(x, y, sizeA, sizeB);
    }

    function internalBuy(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal {
        // Implementation of the buy logic
    }
}","[{'function': 'setHalted', 'complexity': 0}, {'function': 'addSigner', 'complexity': 0}, {'function': 'removeSigner', 'complexity': 0}, {'function': 'verify', 'complexity': 0}, {'function': 'buy', 'complexity': 2}, {'function': 'internalBuy', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sellNewTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only whitelisted addresses can sell new tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""round0TokensRemaining""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient remaining tokens for sale""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenBalances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokenBalances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""round0TokensRemaining""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""round0TokensRemaining""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setHalted', 'complexity': 0}, {'function': 'addSigner', 'complexity': 0}, {'function': 'removeSigner', 'complexity': 0}, {'function': 'verify', 'complexity': 0}, {'function': 'buy', 'complexity': 2}, {'function': 'internalBuy', 'complexity': 0}]",4.0,"
pragma solidity ^0.8.0;

contract TokenSale {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public whitelist;
    mapping(address => uint256) public tokenBalances;
    uint256 public round0TokensRemaining;

    constructor() public {
        owner = msg.sender;
        round0TokensRemaining = 1000000; // 1 million tokens for round 0
    }

    function sellNewTokens(uint256 amount) external {
        require(whitelist[msg.sender], ""Only whitelisted addresses can sell new tokens"");
        require(amount <= round0TokensRemaining, ""Insufficient remaining tokens for sale"");
        tokenBalances[msg.sender] = tokenBalances[msg.sender].add(amount);
        round0TokensRemaining = round0TokensRemaining.sub(amount);
    }
}",4.41595196723938,sellNewTokens,"[{'function': 'sellNewTokens', 'complexity': 2}]",4.0,40.0,0.4527185072002895,0.0605891033679991,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public whitelist;
    mapping(address => uint256) public tokenBalances;
    uint256 public round0TokensRemaining = 1000000; // 1 million tokens for round 0

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        whitelist[owner] = true;
        tokenBalances[owner] = 0;
        round0TokensRemaining = 1000000; // 1 million tokens for round 0
    }

    function sellNewTokens(uint256 amount) external {
        require(whitelist[msg.sender], ""Only whitelisted addresses can sell new tokens"");
        require(amount <= round0TokensRemaining, ""Insufficient remaining tokens for sale"");
        tokenBalances[msg.sender] = tokenBalances[msg.sender].add(amount);
        round0TokensRemaining = round0TokensRemaining.sub(amount);
    }
}"
3181,This function is disabled during the funding .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function getState() external view returns (uint8);
    function balances(address) external view returns (uint256);
    function upgradeAgent() external view returns (address);
    event Transfer(address indexed from, address indexed to, uint256 value);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _token) {
        token = IToken(_token);
    }

    function transfer(address to, uint256 value) external returns (bool ok) {
        require(getState() == 0, ""State is not Success"");
        require(to != address(0), ""Invalid recipient address"");
        require(to != token.upgradeAgent(), ""Recipient is upgrade agent"");

        uint256 senderBalance = token.balances(msg.sender);
        if (senderBalance >= value && value > 0) {
            senderBalance = senderBalance.sub(value);
            token.balances(msg.sender) = senderBalance;
            token.balances(to) = token.balances(to).add(value);
            emit Transfer(msg.sender, to, value);
            return true;
        }
        return false;
    }

    function getState() internal view returns (uint8) {
        return token.getState();
    }
}","[{'function': 'upgradeAgent', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}, {'function': 'getState', 'complexity': 0}]",6.0,{},"[{'function': 'upgradeAgent', 'complexity': 0}, {'function': 'transfer', 'complexity': 5}, {'function': 'getState', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

contract FundingDisabled {
    function disableFunding() external {
        // Additional logic can be added here
    }
}",0.8904228210449219,disableFunding,"[{'function': 'disableFunding', 'complexity': 0}]",1.0,53.0,0.3056479355208946,2.434469472620955e-05,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract FundingDisabled {
    function disableFunding() external {
        // Additional logic can be added here
    }
}"
4086,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper {
    using SafeMath for uint256;

   function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
}

}","[{'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isOperatorAuthorized"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""contains""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_operator""}], ""names"": []}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract OperatorAuthorizer {
    using SafeMath for uint256;

    mapping(address => address[]) public operators;

    function isOperatorAuthorized(address _operator, address _owner) external view returns (bool) {
        return operators[_owner].contains(_operator);
    }
}",1.8440179824829104,isOperatorAuthorized,"[{'function': 'isOperatorAuthorized', 'complexity': 0}]",1.0,16.0,0.7570529695371493,0.3033668865762665,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract OperatorAuthorizer is Ownable {
    using SafeMath for uint256;

    mapping(address => address[]) public operators;

    function isOperatorAuthorized(address _operator, address _owner) external view returns (bool) {
        return operators[_owner].contains(_operator);
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 initialValue = 1; // Use a fixed value for uint/uint256
        address[] memory emptyArray; // Initialize an empty array for the mapping

        operators[msg.sender] = emptyArray; // Assign the empty array to the owner's operator list
    }
}"
79,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public memeIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        memeIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address _owner, uint256 _tokenId) internal view returns (bool) {
        return ownerOf(_tokenId) == _owner;
    }

    function ownerOf(uint256 _tokenId) public pure returns (address) {
        // This is a placeholder for the actual implementation of ownerOf.
        // The real implementation should be provided by the contract that inherits this wrapper.
        require(false, ""ownerOf not implemented"");
    }
}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}, {'function': 'ownerOf', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""grantOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid new owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorizedTransfer""}, ""index"": {""type"": ""Identifier"", ""name"": ""_newOwner""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}, {'function': 'ownerOf', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public authorizedTransfer;

    constructor() public {
        owner = msg.sender;
    }

    function grantOwnership(address _newOwner) external onlyOwner {
        require(_newOwner != address(0), ""Invalid new owner"");
        authorizedTransfer[_newOwner] = true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool) {
        require(authorizedTransfer[msg.sender], ""Not authorized to transfer"");
        return IERC20(_from).transferFrom(_from, _to, _amount);
    }

    function takeOwnership(address _newOwner) external onlyAuthorized {
        require(_newOwner != address(0), ""Invalid new owner"");
        authorizedTransfer[_newOwner] = true;
    }
}",6.178232908248901,grantOwnership,"[{'function': 'grantOwnership', 'complexity': 1}, {'function': 'transferFrom', 'complexity': 1}, {'function': 'takeOwnership', 'complexity': 1}]",2.0,17.0,0.5135368724544297,0.0448998685582449,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public authorizedTransfer;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    modifier onlyOwner {
        require(owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    modifier onlyAuthorized {
        require(authorizedTransfer[msg.sender], ""Not authorized to transfer"");
        _;
    }

    function grantOwnership(address _newOwner) external onlyOwner {
        require(_newOwner != address(0), ""Invalid new owner"");
        authorizedTransfer[_newOwner] = true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool) {
        require(authorizedTransfer[msg.sender], ""Not authorized to transfer"");
        return IERC20(_from).transferFrom(_from, _to, _amount);
    }

    function takeOwnership(address _newOwner) external onlyAuthorized {
        require(_newOwner != address(0), ""Invalid new owner"");
        authorizedTransfer[_newOwner] = true;
    }
}"
3424,Get the name of collection # ` ( _collectionIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollectionRegistry is Ownable {
    using SafeMath for uint256;

    uint256 public totalCollections;
    mapping(uint64 => bytes8) private collectionNames;

    modifier validIndex(uint64 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function getCollectionName(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns (bytes8) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        return collectionNames[_collectionIndex];
    }

    function setTotalCollections(uint256 newTotalCollections) public onlyOwner {
        totalCollections = newTotalCollections;
    }

    function setCollectionName(uint64 _collectionIndex, bytes8 _name) public onlyOwner validIndex(_collectionIndex) {
        collectionNames[_collectionIndex] = _name;
    }
}","[{'function': 'getCollectionName', 'complexity': 1}, {'function': 'setTotalCollections', 'complexity': 0}, {'function': 'setCollectionName', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCollectionName"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_collectionIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collections""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid collection index""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""collections""}, ""index"": {""type"": ""Identifier"", ""name"": ""_collectionIndex""}}, ""memberName"": ""name""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getCollectionName', 'complexity': 1}, {'function': 'setTotalCollections', 'complexity': 0}, {'function': 'setCollectionName', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

contract MyContract {
    struct Collection {
        string name;
        uint256 tokenCount;
    }

    mapping(uint256 => Collection) public collections;

    function getCollectionName(uint256 _collectionIndex) public view returns (string memory) {
        require(_collectionIndex < collections.length, ""Invalid collection index"");
        return collections[_collectionIndex].name;
    }
}",2.1160781383514404,getCollectionName,"[{'function': 'getCollectionName', 'complexity': 1}]",2.0,4.0,0.8759480494023151,0.2911447346289198,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct Collection {
        string name;
        uint256 tokenCount;
    }

    mapping(uint256 => Collection) public collections;

    constructor() Ownable(msg.sender) {
        for (uint256 i = 0; i < 3; i++) {
            collections[i] = Collection({name: ""initialized"", tokenCount: 1});
        }
    }

    function getCollectionName(uint256 _collectionIndex) public view returns (string memory) {
        require(_collectionIndex < 3, ""Invalid collection index"");
        return collections[_collectionIndex].name;
    }
}"
4496,This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ICOContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoEndDate;
    bool public paused = false;

    mapping(address => bool) public whitelistedAddresses;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    modifier onlyWhitelisted() {
        require(whitelistedAddresses[msg.sender], ""Caller is not whitelisted"");
        _;
    }

    function setICOEndDate(uint256 _date) public whenNotPaused onlyWhitelisted {
        icoEndDate = _date;
    }
}","[{'function': 'setICOEndDate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setICOEndDateOnce"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_newIcoEndDate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelistedApplications""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only whitelisted applications can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_newIcoEndDate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""New ICO end date must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoEndDate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newIcoEndDate""}}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setICOEndDate', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract WhitelistICO {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public whitelistedApplications;
    uint256 public icoEndDate;

    constructor() {
        owner = msg.sender;
    }

    function setICOEndDateOnce(uint256 _newIcoEndDate) external returns (bool success) {
        require(whitelistedApplications[msg.sender], ""Only whitelisted applications can call this function"");
        require(_newIcoEndDate > block.timestamp, ""New ICO end date must be in the future"");
        icoEndDate = _newIcoEndDate;
        return true;
    }
}",3.4745311737060547,setICOEndDateOnce,"[{'function': 'setICOEndDateOnce', 'complexity': 2}]",3.0,22.0,0.7662461230424596,0.013318543819033,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract WhitelistICO is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public whitelistedApplications;
    uint256 public icoEndDate;

    constructor() Ownable(msg.sender) {
        icoEndDate = block.timestamp + 1 weeks; // Set to a fixed future date
    }

    function setICOEndDateOnce(uint256 _newIcoEndDate) external returns (bool success) {
        require(whitelistedApplications[msg.sender], ""Only whitelisted applications can call this function"");
        require(_newIcoEndDate > block.timestamp, ""New ICO end date must be in the future"");
        icoEndDate = _newIcoEndDate;
        return true;
    }
}"
1334,Adding ` _backer.address ( ) ` as an early backer,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct backerData {
        uint tokenPrice;
        uint tokenAmount;
        bytes32 privatePhraseHash;
        bool claimed;
        bool redeemed;
        uint rank;
    }

    address[] public earlyBackerList;
    address[] public backersAddresses;
    mapping(address => backerData[]) public backers;
    uint public prepaidUnits;
    uint public claimedUnits;
    uint public promissoryUnits;
    uint public lastPrice;
    uint public numOfBackers;

    event AddedPrepaidTokensEvent(address indexed backer, uint indexed index, uint tokenPrice, uint tokenAmount);

    modifier founderCall() {
        require(msg.sender == owner(), ""Only the founder can call this function"");
        _;
    }

    function setPrepaid(address _backer, uint _tokenPrice, uint _tokenAmount, string memory _privatePhrase, uint _backerRank) external founderCall returns (uint) {
        require(_tokenPrice > 0 && _tokenAmount > 0);
        require(claimedUnits == 0);
        require(_tokenAmount.add(prepaidUnits).add(claimedUnits) <= promissoryUnits);
        if (earlyBackerList.length == numOfBackers && backers[_backer].length == 0) {
            earlyBackerList.push(_backer);
            backersAddresses.push(_backer);
        }
        backers[_backer].push(backerData(_tokenPrice, _tokenAmount, keccak256(abi.encodePacked(_privatePhrase, _backer)), true, false, _backerRank));
        prepaidUnits = prepaidUnits.add(_tokenAmount);
        lastPrice = _tokenPrice;
        emit AddedPrepaidTokensEvent(_backer, backers[_backer].length - 1, _tokenPrice, _tokenAmount);
        return backers[_backer].length - 1;
    }
}","[{'function': 'setPrepaid', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""addEarlyBacker"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""_backerAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isEarlyBacker""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backerAddress""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Backer already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isEarlyBacker""}, ""index"": {""type"": ""Identifier"", ""name"": ""_backerAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""backers""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Backer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_backerAddress""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": [""_backerAddress"", ""_amount""]}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPrepaid', 'complexity': 6}]",7.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract EarlyBacker {
    using SafeMath for uint256;

    struct Backer {
        address payable _backerAddress;
        uint256 _amount;
    }

    mapping(address => bool) public isEarlyBacker;
    mapping(uint256 => Backer[]) public backers;

    function addEarlyBacker(address payable _backerAddress, uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(!isEarlyBacker[_backerAddress], ""Backer already exists"");

        isEarlyBacker[_backerAddress] = true;
        backers.push(Backer({ _backerAddress: _backerAddress, _amount: _amount }));
    }
}",3.999176263809204,addEarlyBacker,"[{'function': 'addEarlyBacker', 'complexity': 3}]",3.0,76.0,0.7039195641696471,0.0281953397305689,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract EarlyBacker is Ownable {
    using SafeMath for uint256;

    struct Backer {
        address payable _backerAddress;
        uint256 _amount;
    }

    mapping(address => bool) public isEarlyBacker;
    Backer[] public backers;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables with safe, non-corner-case values
        for (uint256 i = 0; i < backers.length; i++) {
            isEarlyBacker[backers[i]._backerAddress] = true;
        }
    }

    function addEarlyBacker(address payable _backerAddress, uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(!isEarlyBacker[_backerAddress], ""Backer already exists"");

        isEarlyBacker[_backerAddress] = true;
        backers.push(Backer({ _backerAddress: _backerAddress, _amount: _amount }));
    }
}"
517,Used to intialize the variables of the contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public maxHolderPercentage;

    modifier onlyFactory() {
        require(msg.sender == factory, ""Only the factory can call this function"");
        _;
    }

    address private factory;

    constructor() {
        // Initialize the factory address in the constructor or later
    }

    function configure(uint256 _maxHolderPercentage) public onlyFactory {
        maxHolderPercentage = _maxHolderPercentage;
    }
}","[{'function': 'configure', 'complexity': 0}]",1.0,{},"[{'function': 'configure', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint256;

    // State variables
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;

    constructor() public {
        totalSupply = 1000000;
        balanceOf[msg.sender] = totalSupply;
    }
}",1.9369475841522217,,,,10.0,0.1969021489906954,0.0,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    // State variables
    uint256 public totalSupply = 1000000;
    mapping(address => uint256) public balanceOf;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        balanceOf[owner()] = totalSupply;
    }
}"
3727,Core logic of the ` decreaseApproval ` function .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20Store {
    function allowed(address _owner, address _spender) external view returns (uint256);
    function setAllowance(address _owner, address _spender, uint256 _value) external;
}

interface IERC20Proxy {
    function emitApproval(address _owner, address _spender, uint256 _value) external;
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20Store public erc20Store;
    IERC20Proxy public erc20Proxy;

    constructor(address _erc20Store, address _erc20Proxy) {
        erc20Store = IERC20Store(_erc20Store);
        erc20Proxy = IERC20Proxy(_erc20Proxy);
    }

    function decreaseApprovalWithSender(address _sender, address _spender, uint256 _subtractedValue) public onlyOwner returns (bool) {
        require(_spender != address(0));
        uint256 currentAllowance = erc20Store.allowed(_sender, _spender);
        uint256 newAllowance = currentAllowance.sub(_subtractedValue);
        require(newAllowance <= currentAllowance);
        erc20Store.setAllowance(_sender, _spender, newAllowance);
        erc20Proxy.emitApproval(_sender, _spender, newAllowance);
        return true;
    }
}","[{'function': 'setAllowance', 'complexity': 0}, {'function': 'emitApproval', 'complexity': 0}, {'function': 'decreaseApprovalWithSender', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""decreaseApproval"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""memberName"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient approval""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""memberName"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvals""}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""memberName"": ""value""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setAllowance', 'complexity': 0}, {'function': 'emitApproval', 'complexity': 0}, {'function': 'decreaseApprovalWithSender', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    struct Approval {
        address spender;
        uint256 value;
        bool approved;
    }

    mapping(address => Approval[]) public approvals;

    function decreaseApproval(address _spender, uint256 _value) external {
        require(_value <= approvals[_spender].value, ""Insufficient approval"");

        approvals[_spender].value = approvals[_spender].value.sub(_value);
    }
}",2.8966078758239746,decreaseApproval,"[{'function': 'decreaseApproval', 'complexity': 1}]",2.0,45.0,0.7964830743771473,0.034426036350874,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Approval {
        address spender;
        uint256 value;
        bool approved;
    }

    mapping(address => Approval[]) public approvals;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function decreaseApproval(address _spender, uint256 _value) external {
        require(_value <= approvals[_spender].value, ""Insufficient approval"");

        approvals[_spender].value = approvals[_spender].value.sub(_value);
    }
}"
5953,"Sets the address of another contract to handle the requests of this contract , it can be used to deprecate this Oracle","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    address public fallback;

    function setFallback(address _fallback) public onlyOwner returns (bool) {
        fallback = _fallback;
        return true;
    }
}","[{'function': 'setFallback', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setHandler"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_handler"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_handler""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid handler""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""handlerAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_handler""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setFallback', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Oracle {
    address public handlerAddress;

    function setHandler(address _handler) external {
        require(_handler != address(0), ""Invalid handler"");
        handlerAddress = _handler;
    }
}",1.1834139823913574,setHandler,"[{'function': 'setHandler', 'complexity': 1}]",2.0,18.0,0.4376091523136493,0.0233337846583118,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Oracle {
    address public handlerAddress;
    bool public initialized;
    bytes32 public initBytes;

    constructor() {
        handlerAddress = 0x1111111111111111111111111111111111111111; // Replace with actual address
        initialized = true;
        initBytes = bytes32('init');
    }

    function setHandler(address _handler) external {
        require(_handler != address(0), ""Invalid handler"");
        handlerAddress = _handler;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Oracle is Ownable(msg.sender) {}"
6776,Sends fees to the request burning address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public requestBurnerContract;

    constructor(address _requestBurnerContract) {
        requestBurnerContract = _requestBurnerContract;
    }

    function collectForREQBurning(uint256 _amount) internal {
        require(_amount > 0, ""Amount must be greater than zero"");
        (bool success, ) = requestBurnerContract.call{value: _amount}("""");
        require(success, ""Transfer failed"");
    }
}","[{'function': 'collectForREQBurning', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""burnFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""requestBurningAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0x1234567890123456789012345678901234567890"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""feesToBurn"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""requestBurningAddress""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""feesToBurn""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'collectForREQBurning', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract FeeBurner {
    using SafeMath for uint256;

    function burnFees(uint256 amount) public {
        address requestBurningAddress = 0x1234567890123456789012345678901234567890;

        uint256 feesToBurn = amount.mul(10); // 10% of the total amount
        requestBurningAddress.transfer(feesToBurn);
    }
}",3.0046427249908447,burnFees,"[{'function': 'burnFees', 'complexity': 0}]",1.0,21.0,0.7050939818691437,0.0310039884425276,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract has an appropriate constructor for msg.sender

contract FeeBurner is Ownable {
    using SafeMath for uint256;

    function burnFees(uint256 amount) public onlyOwner {
        address requestBurningAddress = 0x1234567890123456789012345678901234567890;

        uint256 feesToBurn = amount.mul(10); // 10% of the total amount
        requestBurningAddress.transfer(feesToBurn);
    }
}"
1286,Verifies a broker 's signature for an order opening .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public brokers;

    function verifyOpenSignature(address _trader, bytes memory _signature, bytes32 _orderID) external view returns (bool) {
        bytes memory data = abi.encodePacked(""Republic Protocol: open: "", _trader, _orderID);
        address signer = Utils.addr(data, _signature);
        return brokers[signer];
    }
}","[{'function': 'verifyOpenSignature', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""verifyBrokerSignature"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""orderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""brokerAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""signature"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""messageHash"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""orderId""}, {""type"": ""Identifier"", ""name"": ""brokerAddress""}], ""names"": []}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""recoverSigner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""messageHash""}, {""type"": ""Identifier"", ""name"": ""signature""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""brokerAddress""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'verifyOpenSignature', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract BrokerSignature {
    using SafeMath for uint256;

    function verifyBrokerSignature(uint256 orderId, address brokerAddress, bytes32 signature) public view returns (bool) {
        // Get the message hash to be signed by the broker
        bytes32 messageHash = keccak256(abi.encodePacked(orderId, brokerAddress));

        // Verify the signature using the broker's address and the message hash
        return recoverSigner(messageHash, signature) == brokerAddress;
    }

    function recoverSigner(bytes32 messageHash, bytes32 signature) public view returns (address) {
        // Recover the signer's address from the signature and message hash
        return ecrecover(messageHash, signature);
    }
}",4.016294002532959,verifyBrokerSignature,"[{'function': 'verifyBrokerSignature', 'complexity': 0}, {'function': 'recoverSigner', 'complexity': 0}]",2.0,10.0,0.7260686382996135,0.1102418310605768,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract BrokerSignature is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function verifyBrokerSignature(uint256 orderId, address brokerAddress, bytes32 signature) public view returns (bool) {
        // Get the message hash to be signed by the broker
        bytes32 messageHash = keccak256(abi.encodePacked(orderId, brokerAddress));

        // Verify the signature using the broker's address and the message hash
        return recoverSigner(messageHash, signature) == brokerAddress;
    }

    function recoverSigner(bytes32 messageHash, bytes32 signature) public view returns (address) {
        // Recover the signer's address from the signature and message hash
        return ecrecover(messageHash, signature);
    }
}"
5432,Set the minimum required havven balance to have standing to bring a motion .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public minStandingBalance;

    function setMinStandingBalance(uint balance) external onlyOwner {
        minStandingBalance = balance;
    }
}","[{'function': 'setMinStandingBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""vote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minHavvenBalance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""havvenBalanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""gte""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_minHavvenBalance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Insufficient havven balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setMinStandingBalance', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract MotionVoter {
    using SafeMath for uint256;

    function vote(uint256 _minHavvenBalance) public {
        require(havvenBalanceOf(msg.sender).gte(_minHavvenBalance), ""Insufficient havven balance"");

        // Additional logic can be added here
    }

    function havvenBalanceOf(address _account) public view returns (uint256) {
        return 0;
    }
}",2.482387065887451,vote,"[{'function': 'vote', 'complexity': 1}, {'function': 'havvenBalanceOf', 'complexity': 0}]",2.0,9.0,0.5740552252680563,0.0087243839453406,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MotionVoter is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        minHavvenBalance = 1;
        havvenBalanceMap[address(0x111)] = 1;
        havvenBalanceMap[address(0x222)] = 1;
        havvenBalanceMap[address(0x333)] = 1;
    }

    uint256 public minHavvenBalance;
    mapping(address => uint256) public havvenBalanceMap;

    function vote(uint256 _minHavvenBalance) public {
        require(havvenBalanceOf(msg.sender).gte(_minHavvenBalance), ""Insufficient havven balance"");
    }

    function havvenBalanceOf(address _account) public view returns (uint256) {
        return havvenBalanceMap[_account];
    }
}"
6260,"Opens a new channel or tops up an existing one , compatibility with ERC 223 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token;
    mapping(address => bool) public trusted_contracts;

    constructor(address _token, address[] memory _trustedContracts) {
        require(_token != address(0), ""Invalid token address"");
        token = _token;
        for (uint i = 0; i < _trustedContracts.length; i++) {
            trusted_contracts[_trustedContracts[i]] = true;
        }
    }

    function createChannelPrivate(address _sender, address _receiver, uint256 _deposit) internal virtual;

    function updateInternalBalanceStructs(address _sender, address _receiver, uint32 _openBlockNumber, uint256 _deposit) internal virtual;

    function tokenFallback(address _sender_address, uint256 _deposit, bytes memory _data) external {
        require(msg.sender == token, ""Sender must be the token contract"");
        require(_deposit <= type(uint192).max, ""Deposit exceeds uint192 limit"");
        uint256 deposit = uint256(_deposit);
        require(deposit == _deposit, ""Deposit conversion overflow"");

        uint256 length = _data.length;
        require(length == 40 || length == 44, ""Invalid data length"");

        address channel_sender_address = addressFromBytes(_data, 0x20);
        require(_sender_address == channel_sender_address || trusted_contracts[_sender_address], ""Unauthorized sender"");

        address channel_receiver_address = addressFromBytes(_data, 0x34);
        if (length == 40) {
            createChannelPrivate(channel_sender_address, channel_receiver_address, deposit);
        } else {
            uint32 open_block_number = uint32(blockNumberFromBytes(_data, 0x48));
            updateInternalBalanceStructs(channel_sender_address, channel_receiver_address, open_block_number, deposit);
        }
    }

    function addressFromBytes(bytes memory _data, uint256 offset) internal pure returns (address addr) {
        assembly {
            addr := mload(add(_data, add(0x20, offset)))
        }
    }

    function blockNumberFromBytes(bytes memory _data, uint256 offset) internal pure returns (uint32 block_number) {
        assembly {
            block_number := mload(add(_data, add(0x48, offset)))
        }
    }
}","[{'function': 'createChannelPrivate', 'complexity': 0}, {'function': 'updateInternalBalanceStructs', 'complexity': 0}, {'function': 'tokenFallback', 'complexity': 8}, {'function': 'addressFromBytes', 'complexity': 0}, {'function': 'blockNumberFromBytes', 'complexity': 0}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""openChannel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createChannelPrivate', 'complexity': 0}, {'function': 'updateInternalBalanceStructs', 'complexity': 0}, {'function': 'tokenFallback', 'complexity': 8}, {'function': 'addressFromBytes', 'complexity': 0}, {'function': 'blockNumberFromBytes', 'complexity': 0}]",9.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Channel {
    using SafeMath for uint256;

    function openChannel(uint256 amount) public returns (bool) {
        // Additional logic can be added here
        return true;
    }

    function topUpChannel(uint256 amount) public returns (bool) {
        // Additional logic can be added here
        return true;
    }
}",2.159262180328369,openChannel,"[{'function': 'openChannel', 'complexity': 0}, {'function': 'topUpChannel', 'complexity': 0}]",1.0,95.0,0.3871749348313189,5.049442060576691e-05,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for OpenZeppelin's Ownable contract

contract Channel is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        channelBalance = 1; // uint256: Set to 1 (never 0)
        ownerAddress = address(uint160(1)); // address: Use fixed value 0x1111111111111111111111111111111111111111
        isActive = true; // bool: Set to true
    }

    uint256 public channelBalance;
    address public ownerAddress;
    bool public isActive;

    function openChannel(uint256 amount) public returns (bool) {
        // Additional logic can be added here
        return true;
    }

    function topUpChannel(uint256 amount) public returns (bool) {
        // Additional logic can be added here
        return true;
    }
}"
3890,Transfers ETH according to the data held within the specified payment id ( internal function ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LiquidPledging {
    function confirmPayment(uint64, uint256) external;
}

struct Payment {
    uint256 amount;
    address dest;
    uint64 ref;
    PaymentStatus state;
}

enum PaymentStatus { Pending, Paid }

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    LiquidPledging public liquidPledging;
    Payment[] public payments;

    event ConfirmPayment(uint256 indexed idPayment, uint64 ref);

    function doConfirmPayment(uint256 _idPayment) external onlyOwner {
        require(_idPayment < payments.length);
        Payment storage p = payments[_idPayment];
        require(p.state == PaymentStatus.Pending);
        p.state = PaymentStatus.Paid;
        liquidPledging.confirmPayment(uint64(p.ref), p.amount);
        payable(p.dest).transfer(p.amount);
        emit ConfirmPayment(_idPayment, p.ref);
    }
}","[{'function': 'confirmPayment', 'complexity': 0}, {'function': 'doConfirmPayment', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferETH"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""paymentId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""paymentId""}}, ""memberName"": ""recipient""}, ""right"": {""type"": ""Identifier"", ""name"": ""recipient""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""paymentId""}}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid payment data""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""Identifier"", ""name"": ""paymentId""}}, ""memberName"": ""recipient""}}, {""type"": ""stringLiteral"", ""value"": ""Only the recipient can transfer ETH""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'confirmPayment', 'complexity': 0}, {'function': 'doConfirmPayment', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;

contract Payment {
    using SafeMath for uint256;

    struct PaymentData {
        address recipient;
        uint256 amount;
    }

    mapping(uint256 => PaymentData) public payments;

    function transferETH(uint256 paymentId, address recipient, uint256 amount) internal {
        require(payments[paymentId].recipient == recipient && payments[paymentId].amount == amount, ""Invalid payment data"");
        require(msg.sender == payments[paymentId].recipient, ""Only the recipient can transfer ETH"");
        require(SafeMath.sub(address(this).balance, amount) >= 0, ""Insufficient balance"");
        address(this).transfer(amount);
    }
}",3.793959379196167,transferETH,"[{'function': 'transferETH', 'complexity': 4}]",5.0,45.0,0.5804668720309089,0.0447480695767102,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Payment is Ownable {
    using SafeMath for uint256;

    struct PaymentData {
        address recipient;
        uint256 amount;
    }

    mapping(uint256 => PaymentData) public payments;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            payments[i] = PaymentData({recipient: addr, amount: 1});
        }
    }

    function transferETH(uint256 paymentId, address recipient, uint256 amount) internal {
        require(payments[paymentId].recipient == recipient && payments[paymentId].amount == amount, ""Invalid payment data"");
        require(msg.sender == payments[paymentId].recipient, ""Only the recipient can transfer ETH"");
        require(SafeMath.sub(address(this).balance, amount) >= 0, ""Insufficient balance"");
        address(this).transfer(amount);
    }
}"
3719,only the admin is allowed to change the admin .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public admin;

    event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);

    modifier validate_address(address addr) {
        require(addr != address(0), ""Invalid address"");
        _;
    }

    function changeAdmin(address newAdmin) public validate_address(newAdmin) onlyOwner {
        if (admin == newAdmin) revert();
        emit AdminOwnershipTransferred(admin, newAdmin);
        admin = newAdmin;
    }
}","[{'function': 'changeAdmin', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_admin""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, {""type"": ""stringLiteral"", ""value"": ""Only the admin can change the admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_admin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newAdmin""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changeAdmin', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;
contract MyContract {
    address private _admin;

    constructor() public {
        _admin = msg.sender;
    }

    function setAdmin(address newAdmin) external {
        require(_admin == msg.sender, ""Only the admin can change the admin"");
        _admin = newAdmin;
    }
}",1.6326634883880615,setAdmin,"[{'function': 'setAdmin', 'complexity': 1}]",2.0,11.0,0.7871436203709864,0.1183147809279039,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address private _admin;

    constructor() Ownable(msg.sender) {
        _admin = msg.sender;
    }

    function setAdmin(address newAdmin) external onlyOwner {
        require(_admin == msg.sender, ""Only the admin can change the admin"");
        _admin = newAdmin;
    }
}"
4898,Announces intent to withdraw tokens using ` slowWithdraw `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AnnounceWithdrawalWrapper is Ownable {
    using SafeMath for uint256;

    struct AnnouncedWithdrawal {
        uint256 canWithdrawAt;
        uint256 amount;
    }

    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;
    uint256 public withdrawAnnounceDelay;

    constructor(uint256 _withdrawAnnounceDelay) {
        withdrawAnnounceDelay = _withdrawAnnounceDelay;
    }

    function announceWithdraw(address _token, uint256 _amount) external onlyOwner {
        require(_amount <= balances[msg.sender][_token], ""Amount too high"");
        AnnouncedWithdrawal storage announcement = announcedWithdrawals[msg.sender][_token];
        uint256 canWithdrawAt = block.timestamp + withdrawAnnounceDelay;
        announcement.canWithdrawAt = canWithdrawAt;
        announcement.amount = _amount;
        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);
    }
}","[{'function': 'announceWithdraw', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""slowWithdraw"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""fee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""amountWithFee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""fee""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amountWithFee""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'announceWithdraw', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.2/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.2/contracts/utils/math/SafeMath.sol"";

contract Withdrawal {
    using SafeMath for uint;

    function slowWithdraw(address _tokenAddress, uint _amount) public returns (bool) {
        IERC20 token = IERC20(_tokenAddress);

        require(token.balanceOf(msg.sender) >= _amount, ""Insufficient balance"");

        uint fee = _amount.div(10); // 10% fee
        uint amountWithFee = _amount + fee;

        token.transferFrom(address(this), msg.sender, amountWithFee);

        return true;
    }
}",4.80664849281311,slowWithdraw,"[{'function': 'slowWithdraw', 'complexity': 1}]",2.0,34.0,0.7206420089965402,0.0178853419159794,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.2/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.2/contracts/utils/math/SafeMath.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.2/contracts/access/Ownable.sol"";

contract Withdrawal is Ownable {
    using SafeMath for uint;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function slowWithdraw(address _tokenAddress, uint _amount) public returns (bool) {
        IERC20 token = IERC20(_tokenAddress);

        require(token.balanceOf(msg.sender) >= _amount, ""Insufficient balance"");

        uint fee = _amount.div(10); // 10% fee
        uint amountWithFee = _amount + fee;

        token.transferFrom(address(this), msg.sender, amountWithFee);

        return true;
    }
}"
2359,Count the number of attribute types defined by the registry .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeCounter {
    using SafeMath for uint256;

    uint256[] private _attributeTypes;

    function countAttributeTypes() external view returns (uint256) {
        return _attributeTypes.length;
    }
}","[{'function': 'countAttributeTypes', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""div"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""a"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""b"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""b""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""c"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""a""}, ""right"": {""type"": ""Identifier"", ""name"": ""b""}}}, {""type"": ""Identifier"", ""name"": ""c""}]}, ""visibility"": ""internal"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'countAttributeTypes', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
return a * b;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
require(b > 0);
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
return a + b;
}
}
contract Registry {
using SafeMath for uint256;
struct AttributeType {
uint16 id;
string name;
uint8 numAttributes;
}
AttributeType[] public attributeTypes;
function countAttributeTypes() external view returns (uint256) {
return attributeTypes.length;
}
}",4.62225866317749,div,"[{'function': 'mul', 'complexity': 0}, {'function': 'div', 'complexity': 1}, {'function': 'sub', 'complexity': 1}, {'function': 'add', 'complexity': 0}, {'function': 'countAttributeTypes', 'complexity': 0}]",2.0,16.0,0.3368486052022271,0.1291353307547038,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        uint256 c = a / b;
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Registry is Ownable {
    using SafeMath for uint256;

    struct AttributeType {
        uint16 id;
        string name;
        uint8 numAttributes;
    }

    AttributeType[] public attributeTypes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        attributeTypes = [AttributeType({id: 1, name: ""initialized"", numAttributes: 0})];
    }

    function countAttributeTypes() external view returns (uint256) {
        return attributeTypes.length;
    }
}"
239,Register a new child universe after a fork,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IUniverse {
    function getWinningChildUniverse() external view returns (address);
}

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'getWinningChildUniverse', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerChildUniverse"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_parent"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_parent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Parent universe cannot be zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""child"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ChildUniverse""}}, ""arguments"": [], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Fork""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_parent""}, {""type"": ""Identifier"", ""name"": ""child""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getWinningChildUniverse', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

contract ChildUniverse {
    using SafeMath for uint256;

    event Fork(address indexed _parent, address indexed _child);

    function registerChildUniverse(address _parent) public {
        require(_parent != address(0), ""Parent universe cannot be zero"");
        address child = new ChildUniverse();
        emit Fork(_parent, child);
    }
}",1.916825532913208,registerChildUniverse,"[{'function': 'registerChildUniverse', 'complexity': 1}]",2.0,26.0,0.4544130719428889,0.0460301708102763,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ChildUniverse is Ownable {
    using SafeMath for uint256;

    event Fork(address indexed _parent, address indexed _child);

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function registerChildUniverse(address _parent) public {
        require(_parent != address(0), ""Parent universe cannot be zero"");
        address child = new ChildUniverse();
        emit Fork(_parent, child);
    }
}"
4301,` callPlugins ` calls ` callPluginsPledge ` once for the transfer context and once for the receiving context .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function callPlugins(bool before, uint64 fromPledge, uint64 toPledge, uint amount) internal returns (uint allowedAmount) {
        allowedAmount = amount;
        allowedAmount = callPluginsPledge(before, fromPledge, fromPledge, toPledge, allowedAmount);
        allowedAmount = callPluginsPledge(before, toPledge, fromPledge, toPledge, allowedAmount);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'callPlugins', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""callPlugins"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""PluginContext""}, ""name"": ""context"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""callPluginsPledge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""context""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""callPluginsPledge""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""context""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'callPlugins', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract PluginCaller {
    using SafeMath for uint256;

    struct PluginContext {
        address sender;
        address receiver;
        uint256 amount;
    }

    function callPlugins(PluginContext memory context) public {
        // Call plugin functions once for the transfer context and once for the receiving context
        callPluginsPledge(context, true);
        callPluginsPledge(context, false);
    }

    function callPluginsPledge(PluginContext memory context, bool isTransfer) private {
        // Additional logic can be added here to handle plugin functions for the transfer and receiving contexts
    }
}",7.41900897026062,callPlugins,"[{'function': 'callPlugins', 'complexity': 0}, {'function': 'callPluginsPledge', 'complexity': 0}]",1.0,28.0,0.3144099219388764,0.0331495702013991,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PluginCaller is Ownable {
    using SafeMath for uint256;

    struct PluginContext {
        address sender;
        address receiver;
        uint256 amount;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function callPlugins(PluginContext memory context) public {
        // Call plugin functions once for the transfer context and once for the receiving context
        callPluginsPledge(context, true);
        callPluginsPledge(context, false);
    }

    function callPluginsPledge(PluginContext memory context, bool isTransfer) private {
        // Additional logic can be added here to handle plugin functions for the transfer and receiving contexts
    }
}"
2476,Remove ` _value ` tokens from the system irreversibly,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function burn(uint256 _value) external returns (bool success);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Burn(address indexed from, uint256 value);

    function burn(uint256 _value) external returns (bool success) {
        require(balanceOf[msg.sender] >= _value, ""Insufficient balance"");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }
}","[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Value must be greater than zero""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    function removeTokens(uint256 _value) public {
        require(_value > 0, ""Value must be greater than zero"");
        // Additional logic can be added here
    }
}",1.6452693939208984,removeTokens,"[{'function': 'removeTokens', 'complexity': 1}]",2.0,34.0,0.465193723265487,0.0783346145125245,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract Token is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _value = 1; // For uint256
        ownerAddress = msg.sender; // Address initialized to the deployer's address
        isInitialized = true; // bool set to true
        tokenName = ""MyToken""; // string set to 'initialized' for ERC20-like placeholders
        initBytes32 = bytes32('init'); // bytes32 set to bytes32('init')
    }

    uint256 private _value;
    address private ownerAddress;
    bool private isInitialized;
    string private tokenName;
    bytes32 private initBytes32;

    function removeTokens(uint256 _value) public {
        require(_value > 0, ""Value must be greater than zero"");
        // Additional logic can be added here
    }
}"
2621,Only registrations in future can be removed .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function unregister(
        bytes32 _key,
        address _address,
        uint _timestamp,
        uint _gasLimit,
        uint _gasPrice
    ) external returns (uint) {
        // Function body here
    }
}","[{'function': 'unregister', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeRegistration"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""registrationId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registrations""}, ""index"": {""type"": ""Identifier"", ""name"": ""registrationId""}}, ""memberName"": ""registrant""}}, {""type"": ""stringLiteral"", ""value"": ""Only the registrant can remove their own registration""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""registrations""}, ""index"": {""type"": ""Identifier"", ""name"": ""registrationId""}}, ""isPrefix"": True}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'unregister', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract Registration {
    using SafeMath for uint256;

    struct Registration {
        address registrant;
        bytes32 registrationId;
        uint256 timestamp;
    }

    mapping(bytes32 => Registration) public registrations;

    function removeRegistration(bytes32 registrationId) external {
        require(msg.sender == registrations[registrationId].registrant, ""Only the registrant can remove their own registration"");
        delete registrations[registrationId];
    }
}",3.077592134475708,removeRegistration,"[{'function': 'removeRegistration', 'complexity': 1}]",2.0,21.0,0.6005042543517065,0.0243761686899539,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Registration is Ownable {
    using SafeMath for uint256;

    struct Registration {
        address registrant;
        bytes32 registrationId;
        uint256 timestamp;
    }

    mapping(bytes32 => Registration) public registrations;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function removeRegistration(bytes32 registrationId) external {
        require(msg.sender == registrations[registrationId].registrant, ""Only the registrant can remove their own registration"");
        delete registrations[registrationId];
    }
}"
2632,the goal the campaign must reach in order for it to succeed,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Crowdfunding {
    using SafeMath for uint256;

    uint256 public totalAmountRaised;

    function amountRaised() public view returns (uint256) {
        return totalAmountRaised;
    }
}","[{'function': 'amountRaised', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkGoalReached"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_goal"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalDonations"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""donors""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""totalDonations""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""donors""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""amount""}}}]}}, {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""totalDonations""}, ""right"": {""type"": ""Identifier"", ""name"": ""_goal""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'amountRaised', 'complexity': 0}]",1.0,"
function checkGoalReached(uint256 _goal) public view returns (bool) {
    uint256 totalDonations = 0;
    for (uint i = 0; i < donors.length; i++) {
        totalDonations += donors[i].amount;
    }
    return totalDonations >= _goal;
}",1.5205364227294922,checkGoalReached,"[{'function': 'checkGoalReached', 'complexity': 1}]",4.0,28.0,0.4659728279821757,0.124963151764966,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DonationContract is Ownable {
    uint256 public constant GOAL = 100 ether; // Fixed goal value
    address[] public donors;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        goal = GOAL;
        for (uint i = 0; i < 3; i++) {
            if (i == 0) addressDonors[address(this)] = Donor({amount: 1 ether, index: i});
            else if (i == 1) addressDonors[msg.sender] = Donor({amount: 2 ether, index: i});
            else if (i == 2) addressDonors[0x3333333333333333333333333333333333333333] = Donor({amount: 3 ether, index: i});
        }
    }

    struct Donor {
        uint256 amount;
        uint256 index;
    }

    mapping(address => Donor) public addressDonors;
    uint256 public goal;

    function checkGoalReached(uint256 _goal) public view returns (bool) {
        uint256 totalDonations = 0;
        for (uint i = 0; i < donors.length; i++) {
            totalDonations += addressDonors[donors[i]].amount;
        }
        return totalDonations >= _goal;
    }
}"
827,approving image to be taken from specific address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract MarketplaceWrapper is Ownable {
    using SafeMath for uint256;

    address public marketplaceContract;

    constructor(address _marketplaceContract) {
        require(_marketplaceContract != address(0), ""Invalid marketplace contract address"");
        marketplaceContract = _marketplaceContract;
    }

    function transferFromMarketplace(address _from, address _to, uint256 _imageId) public onlyOwner {
        require(msg.sender == marketplaceContract, ""Only the marketplace contract can call this function"");
        require(isApprovedOrOwner(_from, _imageId), ""The token is not approved or owned by the sender"");
        clearApproval(_from, _imageId);
        removeTokenFrom(_from, _imageId);
        addTokenTo(_to, _imageId);
        emit Transfer(_from, _to, _imageId);
    }
}","[{'function': 'transferFromMarketplace', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveImage"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_description"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""images""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""approved""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Image already approved""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Image""}, ""name"": ""image"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Image""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_name""}, {""type"": ""Identifier"", ""name"": ""_description""}, {""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""BooleanLiteral"", ""value"": True}], ""names"": [""name"", ""description"", ""owner"", ""approved""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""images""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""image""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFromMarketplace', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

contract ApproveImage {
    using SafeMath for uint256;

    struct Image {
        string name;
        string description;
        address owner;
        bool approved;
    }

    mapping(address => Image[]) public images;

    function approveImage(string memory _name, string memory _description, address _owner) public {
        require(_owner != address(0), ""Invalid owner"");
        require(!images[_owner].approved, ""Image already approved"");

        Image memory image = Image({
            name: _name,
            description: _description,
            owner: _owner,
            approved: true
        });

        images[_owner].push(image);
    }
}",3.277673482894897,approveImage,"[{'function': 'approveImage', 'complexity': 3}]",3.0,26.0,0.4629953596757233,0.0746348689543641,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ApproveImage is Ownable {
    using SafeMath for uint256;

    struct Image {
        string name;
        string description;
        address owner;
        bool approved;
    }

    mapping(address => Image[]) public images;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function approveImage(string memory _name, string memory _description, address _owner) public {
        require(_owner != address(0), ""Invalid owner"");
        require(!images[_owner].approved, ""Image already approved"");

        Image memory image = Image({
            name: _name,
            description: _description,
            owner: _owner,
            approved: true
        });

        images[_owner].push(image);
    }
}"
3458,"http : //solidity.readthedocs.io/en/develop/contracts.html # fallback-function we dont need recieve ETH always , only in State.Sale from externally accounts .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum State { Sale, Paused }
    State public currentState = State.Sale;

    function byTokens() internal view virtual;

    modifier atState(State state) {
        require(currentState == state, ""Not in the correct state"");
        _;
    }

    function () external payable atState(State.Sale) {
        byTokens();
    }
}","[{'function': 'byTokens', 'complexity': 0}, {'function': '', 'complexity': 0}]",2.0,{},"[{'function': 'byTokens', 'complexity': 0}, {'function': '', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    enum State {
        Sale,
        Other
    }

    function fallback() external payable {
        require(msg.sender == address(this), ""Only the contract itself can call this function"");
        require(State.Sale == state, ""The contract is not in sale mode"");
        require(msg.value > 0, ""Invalid value sent"");

        // Additional logic can be added here
    }
}",8.744632959365845,fallback,"[{'function': 'fallback', 'complexity': 3}]",4.0,,0.6038770526942037,0.0577310305702891,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/SafeMath.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    enum State {
        Sale,
        Other
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        state = State.Sale;
        address1 = address(0x111);
        address2 = address(0x222);
        address3 = address(0x333);
    }

    function fallback() external payable {
        require(msg.sender == address(this), ""Only the contract itself can call this function"");
        require(State.Sale == state, ""The contract is not in sale mode"");
        require(msg.value > 0, ""Invalid value sent"");

        // Additional logic can be added here
    }
}"
5648,Creates a checkpoint that can be used to query historical balances / totalSuppy,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CheckpointModule is Ownable {
    using SafeMath for uint256;

    event LogCheckpointCreated(uint256 indexed checkpointId, uint256 timestamp);

    uint256 public currentCheckpointId = 0;
    constanst CHECKPOINT_KEY = bytes32(""CHECKPOINT_KEY"");

    modifier onlyModule(bytes32 moduleKey, bool allowed) {
        require(moduleKey == CHECKPOINT_KEY && allowed, ""Only the module can call this function."");
        _;
    }

    function createCheckpoint() public onlyModule(CHECKPOINT_KEY, true) returns (uint256) {
        require(currentCheckpointId < type(uint256).max.sub(1));
        currentCheckpointId = currentCheckpointId.add(1);
        emit LogCheckpointCreated(currentCheckpointId, block.timestamp);
        return currentCheckpointId;
    }
}","[{'function': 'createCheckpoint', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createCheckpoint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_totalSupply"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Owner cannot be 0x0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Balance must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Total supply must be greater than 0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""checkpoints""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_balance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""checkpoints""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""totalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""_totalSupply""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""checkpoints""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createCheckpoint', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Checkpoint {
    using SafeMath for uint256;

    struct CheckpointData {
        uint256 balance;
        uint256 totalSupply;
        uint256 timestamp;
    }

    mapping(address => CheckpointData) public checkpoints;

    function createCheckpoint(address _owner, uint256 _balance, uint256 _totalSupply) public {
        require(_owner != address(0), ""Owner cannot be 0x0"");
        require(_balance > 0, ""Balance must be greater than 0"");
        require(_totalSupply > 0, ""Total supply must be greater than 0"");

        checkpoints[_owner].balance = _balance;
        checkpoints[_owner].totalSupply = _totalSupply;
        checkpoints[_owner].timestamp = block.timestamp;
    }
}",4.308655023574829,createCheckpoint,"[{'function': 'createCheckpoint', 'complexity': 3}]",4.0,40.0,0.6889984060188556,0.0374388546586133,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract Checkpoint is Ownable {
    using SafeMath for uint256;

    struct CheckpointData {
        uint256 balance;
        uint256 totalSupply;
        uint256 timestamp;
    }

    mapping(address => CheckpointData) public checkpoints;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables as per the rules provided:
        // - uint/uint256: Set to 1 (never 0)
        // - address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // - bool: Set to true
        // - string: Set to 'initialized'
        // - bytes32: Set to bytes32('init')
        checkpoints[address(0x111)] = CheckpointData({balance: 1, totalSupply: 1, timestamp: uint256(bytes32('init'))});
        checkpoints[address(0x222)] = CheckpointData({balance: 1, totalSupply: 1, timestamp: uint256(bytes32('init'))});
        checkpoints[address(0x333)] = CheckpointData({balance: 1, totalSupply: 1, timestamp: uint256(bytes32('init'))});
    }

    function createCheckpoint(address _owner, uint256 _balance, uint256 _totalSupply) public {
        require(_owner != address(0), ""Owner cannot be 0x0"");
        require(_balance > 0, ""Balance must be greater than 0"");
        require(_totalSupply > 0, ""Total supply must be greater than 0"");

        checkpoints[_owner].balance = _balance;
        checkpoints[_owner].totalSupply = _totalSupply;
        checkpoints[_owner].timestamp = block.timestamp;
    }
}"
5200,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {
        require(_from != address(0), ""Invalid sender address"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_value > 0, ""Invalid value"");
        require(msg.sender == _from || msg.sender == _to, ""Only the sender or recipient can call this function"");

        uint256 fromBalance = balanceOf[_from];
        require(_value <= fromBalance, ""Insufficient funds"");
        balanceOf[_from] = fromBalance.sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        emit Transfer(_from, _to, _value);

        return true;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 6}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 6}]",7.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_value <= IERC20(msg.sender).balanceOf(_from), ""Insufficient balance"");
        require(_value <= IERC20(msg.sender).allowance(_from, address(this)), ""Insufficient allowance"");
        IERC20(msg.sender).transferFrom(_from, _to, _value);
        return true;
    }
}",6.975536823272705,transferFrom,"[{'function': 'transferFrom', 'complexity': 2}]",3.0,64.0,0.8859274393389717,0.2583098138561661,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        uint256 public constant INITIAL_VALUE = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        address public constant ADDRESS_ONE = address(0x111);
        address public constant ADDRESS_TWO = address(0x222);
        address public constant ADDRESS_THREE = address(0x333);

        // bool: Set to true
        bool public initialized = true;

        // string: Set to 'initialized'
        string public constant INITIALIZED_STRING = ""initialized"";

        // bytes32: Set to bytes32('init')
        bytes32 public constant INIT_BYTES32 = keccak256(abi.encodePacked(""init""));
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_value <= IERC20(msg.sender).balanceOf(_from), ""Insufficient balance"");
        require(_value <= IERC20(msg.sender).allowance(_from, address(this)), ""Insufficient allowance"");
        IERC20(msg.sender).transferFrom(_from, _to, _value);
        return true;
    }
}"
5602,Allows the owner to destroy the contract and return the tokens to the owner .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Destroyer is Ownable {
    using SafeMath for IERC20;
    IERC20 public token;

    constructor(address _token) {
        token = IERC20(_token);
    }

    function destroy() public onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(balance > 0, ""No tokens to transfer"");
        token.transfer(owner(), balance);
        selfdestruct(payable(owner()));
    }
}","[{'function': 'destroy', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'destroy', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract Destructible {
    address private _owner;
    mapping(address => uint256) public balances;

    constructor() {
        _owner = msg.sender;
    }

    function destroyContract() external onlyOwner {
        selfdestruct(payable(_owner));
    }
}",1.5762507915496826,destroyContract,"[{'function': 'destroyContract', 'complexity': 0}]",1.0,24.0,0.8057580174069228,0.0443694862512599,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Destructible is Ownable {
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        _owner = msg.sender;
        balances[msg.sender] = 1000; // Initialize balance for the owner to 1
    }

    function destroyContract() external onlyOwner {
        selfdestruct(payable(_owner));
    }
}"
1932,Called to obtain the loyalty reward balance of any given member,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    struct Member {
        uint256 startOfLoyaltyRewardEligibility;
        uint256 stakeBalance;
        uint256 previouslyAppliedLoyaltyBalance;
    }

    mapping(address => Member) public members;
    uint256 public loyaltyPeriodDays;
    uint256 public loyaltyRewardAmount;

    function getLoyaltyRewardBalance(address memberAddress) public view returns (uint256 loyaltyReward) {
        require(members[memberAddress].startOfLoyaltyRewardEligibility != 0, ""Member not eligible for loyalty rewards"");
        uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days;
        Member storage thisMember = members[memberAddress];
        uint256 elapsedTimeSinceEligible = block.timestamp - thisMember.startOfLoyaltyRewardEligibility;
        loyaltyReward = thisMember.previouslyAppliedLoyaltyBalance;
        if (elapsedTimeSinceEligible >= loyaltyPeriodSeconds) {
            uint256 numWholePeriods = elapsedTimeSinceEligible / loyaltyPeriodSeconds;
            uint256 rewardForEachPeriod = thisMember.stakeBalance * loyaltyRewardAmount / 100;
            loyaltyReward += rewardForEachPeriod * numWholePeriods;
        }
    }
}","[{'function': 'getLoyaltyRewardBalance', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLoyaltyRewardBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_member"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_member""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid member address""}], ""names"": []}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""Identifier"", ""name"": ""_member""}}, ""memberName"": ""balance""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getLoyaltyRewardBalance', 'complexity': 2}]",4.0,"
pragma solidity ^0.8.0;

contract LoyaltyRewards {
    using SafeMath for uint256;

    struct Member {
        address addr;
        uint256 balance;
    }

    mapping(address => Member) public members;

    function getLoyaltyRewardBalance(address _member) external view returns (uint256) {
        require(_member != address(0), ""Invalid member address"");

        return members[_member].balance;
    }
}",2.3943889141082764,getLoyaltyRewardBalance,"[{'function': 'getLoyaltyRewardBalance', 'complexity': 1}]",2.0,30.0,0.9017530319186716,0.0574735468700474,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract LoyaltyRewards is Ownable {
    using SafeMath for uint256;

    struct Member {
        address addr;
        uint256 balance;
    }

    mapping(address => Member) public members;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            members[addr] = Member({addr: addr, balance: 1});
        }
    }

    function getLoyaltyRewardBalance(address _member) external view returns (uint256) {
        require(_member != address(0), ""Invalid member address"");

        return members[_member].balance;
    }
}"
4568,Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function transfersEnabled() external view returns (bool);
    function doTransfer(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    IToken public token;

    constructor(address _tokenAddress) {
        require(_tokenAddress != address(0), ""Invalid token address"");
        token = IToken(_tokenAddress);
    }

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(token.transfersEnabled(), ""Transfers are disabled"");
        require(_to != address(0), ""Invalid recipient address"");
        require(_amount > 0, ""Amount must be greater than zero"");
        return token.doTransfer(msg.sender, _to, _amount);
    }
}","[{'function': 'doTransfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transferTokens""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'doTransfer', 'complexity': 0}, {'function': 'transfer', 'complexity': 3}]",5.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transferTokens(address _to, uint256 _amount) public {
        require(_to != address(0), ""Invalid recipient"");
        require(_amount > 0, ""Invalid amount"");
        require(msg.sender == owner(), ""Only the owner can call this function"");

        // Transfer tokens to `_to` from `msg.sender`
        _transferTokens(_to, _amount);
    }

    function _transferTokens(address _to, uint256 _amount) private {
        // Use SafeMath to avoid overflows and underflows
        uint256 balance = SafeMath.sub(balanceOf(msg.sender), _amount);
        require(balance >= 0, ""Insufficient funds"");

        // Transfer tokens to `_to` from `msg.sender`
        balances[_to] = SafeMath.add(balances[_to], _amount);
    }
}",4.842166185379028,transferTokens,"[{'function': 'transferTokens', 'complexity': 3}, {'function': '_transferTokens', 'complexity': 1}]",4.0,17.0,0.8327022472401845,0.4682568791024402,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract MyContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[address(1)] = 1;
        balances[address(2)] = 1;
        balances[address(3)] = 1;
    }

    function transferTokens(address _to, uint256 _amount) public {
        require(_to != address(0), ""Invalid recipient"");
        require(_amount > 0, ""Invalid amount"");
        require(msg.sender == owner(), ""Only the owner can call this function"");

        // Transfer tokens to `_to` from `msg.sender`
        _transferTokens(_to, _amount);
    }

    function _transferTokens(address _to, uint256 _amount) private {
        // Use SafeMath to avoid overflows and underflows
        uint256 balance = SafeMath.sub(balanceOf(msg.sender), _amount);
        require(balance >= 0, ""Insufficient funds"");

        // Transfer tokens to `_to` from `msg.sender`
        balances[_to] = SafeMath.add(balances[_to], _amount);
    }
}"
5799,Set the contract address of the rent auction .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface RentAuction {
    function isRentAuction() external view returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    RentAuction public rentAuctionContract;

    function setRentAuctionContractAddress(address _address) external onlyOwner {
        RentAuction _contract = RentAuction(_address);
        require(_contract.isRentAuction());
        rentAuctionContract = _contract;
    }
}","[{'function': 'isRentAuction', 'complexity': 0}, {'function': 'setRentAuctionContractAddress', 'complexity': 1}]",2.0,{},"[{'function': 'isRentAuction', 'complexity': 0}, {'function': 'setRentAuctionContractAddress', 'complexity': 1}]",2.0,"contract RentAuction {
    address public owner;
    uint256 public rent;

    constructor(address _owner, uint256 _rent) public {
        owner = _owner;
        rent = _rent;
    }

    function setRentAuctionContractAddress(address _contractAddress) external {
        require(msg.sender == owner, ""Only the owner can set the contract address"");
        // Additional logic can be added here
    }
}",2.081390380859375,setRentAuctionContractAddress,"[{'function': 'setRentAuctionContractAddress', 'complexity': 1}]",2.0,22.0,0.9149407197664348,0.1136535202319116,"contract RentAuction {
    address public owner;
    uint256 public rent;

    // Initialize Ownable contract
    constructor() Ownable(msg.sender) public {
        // Initialize RentAuction contract
        owner = 0x1111111111111111111111111111111111111111; // Replace with actual owner address
        rent = 1; // Set to a non-zero value

        // Initialize Ownable contract
        _ownableConstructor();
    }

    function setRentAuctionContractAddress(address _contractAddress) external {
        require(msg.sender == owner, ""Only the owner can set the contract address"");
        // Additional logic can be added here
    }

    // Function to invoke Ownable constructor
    function _ownableConstructor() internal {
        // Invoke Ownable constructor with msg.sender as the owner
        Ownable(msg.sender).constructor();
    }
}"
694,Withdraw any accumulated fees to the specified address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for address;

    function withdraw(address payable addr) public onlyOwner {
        uint256 balance = address(this).balance;
        addr.transfer(balance);
    }
}","[{'function': 'withdraw', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fee"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""fee""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'withdraw', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract FeeWithdrawal {
    using SafeMath for uint256;

    function withdrawFee(address payable recipient, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        require(recipient != address(0), ""Invalid recipient"");

        // Calculate the fee
        uint256 fee = amount.mul(10).div(100);

        // Withdraw the fee to the specified address
        recipient.transfer(fee);
    }
}",3.244176387786865,withdrawFee,"[{'function': 'withdrawFee', 'complexity': 2}]",3.0,24.0,0.6708536565607267,0.0329699975432058,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract FeeWithdrawal is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function withdrawFee(address payable recipient, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        require(recipient != address(0), ""Invalid recipient"");

        // Calculate the fee
        uint256 fee = amount.mul(10).div(100);

        // Withdraw the fee to the specified address
        recipient.transfer(fee);
    }
}"
6751,Returns the amount of tokens approved by the owner that can be transferred to the spender 's account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance (address tokenOwner, address spender) public view returns (uint remaining) {
    return allowed[tokenOwner][spender];
}
}","[{'function': 'allowance ', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid from address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid to address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowance""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'allowance ', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public allowance;

    function approve(uint256 amount, address spender) public {
        require(amount > 0, ""Invalid amount"");
        require(spender != address(0), ""Invalid spender"");

        allowance[msg.sender][spender] = amount;
    }

    function transferFrom(uint256 amount, address from, address to) public {
        require(amount > 0, ""Invalid amount"");
        require(from != address(0), ""Invalid from address"");
        require(to != address(0), ""Invalid to address"");

        allowance[from][msg.sender] = allowance[from][msg.sender].sub(amount);
    }
}",5.49144458770752,transferFrom,"[{'function': 'approve', 'complexity': 2}, {'function': 'transferFrom', 'complexity': 3}]",4.0,39.0,0.5619634845229886,0.0117092517208078,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public allowance;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        allowance[address(0)] = 1; // Placeholder value for address(0), not zero
    }

    function approve(uint256 amount, address spender) public {
        require(amount > 0, ""Invalid amount"");
        require(spender != address(0), ""Invalid spender"");

        allowance[msg.sender][spender] = amount;
    }

    function transferFrom(uint256 amount, address from, address to) public {
        require(amount > 0, ""Invalid amount"");
        require(from != address(0), ""Invalid from address"");
        require(to != address(0), ""Invalid to address"");

        allowance[from][msg.sender] = allowance[from][msg.sender].sub(amount);
    }
}"
2680,Assigns bonus tokens to the specific contributor .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BonusAssignment {
    using SafeMath for uint256;

    uint256 public bonusProvided;
    mapping(address => uint256) public bonusHolders;

    event BonusAssigned(address indexed investor, uint256 bonus);

    function assignBonus(address _investor, uint256 _bonus) internal {
        if (_bonus == 0) {
            return;
        }
        bonusProvided = bonusProvided.add(_bonus);
        bonusHolders[_investor] = bonusHolders[_investor].add(_bonus);
        emit BonusAssigned(_investor, _bonus);
    }
}","[{'function': 'assignBonus', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""assignBonusTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""contributor"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid bonus token amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""contributor""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""contributor""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BonusTokenAssigned""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""contributor""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'assignBonus', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

contract BonusToken {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function assignBonusTokens(address contributor, uint256 amount) external onlyOwner {
        require(amount > 0, ""Invalid bonus token amount"");

        balances[contributor] = balances[contributor].add(amount);

        emit BonusTokenAssigned(contributor, amount);
    }

    function getBonusTokens(address contributor) external view returns (uint256) {
        return balances[contributor];
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can perform this action"");
        _;
    }
}",4.231683254241943,assignBonusTokens,"[{'function': 'assignBonusTokens', 'complexity': 1}, {'function': 'getBonusTokens', 'complexity': 0}]",2.0,10.0,0.7596437777266037,0.0561354575304068,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BonusToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
    }

    function assignBonusTokens(address contributor, uint256 amount) external onlyOwner {
        require(amount > 0, ""Invalid bonus token amount"");

        balances[contributor] = balances[contributor].add(amount);

        emit BonusTokenAssigned(contributor, amount);
    }

    function getBonusTokens(address contributor) external view returns (uint256) {
        return balances[contributor];
    }
}"
3939,"Change the address of the registryAdmin , who has the privilege to create new accounts","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public registryAdmin;

    function setRegistryAdmin(address _newRegistryAdmin) public onlyOwner {
        address _oldRegistryAdmin = registryAdmin;
        registryAdmin = _newRegistryAdmin;
    }
}","[{'function': 'setRegistryAdmin', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""changeRegistryAdmin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newRegistryAdmin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""registryAdmin""}}, {""type"": ""stringLiteral"", ""value"": ""Only the current registry admin can change the registry admin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""registryAdmin""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRegistryAdmin""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setRegistryAdmin', 'complexity': 0}]",7.0,"pragma solidity ^0.8.0;

contract Registry {
    address public registryAdmin;

    constructor() public {
        registryAdmin = msg.sender;
    }

    function changeRegistryAdmin(address newRegistryAdmin) external {
        require(msg.sender == registryAdmin, ""Only the current registry admin can change the registry admin"");
        registryAdmin = newRegistryAdmin;
    }
}",4.697051048278809,changeRegistryAdmin,"[{'function': 'changeRegistryAdmin', 'complexity': 1}]",9.0,8.0,0.8297922454996061,0.022208525930834,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Registry is Ownable {
    address public registryAdmin;

    constructor() Ownable(msg.sender) {
        registryAdmin = msg.sender;
    }

    function changeRegistryAdmin(address newRegistryAdmin) external onlyOwner {
        require(newRegistryAdmin != address(0), ""Invalid address"");
        registryAdmin = newRegistryAdmin;
    }
}"
3322,"Returns the contribution to be used as part of the transaction , and any refund value if expected .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Contribution {
        uint256 amount;
        bool processed;
    }

    mapping(address => Contribution) public contributions;
    uint256 public preSaleCap;

    event PresaleCapUpdated(uint256 newCap);
    event AllowedContributionCheck(uint256 allowedContribution, AllowedContributionState state);

    enum AllowedContributionState { WhitelistClosed, Whitelisted }

    function processContribution() public isValidContribution returns (uint256, uint256) {
        if (!honourWhitelist()) {
            var (allowedContribution, refundAmount) = getAllowedContribution();
            AllowedContributionCheck(allowedContribution, AllowedContributionState.WhitelistClosed);
            preSaleCap = preSaleCap.sub(allowedContribution);
            PresaleCapUpdated(preSaleCap);
            return (allowedContribution, refundAmount);
        }

        var (whiteListedAllowedContribution, whiteListedRefundAmount) = getAllowedContribution();
        if (whitelist[msg.sender] > 0) {
            return processWhitelistedContribution(whiteListedAllowedContribution, whiteListedRefundAmount);
        }

        revert();
    }

    function isValidContribution() internal view returns (bool) {
        // Implement your validation logic here
        return true;
    }

    function honourWhitelist() internal view returns (bool) {
        // Implement your whitelist check logic here
        return false;
    }

    function getAllowedContribution() internal view returns (uint256, uint256) {
        // Implement your logic to calculate allowed contribution and refund amount here
        return (0, 0);
    }

    function processWhitelistedContribution(uint256 whiteListedAllowedContribution, uint256 whiteListedRefundAmount) internal returns (uint256, uint256) {
        // Implement your logic for processing whitelisted contributions here
        return (whiteListedAllowedContribution, whiteListedRefundAmount);
    }
}","[{'function': 'processContribution', 'complexity': 3}, {'function': 'isValidContribution', 'complexity': 0}, {'function': 'honourWhitelist', 'complexity': 0}, {'function': 'getAllowedContribution', 'complexity': 0}, {'function': 'processWhitelistedContribution', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getContribution"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expectedRefund"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""contribution"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refund"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""expectedRefund""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid expected refund""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""expectedRefund""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""contributionWithoutRefund"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""90"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refundAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""contributionWithoutRefund""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""refundAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""expectedRefund""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""contributionWithoutRefund""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""isArray"": False}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""contributionWithoutRefund""}, ""right"": {""type"": ""Identifier"", ""name"": ""refundAmount""}}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""expectedRefund""}, ""right"": {""type"": ""Identifier"", ""name"": ""refundAmount""}}], ""isArray"": False}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'processContribution', 'complexity': 3}, {'function': 'isValidContribution', 'complexity': 0}, {'function': 'honourWhitelist', 'complexity': 0}, {'function': 'getAllowedContribution', 'complexity': 0}, {'function': 'processWhitelistedContribution', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Contribution {
    using SafeMath for uint256;

    function getContribution(uint256 amount, uint256 expectedRefund) public pure returns (uint256 contribution, uint256 refund) {
        require(amount > 0, ""Invalid amount"");
        require(expectedRefund >= 0, ""Invalid expected refund"");

        if (expectedRefund == 0) {
            return (amount, 0);
        }

        uint256 contributionWithoutRefund = SafeMath.div(amount, 100).mul(90);
        uint256 refundAmount = amount - contributionWithoutRefund;

        if (refundAmount > expectedRefund) {
            return (contributionWithoutRefund, 0);
        } else {
            return (contributionWithoutRefund + refundAmount, expectedRefund - refundAmount);
        }
    }
}",4.609861612319946,getContribution,"[{'function': 'getContribution', 'complexity': 4}]",5.0,47.0,0.7036050821275569,0.13149008065196,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of adding an Ownable contract

contract Contribution is Ownable {
    using SafeMath for uint256;

    function getContribution(uint256 amount, uint256 expectedRefund) public pure returns (uint256 contribution, uint256 refund) {
        require(amount > 0, ""Invalid amount"");
        require(expectedRefund >= 0, ""Invalid expected refund"");

        if (expectedRefund == 0) {
            return (amount, 0);
        }

        uint256 contributionWithoutRefund = SafeMath.div(amount, 100).mul(90);
        uint256 refundAmount = amount - contributionWithoutRefund;

        if (refundAmount > expectedRefund) {
            return (contributionWithoutRefund, 0);
        } else {
            return (contributionWithoutRefund + refundAmount, expectedRefund - refundAmount);
        }
    }
}"
3650,Method for setting a registered issuer firm authority,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface StorageInterface {
    function setBool(bytes32 id, bool value) external returns (bool);
    function setString(bytes32 id, string memory value) external returns (bool);
}

abstract contract Data {
    using SafeMath for uint256;
    StorageInterface public storageContract;

    constructor(address _storageAddress) {
        storageContract = StorageInterface(_storageAddress);
    }

    function setRegisteredAuthority(string memory issuerFirm, address authorityAddress, bool approved) internal returns (bool success) {
        require(isRegisteredFirm(issuerFirm), ""Error: `issuerFirm` must be registered."");
        bytes32 id_a = keccak256(abi.encodePacked(""registered.authority"", issuerFirm, authorityAddress));
        bytes32 id_b = keccak256(abi.encodePacked(""registered.authority.firm"", authorityAddress));
        require(storageContract.setBool(id_a, approved), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        require(storageContract.setString(id_b, issuerFirm), ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."");
        return true;
    }

    function isRegisteredFirm(string memory firm) internal view returns (bool) {
        // Implement the logic to check if a firm is registered
        // This is just a placeholder implementation
        bytes32 id = keccak256(abi.encodePacked(""registered.firm"", firm));
        return true; // Replace with actual storage retrieval logic
    }
}","[{'function': 'setString', 'complexity': 0}, {'function': 'setRegisteredAuthority', 'complexity': 3}, {'function': 'isRegisteredFirm', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""setAuthority"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_issuer"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_isRegistered"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_issuer""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid issuer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorities""}, ""index"": {""type"": ""Identifier"", ""name"": ""_issuer""}}, ""memberName"": ""isRegistered""}, ""isPrefix"": True}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorities""}, ""index"": {""type"": ""Identifier"", ""name"": ""_issuer""}}, ""memberName"": ""registeredAt""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""days""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}], ""isArray"": False}}, {""type"": ""stringLiteral"", ""value"": ""Authority already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""authorities""}, ""index"": {""type"": ""Identifier"", ""name"": ""_issuer""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Authority""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_issuer""}, {""type"": ""Identifier"", ""name"": ""_isRegistered""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": [""issuer"", ""isRegistered"", ""registeredAt""]}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setString', 'complexity': 0}, {'function': 'setRegisteredAuthority', 'complexity': 3}, {'function': 'isRegisteredFirm', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract IssuerFirmAuthority {
    using SafeMath for uint256;

    struct Authority {
        address issuer;
        bool isRegistered;
        uint256 registeredAt;
    }

    mapping(address => Authority) public authorities;

    function setAuthority(address _issuer, bool _isRegistered) external {
        require(_issuer != address(0), ""Invalid issuer"");
        require(!authorities[_issuer].isRegistered || (authorities[_issuer].registeredAt + 1 days < block.timestamp), ""Authority already registered"");

        authorities[_issuer] = Authority({
            issuer: _issuer,
            isRegistered: _isRegistered,
            registeredAt: block.timestamp
        });
    }
}",4.014056205749512,setAuthority,"[{'function': 'setAuthority', 'complexity': 4}]",4.0,47.0,0.7664655890852129,0.0358231735805989,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract IssuerFirmAuthority is Ownable {
    using SafeMath for uint256;

    struct Authority {
        address issuer;
        bool isRegistered;
        uint256 registeredAt;
    }

    mapping(address => Authority) public authorities;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables with safe, non-corner-case values
        // uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function setAuthority(address _issuer, bool _isRegistered) external {
        require(_issuer != address(0), ""Invalid issuer"");
        require(!authorities[_issuer].isRegistered || (authorities[_issuer].registeredAt + 1 days < block.timestamp), ""Authority already registered"");

        authorities[_issuer] = Authority({
            issuer: _issuer,
            isRegistered: _isRegistered,
            registeredAt: block.timestamp
        });
    }
}"
4267,"Returns holder id for the specified address , creates it if needed .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderRegistration {
    using SafeMath for uint256;

    struct HoldersData {
        uint countryCode;
        bool operational;
        uint sendLimPerDay;
        uint sendLimPerMonth;
        uint holderAddressCount;
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
    }

    bytes32[] public holderIndex;
    mapping(bytes32 => uint) public holderAddress2Id;
    uint public holdersCount;
    mapping(address => bytes32) public holderAddress2ExternalId;
    HoldersData[] public holders;
    address public oracle;

    uint constant MAX_TOKEN_HOLDER_NUMBER = 10000;
    uint constant OK = 1;

    modifier onlyOracleOrOwner() {
        require(msg.sender == owner() || msg.sender == oracle, ""Only owner or oracle can call this function"");
        _;
    }

    constructor() {
        holdersCount = 0;
    }

    function registerHolder(bytes32 _externalHolderId, address _holderAddress, uint _countryCode) onlyOracleOrOwner external returns (uint) {
        require(_holderAddress != address(0));
        require(holderIndex[_externalHolderId] == bytes32(0));
        uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];
        require(_holderIndex == 0);
        _createCountryId(_countryCode);
        _holderIndex = holdersCount.add(1);
        holdersCount = _holderIndex;
        HoldersData storage _holderData = holders[_holderIndex];
        _holderData.countryCode = _countryCode;
        _holderData.operational = true;
        _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;
        _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;
        uint _firstAddressIndex = 1;
        _holderData.holderAddressCount = _firstAddressIndex;
        _holderData.address2Index[_holderAddress] = _firstAddressIndex;
        _holderData.index2Address[_firstAddressIndex] = _holderAddress;
        holderIndex[_externalHolderId] = bytes32(_holderIndex);
        holderAddress2Id[_holderAddress] = _externalHolderId;
        emit HolderRegistered(_externalHolderId, _holderIndex, _countryCode);
        return OK;
    }

    function _createCountryId(uint _countryCode) internal {
        // Implementation for creating country ID
    }

    event HolderRegistered(bytes32 indexed externalHolderId, uint indexed holderIndex, uint countryCode);
}","[{'function': 'registerHolder', 'complexity': 3}, {'function': '_createCountryId', 'complexity': 0}]",9.0,{},"[{'function': 'registerHolder', 'complexity': 3}, {'function': '_createCountryId', 'complexity': 0}]",10.0,"
contract Holder {
    using SafeMath for uint256;

    struct HolderInfo {
        uint256 id;
        bool exists;
    }

    mapping(address => HolderInfo) public holders;

    function getHolderId(address _holderAddress) public view returns (uint256) {
        if (!holders[_holderAddress].exists) {
            uint256 newId = holders.length();
            holders[_holderAddress] = HolderInfo({id: newId, exists: true});
            return newId;
        } else {
            return holders[_holderAddress].id;
        }
    }
}",2.9552254676818848,getHolderId,"[{'function': 'getHolderId', 'complexity': 2}]",2.0,130.0,0.6449384218004839,0.0098177664191454,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Holder is Ownable {
    using SafeMath for uint256;

    struct HolderInfo {
        uint256 id;
        bool exists;
    }

    mapping(address => HolderInfo) public holders;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address holderAddress = address(uint160(i));
            holders[holderAddress] = HolderInfo({id: i, exists: true});
        }
    }

    function getHolderId(address _holderAddress) public view returns (uint256) {
        if (!holders[_holderAddress].exists) {
            uint256 newId = holders.length();
            holders[_holderAddress] = HolderInfo({id: newId, exists: true});
            return newId;
        } else {
            return holders[_holderAddress].id;
        }
    }
}"
5707,` onlyOwner ` An efficient way to cancel multiple payments,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function multiCancel(uint256[] memory _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doCancelPayment(_idPayments[i]);
        }
    }

    function doCancelPayment(uint256 _paymentId) internal virtual;
}","[{'function': 'multiCancel', 'complexity': 1}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""cancelPayments"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_paymentIds"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""owners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only owner can cancel payments""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_paymentIds""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Payment""}, ""name"": ""payment"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""payments""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_paymentIds""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""payment""}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}]}, ""FalseBody"": None}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'multiCancel', 'complexity': 1}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract PaymentCanceler {
    using SafeMath for uint256;

    struct Payment {
        address recipient;
        uint256 amount;
    }

    mapping(address => bool) public owners;
    mapping(uint256 => Payment) public payments;

    function cancelPayments(uint256[] memory _paymentIds, address _owner) public {
        require(owners[_owner], ""Only owner can cancel payments"");

        for (uint256 i = 0; i < _paymentIds.length; i++) {
            Payment storage payment = payments[_paymentIds[i]];
            if (payment.amount > 0) {
                payment.recipient.transfer(payment.amount);
                payment.amount = 0;
            }
        }
    }
}",4.143748760223389,cancelPayments,"[{'function': 'cancelPayments', 'complexity': 4}]",4.0,19.0,0.824308967483075,0.1268929781459457,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract PaymentCanceler is Ownable {
    using SafeMath for uint256;

    struct Payment {
        address recipient;
        uint256 amount;
    }

    mapping(address => bool) public owners;
    mapping(uint256 => Payment) public payments;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function cancelPayments(uint256[] memory _paymentIds, address _owner) public {
        require(owners[_owner], ""Only owner can cancel payments"");

        for (uint256 i = 0; i < _paymentIds.length; i++) {
            Payment storage payment = payments[_paymentIds[i]];
            if (payment.amount > 0) {
                payment.recipient.transfer(payment.amount);
                payment.amount = 0;
            }
        }
    }

    function initialize() public {
        owners[msg.sender] = true;
    }
}"
32,Allows the owner of this contract to set the currentPrice for each token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;
    uint256 public currentPrice;

    function setCurrentPrice(uint256 newPrice) public onlyOwner {
        currentPrice = newPrice;
    }
}","[{'function': 'setCurrentPrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCurrentPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_currentPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_msgSender""}, ""arguments"": [], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can call this function""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenDetails""}, ""name"": ""token"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenAddress""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""currentPrice""}, ""right"": {""type"": ""Identifier"", ""name"": ""_currentPrice""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setCurrentPrice', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    struct TokenDetails {
        string name;
        string symbol;
        uint256 totalSupply;
        uint256 currentPrice;
    }

    mapping(address => TokenDetails) public tokens;

    function setCurrentPrice(uint256 _currentPrice, address _tokenAddress) public {
        require(_msgSender() == owner(), ""Only the contract owner can call this function"");

        // Set the current price for the token at the specified address
        TokenDetails storage token = tokens[_tokenAddress];
        token.currentPrice = _currentPrice;
    }
}",3.327178239822388,setCurrentPrice,"[{'function': 'setCurrentPrice', 'complexity': 1}]",2.0,19.0,0.7505130485480056,0.057696334522615,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract Token is Ownable {
    using SafeMath for uint256;

    struct TokenDetails {
        string name;
        string symbol;
        uint256 totalSupply;
        uint256 currentPrice;
    }

    mapping(address => TokenDetails) public tokens;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            tokens[addr] = TokenDetails({
                name: 'MyToken',
                symbol: string(abi.encodePacked('TKN', uint256ToHexString(i))),
                totalSupply: 1,
                currentPrice: 1
            });
        }
    }

    function setCurrentPrice(uint256 _currentPrice, address _tokenAddress) public {
        require(_msgSender() == owner(), ""Only the contract owner can call this function"");

        // Set the current price for the token at the specified address
        TokenDetails storage token = tokens[_tokenAddress];
        token.currentPrice = _currentPrice;
    }

    function uint256ToHexString(uint256 value) internal pure returns (string memory) {
        bytes32 strBytes = bytes32('init');
        return string(abi.encodePacked(strBytes, uint256(value)));
    }
}"
2463,Gets a given contract address by bytes32 in order to save gas,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ContractRegistry is Ownable {
    using SafeMath for uint256;

    address public registryAddress;
    bytes32 private constant REGISTRY_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    constructor(address _registryAddress) {
        registryAddress = _registryAddress;
    }

    function getContractAddress(string memory _name) public view returns (address _contractAddress) {
        bytes4 _signature = bytes4(keccak256(""getContractAddress32(bytes32)""));
        bytes32 _name32 = keccak256(abi.encodePacked(_name));
        assembly {
            let _registry := sload(REGISTRY_SLOT)
            let _pointer := mload(0x40)
            mstore(_pointer, _signature)
            mstore(add(_pointer, 0x04), _name32)
            let result := staticcall(gas(), _registry, _pointer, 0x24, _pointer, 0x20)
            if iszero(result) {
                revert(0, 0)
            }
            _contractAddress := mload(_pointer)
            mstore(0x40, add(_pointer, 0x24))
        }
    }
}","[{'function': 'getContractAddress', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""getContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_address""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getContractAddress', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function getContractAddress(bytes32 _address) public view returns (address) {
        return address(_address);
    }
}",2.6816961765289307,getContractAddress,"[{'function': 'getContractAddress', 'complexity': 0}]",1.0,57.0,0.72781251150617,0.0016284395001728,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""Ownable/Ownable.sol""; // Assuming a standard import path for Ownable

contract MyContract is Ownable {
    using SafeMath for uint256;

    function getContractAddress(bytes32 _address) public view returns (address) {
        return address(_address);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        uint256 private constant SAFE_UINT = 1;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        address private constant SAFE_ADDRESS_1 = address(0x111);
        address private constant SAFE_ADDRESS_2 = address(0x222);
        address private constant SAFE_ADDRESS_3 = address(0x333);

        // bool: Set to true
        bool private constant SAFE_BOOL = true;

        // string: Set to 'initialized'
        string private constant INITIALIZED_STRING = ""initialized"";

        // bytes32: Set to bytes32('init')
        bytes32 private constant INITIALIZED_BYTES32 = keccak256(abi.encodePacked(""init""));
    }
}"
1777,"Set a minimum required stake for a given attribute type ID ` ID ` and an amount of ` stake ` , to be locked in the jurisdiction upon assignment of attributes of the given type .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AttributeTypeManager is Ownable {
    using SafeMath for uint256;

    struct AttributeType {
        bool exists;
        uint256 minimumStake;
    }

    mapping(uint256 => AttributeType) private _attributeTypes;

    function setAttributeTypeMinimumRequiredStake(uint256 ID, uint256 minimumRequiredStake) external onlyOwner {
        require(_attributeTypes[ID].exists, ""unable to set minimum stake, no attribute type with the provided ID"");
        _attributeTypes[ID].minimumStake = minimumRequiredStake;
    }
}","[{'function': 'setAttributeTypeMinimumRequiredStake', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMinimumRequiredStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ID"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""stake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""ID""}}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Stake already exists""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""ID""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Stake""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""stake""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": [""amount"", ""owner""]}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setAttributeTypeMinimumRequiredStake', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract AttributeStaking {
    using SafeMath for uint256;

    struct Stake {
        uint256 amount;
        address owner;
    }

    mapping(uint256 => Stake) public stakes;

    function setMinimumRequiredStake(uint256 ID, uint256 stake) external {
        require(stakes[ID].amount == 0, ""Stake already exists"");
        stakes[ID] = Stake({ amount: stake, owner: msg.sender });
    }
}",2.635884523391724,setMinimumRequiredStake,"[{'function': 'setMinimumRequiredStake', 'complexity': 1}]",2.0,8.0,0.809152358805938,0.1644607566145101,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AttributeStaking is Ownable {
    using SafeMath for uint256;

    struct Stake {
        uint256 amount;
        address owner;
    }

    mapping(uint256 => Stake) public stakes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            stakes[i] = Stake({ amount: uint256(i), owner: address(uint160(i)) });
        }
    }

    function setMinimumRequiredStake(uint256 ID, uint256 stake) external {
        require(stakes[ID].amount == 0, ""Stake already exists"");
        stakes[ID] = Stake({ amount: stake, owner: msg.sender });
    }
}"
2431,"The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public controller;

    function () external payable {
        require(isContract(controller), ""Controller must be a contract"");
        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender), ""Proxy payment failed"");
    }

    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

interface TokenController {
    function proxyPayment() external payable returns (bool);
}","[{'function': '', 'complexity': 2}, {'function': 'isContract', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid payment""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mintTokens""}, ""arguments"": [], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': '', 'complexity': 2}, {'function': 'isContract', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    address public controller;

    function proxyPayment() external payable {
        require(msg.value > 0, ""Invalid payment"");
        // Additional logic can be added here
        _mintTokens();
    }

    function _mintTokens() internal {
        // Mint tokens based on the amount of Ether sent to this contract
        uint256 tokenAmount = msg.value.mul(10);
        // Additional logic can be added here
        require(tokenAmount > 0, ""Invalid token amount"");
    }
}",3.263141632080078,_mintTokens,"[{'function': 'proxyPayment', 'complexity': 1}, {'function': '_mintTokens', 'complexity': 1}]",2.0,19.0,0.3809980848638173,0.0134977993747977,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;
    address public controller = 0x1111111111111111111111111111111111111111; // Replace with your controller's address

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function proxyPayment() external payable {
        require(msg.value > 0, ""Invalid payment"");
        _mintTokens();
    }

    function _mintTokens() internal {
        uint256 tokenAmount = msg.value.mul(10);
        require(tokenAmount > 0, ""Invalid token amount"");
    }
}"
1613,Calculate the halving hash rate of a miner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ForkAnnouncer is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateHalvingHashRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_miningTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_hashRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""/"", ""left"": {""type"": ""Identifier"", ""name"": ""_hashRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""2"", ""subdenomination"": None}}], ""isArray"": False}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_miningTime""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'announceFork', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract Miner {
    using SafeMath for uint256;

    function calculateHalvingHashRate(uint256 _miningTime, uint256 _hashRate) public pure returns (uint256) {
        return (_hashRate / 2).div(_miningTime);
    }
}",1.8279571533203125,calculateHalvingHashRate,"[{'function': 'calculateHalvingHashRate', 'complexity': 0}]",1.0,30.0,0.2498903668323833,0.0279210472550559,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming Ownable is imported correctly

contract Miner is Ownable {
    using SafeMath for uint256;

    function calculateHalvingHashRate(uint256 _miningTime, uint256 _hashRate) public pure returns (uint256) {
        return (_hashRate / 2).div(_miningTime);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
2278,Increase the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ExampleToken is Ownable {
    using SafeMath for uint256;

    mapping(bytes => bool) public nonces;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _owner, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_owner, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) internal pure returns (address) {
        if (_signature.length != 65) return address(0);
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(_signature, (uint8, bytes32, bytes32));
        return ecrecover(_hash, v, r, s);
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0));
        require(!nonces[_signature]);

        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0));

        nonces[_signature] = true;
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);

        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);

        return true;
    }
}","[{'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'increaseApprovalPreSigned', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""increaseAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentAllowance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentAllowance""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""currentAllowance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'increaseApprovalPreSigned', 'complexity': 4}]",4.0,"pragma solidity ^0.8.0;

contract TokenSpender {
    using SafeMath for uint256;

    function increaseAllowance(address _owner, address _spender, uint256 _value) public {
        require(_owner != address(0), ""Invalid owner"");
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Invalid value"");

        // Get the current allowance of tokens for the spender
        uint256 currentAllowance = token.allowance(_owner, _spender);

        // Increase the allowance by the specified amount
        currentAllowance = currentAllowance.add(_value);

        // Update the allowance in the contract
        token.approve(_owner, _spender, currentAllowance);
    }
}",3.650425672531128,increaseAllowance,"[{'function': 'increaseAllowance', 'complexity': 3}]",4.0,92.0,0.6025690851860621,0.1665747982853468,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSpender is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _token) Ownable(msg.sender) {
        require(_token != address(0), ""Invalid token address"");
        token = IERC20(_token);
    }

    function increaseAllowance(address _owner, address _spender, uint256 _value) public {
        require(_owner != address(0), ""Invalid owner"");
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Invalid value"");

        // Get the current allowance of tokens for the spender
        uint256 currentAllowance = token.allowance(_owner, _spender);

        // Increase the allowance by the specified amount
        currentAllowance = currentAllowance.add(_value);

        // Update the allowance in the contract
        token.approve(_owner, _spender, currentAllowance);
    }
}"
4847,Function that is called when transaction target is contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ContractReceiver {
    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

    function transferToContract(address _to, uint256 _value, bytes memory _data) public returns (bool success) {
        require(balances[msg.sender] >= _value, ""Insufficient balance"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        emit Transfer(msg.sender, _to, _value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }
}","[{'function': 'tokenFallback', 'complexity': 0}, {'function': 'transferToContract', 'complexity': 1}]",2.0,{},"[{'function': 'tokenFallback', 'complexity': 0}, {'function': 'transferToContract', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public {
        require(_to != address(0), ""Invalid recipient"");
        require(_value > 0, ""Invalid value"");
        uint256 balance = address(this).balance.add(_value);
        require(balance >= _value, ""Insufficient funds"");
        (bool success, ) = _to.call{value: _value}("""");
        require(success, ""Transfer failed"");
    }
}",2.895728588104248,transfer,"[{'function': 'transfer', 'complexity': 4}]",5.0,76.0,0.821730986989647,0.1850995386418389,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        someUint = 1; // Set to 1 (never 0)
        someAddress = address(uint160(uint256(keccak256('address1')))); // Fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        someBool = true; // Set to true
        someString = 'initialized'; // Set to 'initialized'
        someBytes32 = bytes32('init'); // Set to bytes32('init')
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function transfer(address _to, uint256 _value) public {
        require(_to != address(0), ""Invalid recipient"");
        require(_value > 0, ""Invalid value"");
        uint256 balance = address(this).balance.add(_value);
        require(balance >= _value, ""Insufficient funds"");
        (bool success, ) = _to.call{value: _value}("""");
        require(success, ""Transfer failed"");
    }
}"
1565,Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MintWrapper is Ownable {
    using SafeMath for uint256;

    function mint(address _tokenHolder, uint256 _amount, bytes memory _operatorData) public onlyOwner {
        doMint(_tokenHolder, _amount, _operatorData);
    }
}","[{'function': 'mint', 'complexity': 0}]",2.0,{},"[{'function': 'mint', 'complexity': 0}]",2.0,"
contract Token {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function mint(uint256 _amount, address _tokenHolder) external returns (bool) {
        require(_amount > 0, ""Invalid amount"");
        require(_tokenHolder != address(0), ""Invalid recipient"");

        balances[_tokenHolder] = balances[_tokenHolder].safeAdd(_amount);
        emit Minted(_amount, _tokenHolder);

        return true;
    }

    function transfer(address _to, uint256 _value) external returns (bool) {
        require(_to != address(0), ""Invalid recipient"");
        require(_value > 0, ""Invalid amount"");

        balances[msg.sender] = balances[msg.sender].safeSub(_value);
        balances[_to] = balances[_to].safeAdd(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    event Minted(uint256 amount, address indexed to);
    event Transfer(address indexed from, address indexed to, uint256 value);
}",5.85834002494812,transfer,"[{'function': 'mint', 'complexity': 2}, {'function': 'transfer', 'complexity': 2}]",3.0,16.0,0.4757377967909482,0.0126796110073277,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // No need to initialize balances here as they are implicitly initialized to zero
    }

    function mint(uint256 _amount, address _tokenHolder) external returns (bool) {
        require(_amount > 0, ""Invalid amount"");
        require(_tokenHolder != address(0), ""Invalid recipient"");

        balances[_tokenHolder] = balances[_tokenHolder].safeAdd(_amount);
        emit Minted(_amount, _tokenHolder);

        return true;
    }

    function transfer(address _to, uint256 _value) external returns (bool) {
        require(_to != address(0), ""Invalid recipient"");
        require(_value > 0, ""Invalid amount"");

        balances[msg.sender] = balances[msg.sender].safeSub(_value);
        balances[_to] = balances[_to].safeAdd(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    event Minted(uint256 amount, address indexed to);
    event Transfer(address indexed from, address indexed to, uint256 value);
}"
5534,Returns the timestamp at which the question will be/was finalized,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Question {
        uint32 finalize_ts;
    }

    mapping(bytes32 => Question) public questions;

    function getFinalizeTS(bytes32 question_id) public view returns (uint32) {
        return questions[question_id].finalize_ts;
    }
}","[{'function': 'getFinalizeTS', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getFinalizedTimestamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Question""}, ""name"": ""question"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""question""}, ""memberName"": ""finalizedAt""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getFinalizeTS', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract Question {
    using SafeMath for uint256;

    struct Question {
        string text;
        uint256 createdAt;
        uint256 finalizedAt;
    }

    function getFinalizedTimestamp(Question memory question) public view returns (uint256) {
        return question.finalizedAt;
    }
}",1.8681681156158447,getFinalizedTimestamp,"[{'function': 'getFinalizedTimestamp', 'complexity': 0}]",1.0,3.0,0.8081496427194624,0.3100712006600205,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Question is Ownable {
    using SafeMath for uint256;

    struct Question {
        string text;
        uint256 createdAt;
        uint256 finalizedAt;
    }

    function getFinalizedTimestamp(Question memory question) public view returns (uint256) {
        return question.finalizedAt;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        Question storage q = questions[0];
        q.text = 'initialized';
        q.createdAt = 1;
        q.finalizedAt = 2;
    }

    mapping(uint256 => Question) public questions;
}"
2081,Become owner of a deed for which you are currently approved,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IDeed {
    function takeOwnership(uint256 _deedId) external payable;
}

abstract contract Deed is Ownable, SafeMath {
    struct DeedInfo {
        address owner;
        bool isOwner;
    }

    mapping(uint256 => DeedInfo) private _deeds;
    uint256 public constant DEED_PRICE = 1 ether; // Example price, adjust as needed

    function takeOwnership(uint256 _deedId) external payable {
        require(_deedId > 0, ""Invalid deed ID"");
        require(msg.value >= DEED_PRICE, ""Insufficient payment"");
        require(!_deeds[_deedId].isOwner, ""Deed is already owned"");
        _deeds[_deedId].owner = msg.sender;
        _deeds[_deedId].isOwner = true;
        emit DeedOwnershipTransferred(_deedId, msg.sender);
    }
}","[{'function': 'takeOwnership', 'complexity': 0}, {'function': 'takeOwnership', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""becomeOwnerOfDeed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""deedId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""ownerAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""ownerAddress""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ApprovedDeeds""}, ""name"": ""approvedDeeds"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""approvedDeeds""}, ""index"": {""type"": ""Identifier"", ""name"": ""deedId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""approvedDeeds""}, ""memberName"": ""isApproved""}, ""index"": {""type"": ""Identifier"", ""name"": ""ownerAddress""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""approvedDeeds""}, ""memberName"": ""approvers""}, ""index"": {""type"": ""Identifier"", ""name"": ""deedId""}}, ""isPrefix"": True}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'takeOwnership', 'complexity': 0}, {'function': 'takeOwnership', 'complexity': 4}]",4.0,"
pragma solidity ^0.8.0;

contract DeedOwnership {
    struct ApprovedDeeds {
        address[] approvers;
        mapping(address => bool) isApproved;
    }

    function becomeOwnerOfDeed(uint256 deedId, address ownerAddress) public returns (bool) {
        require(msg.sender == ownerAddress);
        ApprovedDeeds storage approvedDeeds = approvedDeeds[deedId];
        require(approvedDeeds.isApproved[ownerAddress]);
        delete approvedDeeds.approvers[deedId];
        return true;
    }
}",2.750164270401001,becomeOwnerOfDeed,"[{'function': 'becomeOwnerOfDeed', 'complexity': 2}]",3.0,35.0,0.7465340930066695,0.0322480989959107,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract DeedOwnership {
    struct ApprovedDeeds {
        address[] approvers;
        mapping(address => bool) isApproved;
    }

    mapping(uint256 => ApprovedDeeds) public approvedDeeds;

    constructor() {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
        approvedDeeds[0].isApproved[address(0x111)] = true;
        approvedDeeds[0].approvers.push(address(0x111));

        // Properly invoke the constructor of Ownable with msg.sender
        // Ownable(msg.sender)
    }

    function becomeOwnerOfDeed(uint256 deedId, address ownerAddress) public returns (bool) {
        require(msg.sender == ownerAddress);
        ApprovedDeeds storage approvedDeeds = approvedDeeds[deedId];
        require(approvedDeeds.isApproved[ownerAddress]);
        delete approvedDeeds.approvers[deedId];
        return true;
    }
}"
790,Allows the owner of the contract to update the address of the RenExBrokerVerifier contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RenExBrokerVerifier {
    using SafeMath for uint256;

    address public brokerVerifierContract;

    event LogBrokerVerifierContractUpdated(address indexed oldBrokerVerifierContract, address indexed newBrokerVerifierContract);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {
        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);
        brokerVerifierContract = _newBrokerVerifierContract;
    }
}","[{'function': 'updateBrokerVerifierContract', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateBrokerVerifier"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newBrokerVerifier"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""newBrokerVerifier""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid broker verifier address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""brokerVerifierAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBrokerVerifier""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updateBrokerVerifierContract', 'complexity': 0}]",9.0,"pragma solidity ^0.8.0;

contract Ownable {
    address private _owner;

    constructor() public {
        _owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Only the owner can call this function"");
        _;
    }
}

contract RenExBrokerVerifier is Ownable {
    address public brokerVerifierAddress;

    constructor() public {
        brokerVerifierAddress = 0x0;
    }

    function updateBrokerVerifier(address newBrokerVerifier) external onlyOwner {
        require(newBrokerVerifier != address(0), ""Invalid broker verifier address"");
        brokerVerifierAddress = newBrokerVerifier;
    }
}",3.57732892036438,updateBrokerVerifier,"[{'function': 'updateBrokerVerifier', 'complexity': 1}]",8.0,7.0,0.8116047304109058,0.1182249176624464,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;

    constructor(address owner) public {
        _owner = owner;
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, ""Only the owner can call this function"");
        _;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract RenExBrokerVerifier is Ownable {
    address public brokerVerifierAddress;

    constructor(address initialBrokerVerifier) Ownable(initialBrokerVerifier) public {
        brokerVerifierAddress = initialBrokerVerifier;
    }

    function updateBrokerVerifier(address newBrokerVerifier) external onlyOwner {
        require(newBrokerVerifier != address(0), ""Invalid broker verifier address"");
        brokerVerifierAddress = newBrokerVerifier;
    }
}"
1335,Owner : Withdraw excess funds which do n't belong to Bskt Token holders,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply_;
    uint256 public creationUnit_;

    constructor(uint256 _totalSupply, uint256 _creationUnit) {
        require(_totalSupply > 0 && _creationUnit > 0, ""Invalid parameters"");
        totalSupply_ = _totalSupply;
        creationUnit_ = _creationUnit;
    }

    function getQuantity(address token) internal view returns (uint256 quantity, bool ok) {
        // Implement your logic to determine the quantity here
        // For example:
        // if (/* some condition */) {
        //     return (quantity, true);
        // } else {
        //     return (0, false);
        // }
        revert(""Not implemented"");
    }

    function withdrawExcessToken(address token) external onlyOwner {
        ERC20 erc20 = ERC20(token);
        uint256 amountOwned = erc20.balanceOf(address(this));
        uint256 quantity;
        bool ok;
        (quantity, ok) = getQuantity(token);
        uint256 withdrawAmount;
        if (ok) {
            withdrawAmount = amountOwned.sub(totalSupply_.div(creationUnit_).mul(quantity));
        } else {
            withdrawAmount = amountOwned;
        }
        require(erc20.transfer(owner(), withdrawAmount), ""Transfer failed"");
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'getQuantity', 'complexity': 0}, {'function': 'withdrawExcessToken', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawExcessFunds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can withdraw excess funds""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1000000000"", ""subdenomination"": None}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenHoldersBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""Identifier"", ""name"": ""totalSupply""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""holder"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BsktToken""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""tokenHolder""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""i""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""holder""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenHoldersBalance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenHoldersBalance""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BsktToken""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""holder""}], ""names"": []}], ""names"": []}}}]}, ""FalseBody"": None}]}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""excessFunds"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""balance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenHoldersBalance""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""excessFunds""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""excessFunds""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'getQuantity', 'complexity': 0}, {'function': 'withdrawExcessToken', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

contract BsktToken {
    using SafeMath for uint256;

    function withdrawExcessFunds(address payable owner) public {
        require(msg.sender == owner, ""Only the owner can withdraw excess funds"");
        uint256 balance = address(this).balance;
        uint256 totalSupply = 1000000000; // 1 billion tokens
        uint256 tokenHoldersBalance = 0;

        for (uint i = 0; i < totalSupply; i++) {
            address holder = BsktToken(address(this)).tokenHolder(i);
            if (holder != owner) {
                tokenHoldersBalance = tokenHoldersBalance.add(BsktToken(address(this)).balanceOf(holder));
            }
        }

        uint256 excessFunds = balance.sub(tokenHoldersBalance);
        if (excessFunds > 0) {
            owner.transfer(excessFunds);
        }
    }
}",4.89718770980835,withdrawExcessFunds,"[{'function': 'withdrawExcessFunds', 'complexity': 5}]",5.0,47.0,0.7973013025663745,0.1125010001327459,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BsktToken is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        totalSupply = 1000000000; // 1 billion tokens
        tokenHoldersBalance = 0;
    }

    function withdrawExcessFunds(address payable owner) public {
        require(msg.sender == owner, ""Only the owner can withdraw excess funds"");
        uint256 balance = address(this).balance;
        uint256 totalSupply_ = 1000000000; // 1 billion tokens
        uint256 tokenHoldersBalance_ = 0;

        for (uint i = 0; i < totalSupply_; i++) {
            address holder = BsktToken(address(this)).tokenHolder(i);
            if (holder != owner) {
                tokenHoldersBalance_ = tokenHoldersBalance_.add(BsktToken(address(this)).balanceOf(holder));
            }
        }

        uint256 excessFunds = balance.sub(tokenHoldersBalance_);
        if (excessFunds > 0) {
            owner.transfer(excessFunds);
        }
    }
}"
3433,Permit ` msg.sender ` to set its NeuroChain Address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NeuroChainWrapper {
    using SafeMath for uint256;

    mapping(address => string) public neuroChainAddresses;

    event NeuroChainAddressSet(address indexed user, string addressString, uint256 timestamp, bool isRegistered);

    function setNeuroChainAddress(string memory neurochainAddress) public {
        require(bytes(neurochainAddress).length > 0, ""Invalid address"");
        neuroChainAddresses[msg.sender] = neurochainAddress;
        emit NeuroChainAddressSet(msg.sender, neurochainAddress, block.timestamp, false);
    }
}","[{'function': 'setNeuroChainAddress', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNeuroChainAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_neuroChainAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_neuroChainAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid NeuroChain Address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""users""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""neuroChainAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_neuroChainAddress""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setNeuroChainAddress', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract NeuroChain {
    using SafeMath for uint256;

    struct User {
        address neuroChainAddress;
    }

    mapping(address => User) public users;

    function setNeuroChainAddress(address _neuroChainAddress) external {
        require(_neuroChainAddress != address(0), ""Invalid NeuroChain Address"");
        users[msg.sender].neuroChainAddress = _neuroChainAddress;
    }
}",2.444685220718384,setNeuroChainAddress,"[{'function': 'setNeuroChainAddress', 'complexity': 1}]",2.0,14.0,0.9107943872459372,0.0518758179661582,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of adding Ownable functionality

contract NeuroChain is Ownable {
    using SafeMath for uint256;

    struct User {
        address neuroChainAddress;
    }

    mapping(address => User) public users;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            users[addr] = User({neuroChainAddress: addr});
        }
    }

    function setNeuroChainAddress(address _neuroChainAddress) external {
        require(_neuroChainAddress != address(0), ""Invalid NeuroChain Address"");
        users[msg.sender].neuroChainAddress = _neuroChainAddress;
    }
}"
465,Get the token balance for a given account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Storage {
    function getUint(bytes32 key) external view returns (uint);
}

abstract contract Data {
    Storage public immutable Storage;

    constructor(Storage _storage) {
        Storage = _storage;
    }
}

abstract contract TokenBalanceWrapper is Ownable, SafeMath {
    function getForwardedAccount(Data storage self, address account) internal view virtual returns (address);

    function getTokenBalance(Data storage self, string memory currency, address account) public view returns (uint balance) {
        bytes32 id = keccak256(abi.encodePacked('token.balance', currency, getForwardedAccount(self, account)));
        return self.Storage.getUint(id);
    }
}","[{'function': 'getUint', 'complexity': 0}, {'function': 'getForwardedAccount', 'complexity': 0}, {'function': 'getTokenBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""accounts""}, ""index"": {""type"": ""Identifier"", ""name"": ""account""}}, ""memberName"": ""balance""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getUint', 'complexity': 0}, {'function': 'getForwardedAccount', 'complexity': 0}, {'function': 'getTokenBalance', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    struct Account {
        address owner;
        uint256 balance;
    }

    mapping(address => Account) public accounts;

    function getBalance(address account) external view returns (uint256) {
        return accounts[account].balance;
    }
}",2.007883310317993,getBalance,"[{'function': 'getBalance', 'complexity': 0}]",1.0,21.0,0.7083764358265054,0.0163678744516226,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is how you import OpenZeppelin contracts

contract Token is Ownable {
    using SafeMath for uint256;

    struct Account {
        address owner;
        uint256 balance;
    }

    mapping(address => Account) public accounts;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            accounts[address(uint160(i << 160))] = Account({owner: address(uint160(i << 160)), balance: 1});
        }
    }

    function getBalance(address account) external view returns (uint256) {
        return accounts[account].balance;
    }
}"
5228,A getter that searches the delegationChain for the level of authority a specific delegate has within a Pledge,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledge {
    uint64 public constant NOTFOUND = type(uint64).max;
    uint64[] public delegationChain;
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function getDelegateIdx(Pledge p, uint64 idDelegate) external returns (uint64) {
        for (uint i = 0; i < p.delegationChain.length; i++) {
            if (p.delegationChain[i] == idDelegate) return uint64(i);
        }
        return NOTFOUND;
    }
}","[{'function': 'getDelegateIdx', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAuthorityLevel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_delegate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_pledgeId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_pledgeId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""delegations""}, ""memberName"": ""length""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Pledge""}, ""name"": ""pledge"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""delegations""}, ""index"": {""type"": ""Identifier"", ""name"": ""_pledgeId""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledge""}, ""memberName"": ""delegate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""TrueBody"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""authorityLevel"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, {""type"": ""WhileStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledge""}, ""memberName"": ""delegate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_delegate""}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""pledge""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""delegations""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledge""}, ""memberName"": ""delegate""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""Identifier"", ""name"": ""authorityLevel""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""pledge""}, ""memberName"": ""authorityLevel""}}}]}}, {""type"": ""Identifier"", ""name"": ""authorityLevel""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getDelegateIdx', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Delegation {
    using SafeMath for uint256;

    struct Pledge {
        address delegate;
        uint256 authorityLevel;
    }

    mapping(address => Pledge) public delegations;

    function getAuthorityLevel(address _delegate, uint256 _pledgeId) external view returns (uint256) {
        require(_pledgeId < delegations.length);
        Pledge storage pledge = delegations[_pledgeId];
        if (pledge.delegate == address(0)) return 0;
        uint256 authorityLevel = 1;
        while (pledge.delegate != _delegate) {
            pledge = delegations[pledge.delegate];
            authorityLevel += pledge.authorityLevel;
        }
        return authorityLevel;
    }
}",4.201555967330933,getAuthorityLevel,"[{'function': 'getAuthorityLevel', 'complexity': 2}]",4.0,37.0,0.6645338865173641,0.0207270220764263,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Delegation is Ownable {
    using SafeMath for uint256;

    struct Pledge {
        address delegate;
        uint256 authorityLevel;
    }

    mapping(address => Pledge) public delegations;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            delegations[addr] = Pledge({delegate: address(0), authorityLevel: 1});
        }
    }

    function getAuthorityLevel(address _delegate, uint256 _pledgeId) external view returns (uint256) {
        require(_pledgeId < 3); // Assuming the length of delegations is always 3 for this example
        Pledge storage pledge = delegations[_pledgeId];
        if (pledge.delegate == address(0)) return 0;
        uint256 authorityLevel = 1;
        while (pledge.delegate != _delegate) {
            pledge = delegations[pledge.delegate];
            authorityLevel += pledge.authorityLevel;
        }
        return authorityLevel;
    }
}"
3288,Distirbutes a different quantity of tokens to all the specified addresses,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Airdrop {
        address tokenSC;
    }

    mapping(uint => Airdrop) public airdrops;

    function distributeVariable(uint index, address[] memory _addrs, uint[] memory _vals) public onlyOwner {
        if (timeGone(index) == true) {
            Airdrop storage airdrop = airdrops[index];
            for (uint i = 0; i < _addrs.length; ++i) {
                require(SafeMath.mul(_vals[i], 1 ether) <= address(airdrop.tokenSC).balance, ""Insufficient balance"");
                airdrop.tokenSC.call(abi.encodeWithSelector(bytes4(keccak256(""transfer(address,uint256)"")), _addrs[i], _vals[i]));
            }
        } else {
            revert(""Distribution Failed: Countdown not finished yet"");
        }
    }

    function timeGone(uint index) public view returns (bool) {
        // Implement your logic to check if the countdown is finished for the given index
        return true; // Placeholder, replace with actual implementation
    }
}","[{'function': 'distributeVariable', 'complexity': 4}, {'function': 'timeGone', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""distributeTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""recipients"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Recipient list must not be empty""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amountToTransfer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipients""}, ""memberName"": ""length""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amountToTransfer""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount to transfer must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amountToTransfer""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'distributeVariable', 'complexity': 4}, {'function': 'timeGone', 'complexity': 0}]",5.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract TokenDistributor {
    using SafeMath for uint256;

    function distributeTokens(address[] memory recipients, uint256 amount) public {
        require(recipients.length > 0, ""Recipient list must not be empty"");
        require(amount > 0, ""Amount must be greater than zero"");

        for (uint256 i = 0; i < recipients.length; i++) {
            address recipient = recipients[i];
            uint256 amountToTransfer = amount.div(recipients.length);
            require(amountToTransfer > 0, ""Amount to transfer must be greater than zero"");
            recipient.transfer(amountToTransfer);
        }
    }
}",3.757262945175171,distributeTokens,"[{'function': 'distributeTokens', 'complexity': 4}]",5.0,52.0,0.6618943628379729,0.0985326379716778,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is from OpenZeppelin for Ownable

contract TokenDistributor is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function distributeTokens(address[] memory recipients, uint256 amount) public {
        require(recipients.length > 0, ""Recipient list must not be empty"");
        require(amount > 0, ""Amount must be greater than zero"");

        for (uint256 i = 0; i < recipients.length; i++) {
            address recipient = recipients[i];
            uint256 amountToTransfer = amount.div(recipients.length);
            require(amountToTransfer > 0, ""Amount to transfer must be greater than zero"");
            recipient.transfer(amountToTransfer);
        }
    }
}"
110,This method should be called by the owner before the contribution period starts This initializes most of the parameters,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function totalSupply() external view returns (uint256);
    function controller() external view returns (address);
    function decimals() external view returns (uint8);
}

interface DynamicCeiling {
    function getBlockNumber() external view returns (uint256);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    MiniMeToken public SNT;
    address public sntController;
    uint256 public startBlock;
    uint256 public endBlock;
    DynamicCeiling public dynamicCeiling;
    address public destEthDevs;
    address public destTokensReserve;
    address public destTokensSgt;
    address public destTokensDevs;
    MiniMeToken public SGT;
    uint256 public maxSGTSupply;

    function initialize(address _snt, address _sntController, uint256 _startBlock, uint256 _endBlock, address _dynamicCeiling, address _destEthDevs, address _destTokensReserve, address _destTokensSgt, address _destTokensDevs, address _sgt, uint256 _maxSGTSupply) public onlyOwner {
    require(address(SNT) == 0x0);
    SNT = MiniMeToken(_snt);
    require(SNT.totalSupply() == 0);
    require(SNT.controller() == address(this));
    require(SNT.decimals() == 18);
    require(_sntController != 0x0);
    sntController = _sntController;
    require(_startBlock >= getBlockNumber());
    require(_startBlock < _endBlock);
    startBlock = _startBlock;
    endBlock = _endBlock;
    require(_dynamicCeiling != 0x0);
    dynamicCeiling = DynamicCeiling(_dynamicCeiling);
    require(_destEthDevs != 0x0);
    destEthDevs = _destEthDevs;
    require(_destTokensReserve != 0x0);
    destTokensReserve = _destTokensReserve;
    require(_destTokensSgt != 0x0);
    destTokensSgt = _destTokensSgt;
    require(_destTokensDevs != 0x0);
    destTokensDevs = _destTokensDevs;
    require(_sgt != 0x0);
    SGT = MiniMeToken(_sgt);
    require(_maxSGTSupply >= MiniMeToken(SGT).totalSupply());
    maxSGTSupply = _maxSGTSupply;
}
}","[{'function': 'decimals', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""initializeCrowdfunding"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_contributionDeadline"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_minContributionAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_maxContributionAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_contributionDeadline""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid contribution deadline""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_minContributionAmount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Minimum contribution amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""_maxContributionAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minContributionAmount""}}, {""type"": ""stringLiteral"", ""value"": ""Maximum contribution amount must be greater than or equal to minimum contribution amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""contributionDeadline""}, ""right"": {""type"": ""Identifier"", ""name"": ""_contributionDeadline""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""minContributionAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_minContributionAmount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""maxContributionAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_maxContributionAmount""}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'decimals', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'initialize', 'complexity': 14}]",15.0,"
pragma solidity ^0.8.0;

contract Crowdfunding {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public contributors;
    uint256 public contributionDeadline;
    uint256 public totalContributions;
    uint256 public minContributionAmount;
    uint256 public maxContributionAmount;

    constructor() public {
        owner = msg.sender;
    }

    function initializeCrowdfunding(uint256 _contributionDeadline, uint256 _minContributionAmount, uint256 _maxContributionAmount) public onlyOwner {
        require(_contributionDeadline > block.timestamp, ""Invalid contribution deadline"");
        require(_minContributionAmount > 0, ""Minimum contribution amount must be greater than zero"");
        require(_maxContributionAmount >= _minContributionAmount, ""Maximum contribution amount must be greater than or equal to minimum contribution amount"");

        contributionDeadline = _contributionDeadline;
        minContributionAmount = _minContributionAmount;
        maxContributionAmount = _maxContributionAmount;
    }

    function contribute() public payable {
        require(block.timestamp < contributionDeadline, ""Contribution period has ended"");
        require(msg.value >= minContributionAmount && msg.value <= maxContributionAmount, ""Invalid contribution amount"");

        contributors[msg.sender] = true;
        totalContributions = totalContributions.add(msg.value);
    }

    function getTotalContributions() public view returns (uint256) {
        return totalContributions;
    }
}",7.56519079208374,initializeCrowdfunding,"[{'function': 'initializeCrowdfunding', 'complexity': 3}, {'function': 'contribute', 'complexity': 3}, {'function': 'getTotalContributions', 'complexity': 0}]",4.0,138.0,0.5620333367630097,0.0272697045620982,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Crowdfunding is Ownable {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public contributors;
    uint256 public contributionDeadline;
    uint256 public totalContributions;
    uint256 public minContributionAmount;
    uint256 public maxContributionAmount;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        minContributionAmount = 1;
        maxContributionAmount = 1;
    }

    function initializeCrowdfunding(uint256 _contributionDeadline, uint256 _minContributionAmount, uint256 _maxContributionAmount) public onlyOwner {
        require(_contributionDeadline > block.timestamp, ""Invalid contribution deadline"");
        require(_minContributionAmount > 0, ""Minimum contribution amount must be greater than zero"");
        require(_maxContributionAmount >= _minContributionAmount, ""Maximum contribution amount must be greater than or equal to minimum contribution amount"");

        contributionDeadline = _contributionDeadline;
        minContributionAmount = _minContributionAmount;
        maxContributionAmount = _maxContributionAmount;
    }

    function contribute() public payable {
        require(block.timestamp < contributionDeadline, ""Contribution period has ended"");
        require(msg.value >= minContributionAmount && msg.value <= maxContributionAmount, ""Invalid contribution amount"");

        contributors[msg.sender] = true;
        totalContributions = totalContributions.add(msg.value);
    }

    function getTotalContributions() public view returns (uint256) {
        return totalContributions;
    }
}"
2093,Get all details of PixelCon # ` ( _tokenIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IPixelCon {
    function totalSupply() external view returns (uint256);
}

struct PixelCon {
    uint256 tokenId;
    uint64 collectionIndex;
    uint32 dateCreated;
}

struct TokenLookup {
    address owner;
    address creator;
    uint64 tokenIndex;
}

mapping(uint256 => PixelCon) public pixelcons;
mapping(uint256 => TokenLookup) public tokenLookup;
mapping(uint256 => bytes8) public pixelconNames;

function getTokenDataByIndex(uint64 _tokenIndex, IPixelCon pixelConContract) public view returns (uint256 _tknId, uint64 _tknIdx, uint64 _collectionIdx, address _owner, address _creator, bytes8 _name, uint32 _dateCreated) {
    require(_tokenIndex < pixelConContract.totalSupply(), ""PixelCon index is out of bounds"");
    PixelCon storage pixelcon = pixelcons[_tokenIndex];
    TokenLookup storage lookupData = tokenLookup[pixelcon.tokenId];
    return (pixelcon.tokenId, lookupData.tokenIndex, pixelcon.collectionIndex, lookupData.owner, pixelcon.creator, pixelconNames[lookupData.tokenIndex], pixelcon.dateCreated);
}","[{'function': 'totalSupply', 'complexity': 0}, {'function': 'getTokenDataByIndex', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenDetails"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_tokenIndex"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""Mapping"", ""keyType"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""valueType"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""Mapping"", ""keyType"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""valueType"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""_tokenIndex""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid token index""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenDetails""}, ""name"": ""token"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""_tokenIndex""}}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""name""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""symbol""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""totalSupply""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""owners""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balances""}], ""isArray"": False}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'totalSupply', 'complexity': 0}, {'function': 'getTokenDataByIndex', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract PixelCon {
    using SafeMath for uint256;

    struct TokenDetails {
        string name;
        string symbol;
        uint256 totalSupply;
        mapping(uint256 => address) owners;
        mapping(address => uint256) balances;
    }

    TokenDetails[] public tokens;

    function getTokenDetails(uint256 _tokenIndex) external view returns (string memory, string memory, uint256, mapping(uint256 => address), mapping(address => uint256)) {
        require(_tokenIndex < tokens.length, ""Invalid token index"");
        TokenDetails storage token = tokens[_tokenIndex];
        return (token.name, token.symbol, token.totalSupply, token.owners, token.balances);
    }
}",6.651376724243164,getTokenDetails,"[{'function': 'getTokenDetails', 'complexity': 1}]",2.0,45.0,0.6367363405359346,0.120859069753335,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PixelCon is Ownable {
    using SafeMath for uint256;

    struct TokenDetails {
        string name;
        string symbol;
        uint256 totalSupply;
        mapping(uint256 => address) owners;
        mapping(address => uint256) balances;
    }

    TokenDetails[] public tokens;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        tokens.push(TokenDetails({
            name: 'initialized',
            symbol: 'TKN',
            totalSupply: 1
        }));
    }

    function getTokenDetails(uint256 _tokenIndex) external view returns (string memory, string memory, uint256, mapping(uint256 => address), mapping(address => uint256)) {
        require(_tokenIndex < tokens.length, ""Invalid token index"");
        TokenDetails storage token = tokens[_tokenIndex];
        return (token.name, token.symbol, token.totalSupply, token.owners, token.balances);
    }
}"
2971,Get the approved address for a single NFT,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 private _totalSupply;
    mapping(uint40 => address) public cutieIndexToApproved;
    mapping(uint40 => address) public cutieIndexToOwner;
    mapping(address => bool) public addressToApprovedAll;

    function getApproved(uint256 _tokenId) external view returns (address) {
        require(_tokenId <= _totalSupply());

        if (cutieIndexToApproved[uint40(_tokenId)] != address(0)) {
            return cutieIndexToApproved[uint40(_tokenId)];
        }

        address owner = cutieIndexToOwner[uint40(_tokenId)];
        return addressToApprovedAll[owner];
    }

    function _totalSupply() internal view returns (uint256) {
        return _totalSupply;
    }
}","[{'function': 'getApproved', 'complexity': 2}, {'function': '_totalSupply', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getApprovedAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""approvedAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_approve""}, ""index"": {""type"": ""Identifier"", ""name"": ""tokenId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""approvedAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token has not been approved""}], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""approvedAddress""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getApproved', 'complexity': 2}, {'function': '_totalSupply', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC721/IERC721.sol"";
import ""openzeppelin-solidity/contracts/utils/SafeMath.sol"";

contract NFTApproval is IERC721 {
    using SafeMath for uint256;

    function getApprovedAddress(uint256 tokenId) public view returns (address) {
        address approvedAddress = _approve[tokenId];
        require(approvedAddress != address(0), ""Token has not been approved"");
        return approvedAddress;
    }
}",3.0605828762054443,getApprovedAddress,"[{'function': 'getApprovedAddress', 'complexity': 1}]",2.0,23.0,0.7946120456934982,0.1743838212791232,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC721/IERC721.sol"";
import ""openzeppelin-solidity/contracts/utils/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract NFTApproval is IERC721, Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) private _approve;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getApprovedAddress(uint256 tokenId) public view returns (address) {
        address approvedAddress = _approve[tokenId];
        require(approvedAddress != address(0), ""Token has not been approved"");
        return approvedAddress;
    }
}"
2241,Gets absolute issued hardcap volume which means it will be greater than softcap value .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    uint public tokenSoftcap;
    uint public tokenHardcapIssuedValue;

    function tokenHardcapIssued() public view returns (uint) {
        return tokenSoftcap.add(tokenHardcapIssuedValue);
    }
}","[{'function': 'tokenHardcapIssued', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAbsoluteIssuedHardCapVolume"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""softcap"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""hardcap"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""hardcap""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""softcap""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'tokenHardcapIssued', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function getAbsoluteIssuedHardCapVolume(uint256 softcap, uint256 hardcap) public view returns (uint256) {
        return hardcap.sub(softcap);
    }
}",1.7395634651184082,getAbsoluteIssuedHardCapVolume,"[{'function': 'getAbsoluteIssuedHardCapVolume', 'complexity': 0}]",1.0,4.0,0.7622016894900536,0.2694353370737825,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and that Ownable contract exists

contract MyContract is Ownable {
    using SafeMath for uint256;

    function getAbsoluteIssuedHardCapVolume(uint256 softcap, uint256 hardcap) public pure returns (uint256) {
        return hardcap.sub(softcap);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        softcap = 1;
        hardcap = 2;

        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222
        ownerAddress = msg.sender;

        // bool: Set to true
        isInitialized = true;

        // string: Set to 'initialized'
        tokenName = ""MyToken"";

        // bytes32: Set to bytes32('init')
        initBytes = bytes32(0x696e6974);
    }

    uint256 public softcap;
    uint256 public hardcap;
    address public ownerAddress;
    bool public isInitialized;
    string public tokenName;
    bytes32 public initBytes;
}"
4491,Exchange ETH to SNX while insisting on a particular set of rates .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IExchange {
    function exchangeEtherForSynthetix() external payable returns (uint);
}

interface IPricing {
    function usdToEthPrice() external view returns (uint);
    function usdToSnxPrice() external view returns (uint);
}

abstract contract ExchangeWrapper is Ownable, IExchange {
    using SafeMath for uint;

    IPricing public pricing;
    bool public paused = false;

    constructor(address _pricing) {
        pricing = IPricing(_pricing);
    }

    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
    }

    function exchangeEtherForSynthetixAtRate(uint guaranteedEtherRate, uint guaranteedSynthetixRate) public payable override returns (uint) {
        require(!paused, ""Contract is paused"");
        require(guaranteedEtherRate == pricing.usdToEthPrice(), ""Guaranteed ether rate would not be received"");
        require(guaranteedSynthetixRate == pricing.usdToSnxPrice(), ""Guaranteed synthetix rate would not be received"");
        return exchangeEtherForSynthetix();
    }

    function exchangeEtherForSynthetix() public payable override returns (uint) {
        // Implementation of the actual exchange logic
        // This is a placeholder for the actual implementation
        return 0;
    }
}","[{'function': 'exchangeEtherForSynthetix', 'complexity': 0}, {'function': 'usdToSnxPrice', 'complexity': 0}, {'function': 'setPaused', 'complexity': 0}, {'function': 'exchangeEtherForSynthetixAtRate', 'complexity': 4}, {'function': 'exchangeEtherForSynthetix', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""exchange"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""ether""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect ETH value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""snxAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""rate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""snxAmount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'exchangeEtherForSynthetix', 'complexity': 0}, {'function': 'usdToSnxPrice', 'complexity': 0}, {'function': 'setPaused', 'complexity': 0}, {'function': 'exchangeEtherForSynthetixAtRate', 'complexity': 4}, {'function': 'exchangeEtherForSynthetix', 'complexity': 0}]",4.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract Exchange {
    using SafeMath for uint256;

    function exchange(uint256 amount, address payable recipient) public payable returns (bool success) {
        require(msg.value == amount.mul(1 ether), ""Incorrect ETH value"");
        require(recipient != address(0), ""Invalid recipient"");

        uint256 snxAmount = amount.div(rate);
        recipient.transfer(snxAmount);

        return true;
    }
}",2.662983655929565,exchange,"[{'function': 'exchange', 'complexity': 2}]",3.0,21.0,0.6120472054117488,0.1380813237617845,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and that Ownable contract exists

contract Exchange is Ownable {
    using SafeMath for uint256;

    uint256 public rate = 1 ether; // Placeholder value, can be adjusted based on actual requirements

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        rate = 1; // Set to safe non-corner-case value
    }

    function exchange(uint256 amount, address payable recipient) public payable returns (bool success) {
        require(msg.value == amount.mul(rate), ""Incorrect ETH value"");
        require(recipient != address(0), ""Invalid recipient"");

        uint256 snxAmount = amount.div(rate);
        recipient.transfer(snxAmount);

        return true;
    }
}"
4173,"Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract {
    using SafeMath for uint256;

    enum Error { NO_ERROR, SOME_ERROR }

    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {
        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);
        if (err != Error.NO_ERROR) {
            return (uint(err), 0, 0);
        }
        return (0, supplyValue, borrowValue);
    }

    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
        // Implement the logic of calculateAccountValuesInternal here
        // For demonstration purposes, let's assume it returns some values based on userAddress
        return (Error.NO_ERROR, 100, 50);
    }
}","[{'function': 'calculateAccountValues', 'complexity': 1}, {'function': 'calculateAccountValuesInternal', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getUserETHValues"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""supply"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""borrow"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""supplyBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""user""}, ""memberName"": ""supplyToken""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""borrowBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""user""}, ""memberName"": ""borrowToken""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""user""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""supply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""supplyBalance""}, {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""borrow""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""borrowBalance""}, {""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'calculateAccountValues', 'complexity': 1}, {'function': 'calculateAccountValuesInternal', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract UserBalances {
    using SafeMath for uint256;

    function getUserETHValues(address user) public view returns (uint256 supply, uint256 borrow) {
        // Get the user's accumulated supply balance in ETH
        uint256 supplyBalance = IERC20(user.supplyToken).balanceOf(user);

        // Get the user's accumulated borrow balance in ETH
        uint256 borrowBalance = IERC20(user.borrowToken).balanceOf(user);

        // Scale the supply and borrow balances by 10e18
        supply = SafeMath.mul(supplyBalance, 10**18);
        borrow = SafeMath.mul(borrowBalance, 10**18);
    }
}",4.672214984893799,getUserETHValues,"[{'function': 'getUserETHValues', 'complexity': 0}]",1.0,31.0,0.7010107985383477,0.0818698192408477,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract UserBalances is Ownable {
    using SafeMath for uint256;

    address public constant ETH_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual ETH address
    address public constant SUPPLY_TOKEN_ADDRESS = 0x2222222222222222222222222222222222222222; // Replace with actual supply token address
    address public constant BORROW_TOKEN_ADDRESS = 0x3333333333333333333333333333333333333333; // Replace with actual borrow token address

    bytes32 public constant INIT_BYTES32 = bytes32('init');

    uint256 public constant ETH_VALUE = 1;
    uint256 public constant SUPPLY_VALUE = 1;
    uint256 public constant BORROW_VALUE = 1;

    bool public initialized = true;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize instance variables
        ETH_ADDRESS = ETH_ADDRESS;
        SUPPLY_TOKEN_ADDRESS = SUPPLY_TOKEN_ADDRESS;
        BORROW_TOKEN_ADDRESS = BORROW_TOKEN_ADDRESS;
        initialized = true;
    }

    function getUserETHValues(address user) public view returns (uint256 supply, uint256 borrow) {
        // Get the user's accumulated supply balance in ETH
        uint256 supplyBalance = IERC20(user.supplyToken).balanceOf(user);

        // Get the user's accumulated borrow balance in ETH
        uint256 borrowBalance = IERC20(user.borrowToken).balanceOf(user);

        // Scale the supply and borrow balances by 10e18
        supply = SafeMath.mul(supplyBalance, 10**18);
        borrow = SafeMath.mul(borrowBalance, 10**18);
    }
}"
4418,Create a new payment channel between two parties,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract NettingChannelRegistry is Ownable {
    using SafeMath for uint256;

    struct Data {
        address token;
        address[][] nodeaddress_to_channeladdresses;
        mapping(bytes32 => uint) partyhash_to_channelpos;
        address[] all_channels;
        mapping(address => mapping(address => uint)) node_index;
    }

    Data data;

    function newChannel(address partner, uint settle_timeout) external returns (address) {
        Data storage self = data;
        address[] storage caller_channels = self.nodeaddress_to_channeladdresses[msg.sender];
        address[] storage partner_channels = self.nodeaddress_to_channeladdresses[partner];
        bytes32 party_hash = keccak256(abi.encodePacked(msg.sender, partner));
        uint channel_pos = self.partyhash_to_channelpos[party_hash];
        address new_channel_address = new NettingChannelContract(self.token, msg.sender, partner, settle_timeout);
        if (channel_pos != 0) {
            address settled_channel = self.all_channels[channel_pos - 1];
            require(!contractExists(settled_channel));
            uint caller_pos = self.node_index[msg.sender][partner];
            uint partner_pos = self.node_index[partner][msg.sender];
            self.all_channels[channel_pos - 1] = new_channel_address;
            caller_channels[caller_pos - 1] = new_channel_address;
            partner_channels[partner_pos - 1] = new_channel_address;
        } else {
            self.all_channels.push(new_channel_address);
            caller_channels.push(new_channel_address);
            partner_channels.push(new_channel_address);
            self.partyhash_to_channelpos[party_hash] = self.all_channels.length;
            self.node_index[msg.sender][partner] = caller_channels.length;
            self.node_index[partner][msg.sender] = partner_channels.length;
        }
        return new_channel_address;
    }

    function contractExists(address contractAddress) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(contractAddress) }
        return size > 0;
    }
}","[{'function': 'newChannel', 'complexity': 3}, {'function': 'contractExists', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createChannel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_expiration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_balance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Balance must be positive""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_expiration""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""Expiration must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""channels""}, ""index"": {""type"": ""Identifier"", ""name"": ""_sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Channel""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_sender""}, {""type"": ""Identifier"", ""name"": ""_receiver""}, {""type"": ""Identifier"", ""name"": ""_balance""}, {""type"": ""Identifier"", ""name"": ""_expiration""}], ""names"": [""sender"", ""receiver"", ""balance"", ""expiration""]}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'newChannel', 'complexity': 3}, {'function': 'contractExists', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract PaymentChannel {
    using SafeMath for uint256;

    struct Channel {
        address sender;
        address receiver;
        uint256 balance;
        uint256 expiration;
    }

    mapping(address => Channel) public channels;

    function createChannel(address _sender, address _receiver, uint256 _balance, uint256 _expiration) public {
        require(_balance > 0, ""Balance must be positive"");
        require(_expiration > block.timestamp, ""Expiration must be in the future"");

        channels[_sender] = Channel({
            sender: _sender,
            receiver: _receiver,
            balance: _balance,
            expiration: _expiration
        });
    }
}",4.341615438461304,createChannel,"[{'function': 'createChannel', 'complexity': 2}]",3.0,96.0,0.6424031099222214,0.0057354476138378,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract PaymentChannel is Ownable {
    using SafeMath for uint256;

    struct Channel {
        address sender;
        address receiver;
        uint256 balance;
        uint256 expiration;
    }

    mapping(address => Channel) public channels;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i) << 96);
            channels[addr] = Channel({
                sender: addr,
                receiver: addr,
                balance: 1,
                expiration: block.timestamp + (i * 1 days)
            });
        }
    }

    function createChannel(address _sender, address _receiver, uint256 _balance, uint256 _expiration) public {
        require(_balance > 0, ""Balance must be positive"");
        require(_expiration > block.timestamp, ""Expiration must be in the future"");

        channels[_sender] = Channel({
            sender: _sender,
            receiver: _receiver,
            balance: _balance,
            expiration: _expiration
        });
    }
}"
6848,from ` _from ` will be sended ` _value ` tokens to ` _to `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public approved;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {
        require(approved[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        approved[_from][msg.sender] = approved[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid from address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid to address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""Identifier"", ""name"": ""balance""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transfer(address _from, address _to, uint256 _value) public {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_value > 0, ""Invalid value"");

        uint256 balance = SafeMath.sub(balances[_from], _value);
        balances[_from] = balance;

        balance = SafeMath.add(balances[_to], _value);
        balances[_to] = balance;
    }
}",3.2817845344543457,transfer,"[{'function': 'transfer', 'complexity': 3}]",4.0,55.0,0.8702837665200506,0.304524582085345,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');
    string public constant DEFAULT_STRING = 'initialized';
    uint256 public constant DEFAULT_UINT = 1;

    constructor() Ownable(msg.sender) {
        balances[DEFAULT_ADDRESS] = DEFAULT_UINT;
        balances[msg.sender] = DEFAULT_UINT;
    }

    mapping(address => uint256) public balances;

    function transfer(address _from, address _to, uint256 _value) public {
        require(_from != address(0), ""Invalid from address"");
        require(_to != address(0), ""Invalid to address"");
        require(_value > 0, ""Invalid value"");

        uint256 balance = SafeMath.sub(balances[_from], _value);
        balances[_from] = balance;

        balance = SafeMath.add(balances[_to], _value);
        balances[_to] = balance;
    }
}"
967,Sets the message sender as the winner if they have completed the hunt,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GameContract is Ownable {
    using SafeMath for uint256;

    bool public grace = false;
    uint[] public locations;
    mapping(address => Hunter[]) public hunters;
    address public winner;
    uint public timeOfWin;

    struct Hunter {
        uint block;
        bytes32 encryptKey;
    }

    event WonEvent(address indexed winner);

    function checkWin(uint[] memory decryptKeys) public {
        require(!grace, ""Grace period is active"");
        require(decryptKeys.length == locations.length, ""Length of decryptKeys must match length of locations"");

        uint lastBlock = 0;
        bool won = true;

        for (uint i = 0; i < locations.length; i++) {
            require(hunters[msg.sender][i].block > lastBlock, ""Blocks must be in increasing order"");
            lastBlock = hunters[msg.sender][i].block;

            if (locations[i] != 0) {
                uint storedVal = uint(keccak256(abi.encodePacked(hunters[msg.sender][i].encryptKey ^ decryptKeys[i])));
                won = won && (locations[i] == storedVal);
            }
        }

        require(won, ""Not all conditions are met"");

        if (won) {
            timeOfWin = block.timestamp;
            winner = msg.sender;
            grace = true;
            emit WonEvent(winner);
        }
    }
}","[{'function': 'checkWin', 'complexity': 9}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""setWinner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tx""}, ""memberName"": ""origin""}}, {""type"": ""stringLiteral"", ""value"": ""Only the sender can set themselves as a winner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""winners""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""score""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Sender must have completed the hunt to be eligible for winning""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""winners""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Winner""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""winners""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""score""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": [""sender"", ""score""]}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'checkWin', 'complexity': 9}]",9.0,"
pragma solidity ^0.8.0;

contract Hunt {
    struct Winner {
        address sender;
        uint256 score;
    }

    mapping(address => Winner) public winners;

    function setWinner() external {
        require(msg.sender == tx.origin, ""Only the sender can set themselves as a winner"");
        require(winners[msg.sender].score > 0, ""Sender must have completed the hunt to be eligible for winning"");

        winners[msg.sender] = Winner({
            sender: msg.sender,
            score: winners[msg.sender].score + 1
        });
    }
}",3.044309616088867,setWinner,"[{'function': 'setWinner', 'complexity': 2}]",4.0,53.0,0.5347302430630506,0.0246570528136459,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Hunt is Ownable {
    struct Winner {
        address sender;
        uint256 score;
    }

    mapping(address => Winner) public winners;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            winners[addr] = Winner({
                sender: addr,
                score: 1
            });
        }
    }

    function setWinner() external {
        require(msg.sender == tx.origin, ""Only the sender can set themselves as a winner"");
        require(winners[msg.sender].score > 0, ""Sender must have completed the hunt to be eligible for winning"");

        winners[msg.sender] = Winner({
            sender: msg.sender,
            score: winners[msg.sender].score + 1
        });
    }
}"
5478,Allow users to buy tokens for ` _buyExchangeRate ` eth and sell tokens for ` _sellExchangeRate ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExchangeRateSetter is Ownable {
    using SafeMath for uint256;

    uint256 public sellExchangeRate;
    uint256 public buyExchangeRate;

    function setExchangeRate(uint256 _sellExchangeRate, uint256 _buyExchangeRate) public onlyOwner {
        sellExchangeRate = _sellExchangeRate;
        buyExchangeRate = _buyExchangeRate;
    }
}","[{'function': 'setExchangeRate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_buyExchangeRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setExchangeRate', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract TokenSale {
    using SafeMath for uint256;

    // State variables
    address public owner;
    uint256 public totalSupply;
    mapping(address => uint256) public balances;

    // Modifiers
    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can call this function"");
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function buyTokens(uint256 _buyExchangeRate) external onlyOwner returns (bool success) {
        // Add logic to buy tokens using the exchange rate
        return true;
    }

    function sellTokens(uint256 _sellExchangeRate) external onlyOwner returns (bool success) {
        // Add logic to sell tokens using the exchange rate
        return true;
    }
}",4.3019773960113525,buyTokens,"[{'function': 'buyTokens', 'complexity': 0}, {'function': 'sellTokens', 'complexity': 0}]",1.0,11.0,0.6576939508792804,0.0488574413997647,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    using SafeMath for uint256;

    // State variables
    address public owner = msg.sender;
    uint256 public totalSupply = 1000000000000000000;
    mapping(address => uint256) public balances;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables is already handled in the base class uint256 public totalSupply;

 constructor
    }

    function buyTokens(uint256 _buyExchangeRate) external onlyOwner returns (bool success) {
        // Add logic to buy tokens using the exchange rate
        return true;
    }

    function sellTokens(uint256 _sellExchangeRate) external onlyOwner returns (bool success) {
        // Add logic to sell tokens using the exchange rate
        return true;
    }
}"
1010,Fills a offer that has been previously made using ` makeOffer ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    // Assuming _v, _r, and _s are state variables or parameters passed to the function
    bytes32 private constant EIP191_PREFIX = 0x1901;

    constructor() Ownable() {}

    function fillOffer(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount, uint64 _nonce, uint8 v, bytes32 r, bytes32 s) external onlyOwner {
        require(_recoverAddress(keccak256(abi.encodePacked(EIP191_PREFIX, ""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce)), v, r, s) == _filler, ""Invalid signature"");
        bytes32 msgHash = keccak256(abi.encodePacked(""fillOffer"", _filler, _offerHash, _amountToTake, _feeAsset, _feeAmount, _nonce));
        _validateAndAddHash(msgHash);
        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }

    function _validateAndAddHash(bytes32 hash) internal virtual;

    function _fill(address _filler, bytes32 _offerHash, uint256 _amountToTake, address _feeAsset, uint256 _feeAmount) internal virtual;
}","[{'function': 'fillOffer', 'complexity': 1}, {'function': '_recoverAddress', 'complexity': 0}, {'function': '_validateAndAddHash', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""fillOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_offerId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_offerId""}}, ""memberName"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient offer balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Offer""}, ""name"": ""filledOffer"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""Offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_offerId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""filledOffer""}, ""memberName"": ""taker""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""filledOffer""}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_offerId""}}, ""right"": {""type"": ""Identifier"", ""name"": ""filledOffer""}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""OfferFilled""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_offerId""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'fillOffer', 'complexity': 1}, {'function': '_recoverAddress', 'complexity': 0}, {'function': '_validateAndAddHash', 'complexity': 0}]",2.0,"
pragma solidity ^0.8.0;

contract OfferContract {
    event OfferFilled(address indexed _from, uint256 indexed _offerId);

    struct Offer {
        address maker;
        address taker;
        uint256 amount;
        string currency;
    }

    mapping(uint256 => Offer) public offers;

    function fillOffer(uint256 _offerId, uint256 _amount) external {
        require(_amount > 0, ""Invalid amount"");
        require(_amount <= offers[_offerId].amount, ""Insufficient offer balance"");

        Offer memory filledOffer = Offers[_offerId];
        filledOffer.taker = msg.sender;
        filledOffer.amount -= _amount;
        offers[_offerId] = filledOffer;

        emit OfferFilled(msg.sender, _offerId);
    }
}",4.198357582092285,fillOffer,"[{'function': 'fillOffer', 'complexity': 2}]",3.0,62.0,0.7925420616884095,0.0192741412052788,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OfferContract is Ownable {
    event OfferFilled(address indexed _from, uint256 indexed _offerId);

    struct Offer {
        address maker;
        address taker;
        uint256 amount;
        string currency;
    }

    mapping(uint256 => Offer) public offers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            offers[i] = Offer({
                maker: msg.sender,
                taker: address(0),
                amount: uint256(i) * 1 ether, // Set to non-zero and safe value
                currency: ""USD""
            });
        }
    }

    function fillOffer(uint256 _offerId, uint256 _amount) external {
        require(_amount > 0, ""Invalid amount"");
        Offer storage filledOffer = offers[_offerId];
        require(_amount <= filledOffer.amount, ""Insufficient offer balance"");

        filledOffer.taker = msg.sender;
        filledOffer.amount -= _amount;

        emit OfferFilled(msg.sender, _offerId);
    }
}"
1790,Update the Synthetix Drawing Rights exchange rate based on other rates already updated .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address[] public xdrParticipants;
    mapping(address => uint256) public rates;
    mapping(string => uint256) public lastRateUpdateTimes;

    event RatesUpdated(bytes4[] currencyCode, uint256[] rate);

    function updateXDRRate(uint timeSent) external onlyOwner {
        uint total = 0;
        for (uint i = 0; i < xdrParticipants.length; i++) {
            total = rates[xdrParticipants[i]].add(total);
        }
        rates[""XDR""] = total;
        lastRateUpdateTimes[""XDR""] = timeSent;

        bytes4[] memory eventCurrencyCode = new bytes4[](1);
        eventCurrencyCode[0] = ""XDR"";

        uint[] memory eventRate = new uint[](1);
        eventRate[0] = rates[""XDR""];

        emit RatesUpdated(eventCurrencyCode, eventRate);
    }
}","[{'function': 'updateXDRRate', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateExchangeRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_drawingRights"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""_otherRates"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_drawingRights""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid drawing rights""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_otherRates""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No other rates provided""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newExchangeRate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_drawingRights""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_otherRates""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_otherRates""}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""Synthetix""}, ""memberName"": ""updateExchangeRate""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newExchangeRate""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updateXDRRate', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./Synthetix.sol"";
import ""./SafeMath.sol"";

contract SynthetixExchangeRateUpdater {
    using SafeMath for uint256;

    function updateExchangeRate(uint256 _drawingRights, uint256[] memory _otherRates) public {
        require(_drawingRights > 0, ""Invalid drawing rights"");
        require(_otherRates.length > 0, ""No other rates provided"");

        // Calculate the new exchange rate based on the other rates
        uint256 newExchangeRate = SafeMath.div(SafeMath.mul(_drawingRights, _otherRates[0]), _otherRates[1]);

        // Update the Synthetix drawing rights exchange rate with the new value
        Synthetix.updateExchangeRate(newExchangeRate);
    }
}",4.163543939590454,updateExchangeRate,"[{'function': 'updateExchangeRate', 'complexity': 2}]",3.0,70.0,0.6116605485611287,0.0240181088466159,"pragma solidity ^0.8.0;

import ""./Synthetix.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is the correct import path for Ownable

contract SynthetixExchangeRateUpdater is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        drawingRights = 1; // Set to 1 (never 0)
        otherRates = [0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222]; // Use these fixed values in order
    }

    uint256 public drawingRights;
    address[] public otherRates;

    function updateExchangeRate(uint256 _drawingRights, uint256[] memory _otherRates) public {
        require(_drawingRights > 0, ""Invalid drawing rights"");
        require(_otherRates.length > 0, ""No other rates provided"");

        // Calculate the new exchange rate based on the other rates
        uint256 newExchangeRate = SafeMath.div(SafeMath.mul(_drawingRights, _otherRates[0]), _otherRates[1]);

        // Update the Synthetix drawing rights exchange rate with the new value
        Synthetix.updateExchangeRate(newExchangeRate);
    }
}"
3704,Buy tokens from contract by sending ethereum to contract address with no minimum contribution,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    uint public buyPrice = 100; // Example price, adjust as needed
    Token token;

    mapping(address => uint256) public balanceOf;
    address public creator;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(Token _token, address _creator) {
        token = _token;
        creator = _creator;
    }

    function () external payable {
        require(msg.value > 0, ""Amount must be greater than zero"");
        uint amount = msg.value.mul(buyPrice);
        uint amountRaised;
        amountRaised = amountRaised.add(msg.value);
        require(token.balanceOf(creator) >= amount, ""Insufficient balance of creator"");
        require(msg.value > 0, ""Amount must be greater than zero"");
        token.transfer(msg.sender, amount);
        token.transfer(creator, msg.value);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': '', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid contribution""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalContributions""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalContributions""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'transfer', 'complexity': 0}, {'function': '', 'complexity': 3}]",4.0,"
pragma solidity ^0.8.0;

contract TokenSale {
    using SafeMath for uint256;

    mapping(address => uint256) public contributions;
    uint256 public totalContributions;

    function buyTokens() external payable {
        require(msg.value > 0, ""Invalid contribution"");
        contributions[msg.sender] = contributions[msg.sender].add(msg.value);
        totalContributions = totalContributions.add(msg.value);
    }
}",2.377479314804077,buyTokens,"[{'function': 'buyTokens', 'complexity': 1}]",2.0,,0.686553036771111,0.1103488495908047,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public contributions;
    uint256 public totalContributions;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        totalContributions = 1;
    }

    function buyTokens() external payable {
        require(msg.value > 0, ""Invalid contribution"");
        contributions[msg.sender] = contributions[msg.sender].add(msg.value);
        totalContributions = totalContributions.add(msg.value);
    }
}"
2468,"Decentralizes the contract , this operation can not be undone","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function removeOwnership(address _dece) public onlyOwner {
        require(_dece == 0xdece);
        owner = address(0);
        newOwnerCandidate = address(0);
        emit OwnershipRemoved();
    }
}","[{'function': 'removeOwnership', 'complexity': 1}]",2.0,{},"[{'function': 'removeOwnership', 'complexity': 1}]",2.0,"
contract DecentralizedContract {
    using SafeMath for uint256;

    address public owner;
    bool public decentralized;

    constructor() public {
        owner = msg.sender;
        decentralized = false;
    }

    function decentralizeContract(address newOwner) public {
        require(!decentralized, ""Contract is already decentralized"");
        require(msg.sender == owner, ""Only the contract owner can decentralize it"");

        // Transfer ownership to new owner
        owner = newOwner;

        // Set flag to indicate that the contract is now decentralized
        decentralized = true;
    }
}",2.9868104457855225,decentralizeContract,"[{'function': 'decentralizeContract', 'complexity': 3}]",3.0,27.0,0.5990650567349016,0.0339537544282924,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DecentralizedContract is Ownable {
    using SafeMath for uint256;

    address public owner;
    bool public decentralized;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        decentralized = false;
    }

    function decentralizeContract(address newOwner) public {
        require(!decentralized, ""Contract is already decentralized"");
        require(msg.sender == owner, ""Only the contract owner can decentralize it"");

        // Transfer ownership to new owner
        owner = newOwner;

        // Set flag to indicate that the contract is now decentralized
        decentralized = true;
    }
}"
97,This is public rather than external so it can be called by derived contracts .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    bool public paused = true;

    modifier onlyManager() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function unpause() public onlyManager {
        paused = false;
    }
}","[{'function': 'unpause', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""myFunction"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero.""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'unpause', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;
contract MyContract {
function myFunction (uint256 _amount) public returns (bool success) {
require(_amount > 0, ""Amount must be greater than zero."");
// Additional logic can be added here.
return true;
}
}",1.2895290851593018,myFunction,"[{'function': 'myFunction ', 'complexity': 1}]",2.0,11.0,0.2096909669521041,0.0139484200039977,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    uint256 public constant _INITIAL_AMOUNT = 1;
    address public constant _INITIAL_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant _INITIAL_BOOL = true;
    string public constant _INITIAL_STRING = 'initialized';
    bytes32 public constant _INITIAL_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        uint256 amount = _INITIAL_AMOUNT;
        address address = _INITIAL_ADDRESS;
        bool boolValue = _INITIAL_BOOL;
        string stringValue = _INITIAL_STRING;
        bytes32 bytes32Value = _INITIAL_BYTES32;

        // Initialize state variables
        myFunction(amount, address, boolValue, stringValue, bytes32Value);
    }

    function myFunction(uint256 amount, address address, bool boolValue, string memory stringValue, bytes32 bytes32Value) public returns (bool success) {
        require(amount > 0, ""Amount must be greater than zero."");
        // Additional logic can be added here.
        return true;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address private _owner;

    constructor(address owner) {
        _owner = owner;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}"
5181,Checks if an address ` _address ` is one of 3rd party owners ( origin owner is not included ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum Role { ROLE_THIRDPARTY_OWNER }
    mapping(address => mapping(Role => bool)) public ownerRoles;

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return ownerRoles[_address][ROLE_THIRDPARTY_OWNER];
    }
}","[{'function': 'isThirdPartyOwner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isThirdPartyOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""thirdPartyOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""_address""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isThirdPartyOwner', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Ownership {
    mapping(address => bool) public thirdPartyOwners;

    constructor() public {
        // Initialize the contract with the 3rd party owners
        thirdPartyOwners[msg.sender] = true;
    }

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return thirdPartyOwners[_address];
    }
}",2.0873332023620605,isThirdPartyOwner,"[{'function': 'isThirdPartyOwner', 'complexity': 0}]",1.0,2.0,0.9245870670053338,0.8761560783209453,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownership is Ownable {
    mapping(address => bool) public thirdPartyOwners;

    constructor() public Ownable(msg.sender) {
        // Initialize the contract with the 3rd party owners
        thirdPartyOwners[owner()] = true;
    }

    function isThirdPartyOwner(address _address) public view returns (bool) {
        return thirdPartyOwners[_address];
    }
}"
4562,"Creates a dividend with a provided checkpoint , specifying explicit excluded addresses","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ISecurityToken {
    function totalSupplyAt(uint256 checkpointId) external view returns (uint256);
    function balanceOfAt(address account, uint256 checkpointId) external view returns (uint256);
    function currentCheckpointId() external view returns (uint256);
}

abstract contract DividendManager is Ownable {
    using SafeMath for uint256;

    struct Dividend {
        uint256 checkpointId;
        uint256 creationTime;
        uint256 maturity;
        uint256 expiry;
        uint256 amount;
        uint256 totalSupply;
        uint256 claimedAmount;
        bool isClaimed;
        uint256 claimableDays;
        uint256 penaltyPercentage;
        bytes32 name;
        mapping(address => bool) dividendExcluded;
    }

    Dividend[] public dividends;
    ISecurityToken public securityToken;
    uint256 public constant EXCLUDED_ADDRESS_LIMIT = 100;

    event EtherDividendDeposited(address indexed sender, uint256 checkpointId, uint256 time, uint256 maturity, uint256 expiry, uint256 amount, uint256 totalSupply, uint256 dividendIndex, bytes32 name);

    function _createDividendWithCheckpointAndExclusions(uint256 _maturity, uint256 _expiry, uint256 _checkpointId, address[] memory _excluded, bytes32 _name) internal {
        require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, ""Too many addresses excluded"");
        require(_expiry > _maturity, ""Expiry is before maturity"");
        require(_expiry > block.timestamp, ""Expiry is in the past"");
        require(msg.value > 0, ""No dividend sent"");
        require(_checkpointId <= ISecurityToken(securityToken).currentCheckpointId(), ""Invalid checkpoint ID"");
        require(_name[0] != 0, ""Invalid name"");

        uint256 dividendIndex = dividends.length;
        uint256 currentSupply = ISecurityToken(securityToken).totalSupplyAt(_checkpointId);
        uint256 excludedSupply = 0;
        dividends.push(Dividend({
            checkpointId: _checkpointId,
            creationTime: block.timestamp,
            maturity: _maturity,
            expiry: _expiry,
            amount: msg.value,
            totalSupply: 0,
            claimedAmount: 0,
            isClaimed: false,
            claimableDays: 0,
            penaltyPercentage: 0,
            name: _name,
            dividendExcluded: new mapping(address => bool)(address(0))
        }));

        for (uint256 j = 0; j < _excluded.length; j++) {
            require(_excluded[j] != address(0), ""Invalid address"");
            require(!dividends[dividendIndex].dividendExcluded[_excluded[j]], ""Duped exclude address"");
            excludedSupply = excludedSupply.add(ISecurityToken(securityToken).balanceOfAt(_excluded[j], _checkpointId));
            dividends[dividendIndex].dividendExcluded[_excluded[j]] = true;
        }

        dividends[dividendIndex].totalSupply = currentSupply.sub(excludedSupply);
        emit EtherDividendDeposited(msg.sender, _checkpointId, block.timestamp, _maturity, _expiry, msg.value, currentSupply, dividendIndex, _name);
    }
}","[{'function': 'currentCheckpointId', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 10}]",11.0,"{""type"": ""FunctionDefinition"", ""name"": ""createDividend"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_timestamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_dividendPerShare"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_excludedAddresses"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Timestamp must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_dividendPerShare""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Dividend per share must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_excludedAddresses""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Must provide at least one excluded address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Checkpoint""}, ""name"": ""checkpoint"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Checkpoint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_timestamp""}, {""type"": ""Identifier"", ""name"": ""_dividendPerShare""}], ""names"": [""timestamp"", ""dividendPerShare""]}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_excludedAddresses""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""excludedAddresses""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_excludedAddresses""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""checkpoints""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""checkpoint""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'currentCheckpointId', 'complexity': 0}, {'function': '_createDividendWithCheckpointAndExclusions', 'complexity': 10}]",11.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Dividend {
    using SafeMath for uint256;

    struct Checkpoint {
        uint256 timestamp;
        uint256 dividendPerShare;
    }

    mapping(address => uint256) public balances;
    mapping(address => bool) public excludedAddresses;
    Checkpoint[] public checkpoints;

    function createDividend(uint256 _timestamp, uint256 _dividendPerShare, address[] memory _excludedAddresses) external {
        require(_timestamp > 0, ""Timestamp must be greater than zero"");
        require(_dividendPerShare > 0, ""Dividend per share must be greater than zero"");
        require(_excludedAddresses.length > 0, ""Must provide at least one excluded address"");

        Checkpoint memory checkpoint = Checkpoint({
            timestamp: _timestamp,
            dividendPerShare: _dividendPerShare
        });

        for (uint256 i = 0; i < _excludedAddresses.length; i++) {
            excludedAddresses[_excludedAddresses[i]] = true;
        }

        checkpoints.push(checkpoint);
    }
}",5.82089638710022,createDividend,"[{'function': 'createDividend', 'complexity': 4}]",5.0,136.0,0.8222780484088117,0.0321293852339668,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract Dividend is Ownable {
    using SafeMath for uint256;

    struct Checkpoint {
        uint256 timestamp;
        uint256 dividendPerShare;
    }

    mapping(address => uint256) public balances;
    mapping(address => bool) public excludedAddresses;
    Checkpoint[] public checkpoints;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function createDividend(uint256 _timestamp, uint256 _dividendPerShare, address[] memory _excludedAddresses) external {
        require(_timestamp > 0, ""Timestamp must be greater than zero"");
        require(_dividendPerShare > 0, ""Dividend per share must be greater than zero"");
        require(_excludedAddresses.length > 0, ""Must provide at least one excluded address"");

        Checkpoint memory checkpoint = Checkpoint({
            timestamp: _timestamp,
            dividendPerShare: _dividendPerShare
        });

        for (uint256 i = 0; i < _excludedAddresses.length; i++) {
            excludedAddresses[_excludedAddresses[i]] = true;
        }

        checkpoints.push(checkpoint);
    }
}"
6025,Adds a token deposit to ` deposits [ ] ` ; only the ` owner ` can call this function and it will only work if the account sending the tokens has called ` approve ( ) ` so that this contract can call ` transferFrom ( ) ` and take the tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenDeposit is Ownable {
    using SafeMath for uint256;

    struct Deposit {
        uint blockNumber;
        ERC20 token;
        uint amount;
    }

    Deposit[] public deposits;

    event NewDeposit(uint indexed id, ERC20 indexed token, uint amount);

    function newTokenDeposit(ERC20 _token, uint _amount, uint _block) public onlyOwner returns (uint _idDeposit) {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_block < block.number, ""Block number must be less than current block number"");
        require(_token.transferFrom(msg.sender, address(this), _amount), ""Token transfer failed"");

        _idDeposit = deposits.length;
        Deposit storage d = deposits[_idDeposit];
        d.blockNumber = _block == 0 ? block.number - 1 : _block;
        d.token = _token;
        d.amount = _amount;

        emit NewDeposit(_idDeposit, _token, _amount);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'newTokenDeposit', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addDeposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""from""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""From address cannot be zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""deposits""}, ""index"": {""type"": ""Identifier"", ""name"": ""from""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'newTokenDeposit', 'complexity': 4}]",4.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public deposits;

    constructor() public {
        owner = msg.sender;
    }

    function addDeposit(uint256 amount, address from) public onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        require(from != address(0), ""From address cannot be zero"");
        deposits[from] = deposits[from].add(amount);
    }
}",3.0192251205444336,addDeposit,"[{'function': 'addDeposit', 'complexity': 2}]",3.0,52.0,0.6641781124285093,0.1219322465486395,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""Ownable/contracts/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => uint256) public deposits;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables are already handled in the parent constructor
    }

    function addDeposit(uint256 amount, address from) public onlyOwner {
        require(amount > 0, ""Amount must be greater than zero"");
        require(from != address(0), ""From address cannot be zero"");
        deposits[from] = deposits[from].add(amount);
    }
}"
521,set the ticker registration fee in POLY tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PolyRegistration {
    using SafeMath for uint256;

    uint256 public registrationFee;

    event LogChangePolyRegisterationFee(uint256 oldFee, uint256 newFee);

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Ownable: caller is not the owner"");
        _;
    }

    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {
        require(registrationFee != _registrationFee);
        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);
        registrationFee = _registrationFee;
    }
}","[{'function': 'changePolyRegisterationFee', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTickerFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""fee""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'changePolyRegisterationFee', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeMath.sol"";

contract TickerRegistration {
    using SafeMath for uint256;

    function setTickerFee(uint256 fee) public pure returns (uint256) {
        return fee;
    }
}",1.9731810092926023,setTickerFee,"[{'function': 'setTickerFee', 'complexity': 0}]",1.0,16.0,0.5506835887542073,0.0212826943224215,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TickerRegistration is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        tickerFee = 1;
        ownerAddress = address(0x111);
        secondOwnerAddress = address(0x222);
        thirdOwnerAddress = address(0x333);
    }

    uint256 private tickerFee;
    address private ownerAddress;
    address private secondOwnerAddress;
    address private thirdOwnerAddress;

    function setTickerFee(uint256 fee) public pure returns (uint256) {
        return fee;
    }
}"
2313,Set both ico min at the same time,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoMin;
    uint256 public preIcoLimit;
    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function setIcosMinLimit(uint256 newIcoMin, uint256 newPreIcoLimit) public onlyOwner {
        require(newIcoMin > 0, ""New ICO minimum must be greater than zero"");
        require(newPreIcoLimit > 0, ""New pre-ICO limit must be greater than zero"");
        icoMin = newIcoMin;
        preIcoLimit = newPreIcoLimit;
        updatePrices();
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number, ""Block number must be greater than current block number or zero"");
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(name, url, blockNumber);
    }
}","[{'function': 'setIcosMinLimit', 'complexity': 2}, {'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIcoMin"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_icoMin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_icoMin""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""ICO min must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoMin""}, ""right"": {""type"": ""Identifier"", ""name"": ""_icoMin""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setIcosMinLimit', 'complexity': 2}, {'function': 'announceFork', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function setIcoMin(uint256 _icoMin) public {
        require(_icoMin > 0, ""ICO min must be greater than zero"");
        icoMin = _icoMin;
    }
}",1.777174949645996,setIcoMin,"[{'function': 'setIcoMin', 'complexity': 1}]",2.0,17.0,0.802563192011639,0.1562009673815797,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public icoMin;

    constructor() Ownable(msg.sender) {
        icoMin = 1;
    }

    function setIcoMin(uint256 _icoMin) public {
        require(_icoMin > 0, ""ICO min must be greater than zero"");
        icoMin = _icoMin;
    }
}"
1838,Keep a US Citizen 's tokens for one year .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenHolder is Ownable {
    using SafeMath for uint256;

    struct Holding {
        uint256 quantity;
        uint256 releaseDate;
        bool claimed;
    }

    mapping(address => Holding) public heldTokens;
    event TokensHeld(address indexed who, uint256 quantity, uint256 releaseDate);

    function hold(address who, uint256 quantity) public onlyOwner {
        require(who != address(0), ""The null address cannot own tokens."");
        require(quantity > 0, ""Quantity must be greater than zero."");
        require(!isExistingHolding(who), ""Cannot overwrite an existing holding, use a new wallet."");

        Holding memory holding = Holding(quantity, block.timestamp + oneYear, false);
        heldTokens[who] = holding;
        emit TokensHeld(who, holding.quantity, holding.releaseDate);
    }

    function isExistingHolding(address who) internal view returns (bool) {
        return heldTokens[who].quantity > 0;
    }

    uint256 constant oneYear = 365 days;
}","[{'function': 'hold', 'complexity': 4}, {'function': 'isExistingHolding', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""keepTokenForOneYear"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_holder"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_holder""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid holder address""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""TokenHolder""}, ""name"": ""holder"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holder""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""expiryDate""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""expiryDate""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""365"", ""subdenomination"": ""days""}}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""amount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""expiryDate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holder""}, ""memberName"": ""expiryDate""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""365"", ""subdenomination"": ""days""}], ""names"": []}}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""holders""}, ""index"": {""type"": ""Identifier"", ""name"": ""_holder""}}, ""right"": {""type"": ""Identifier"", ""name"": ""holder""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'hold', 'complexity': 4}, {'function': 'isExistingHolding', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";

contract CitizenToken {
    using SafeMath for uint256;

    struct TokenHolder {
        address holder;
        uint256 amount;
        uint256 expiryDate;
    }

    mapping(address => TokenHolder) public holders;

    function keepTokenForOneYear(address _holder, uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_holder != address(0), ""Invalid holder address"");

        TokenHolder memory holder = holders[_holder];

        if (holder.expiryDate < block.timestamp) {
            holder.amount = _amount;
            holder.expiryDate = block.timestamp + 365 days;
        } else {
            holder.amount = holder.amount.add(_amount);
            holder.expiryDate = holder.expiryDate.add(365 days);
        }

        holders[_holder] = holder;
    }
}",5.391714572906494,keepTokenForOneYear,"[{'function': 'keepTokenForOneYear', 'complexity': 3}]",4.0,38.0,0.6629275441152599,0.1673139754768232,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CitizenToken is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    struct TokenHolder {
        address holder;
        uint256 amount;
        uint256 expiryDate;
    }

    mapping(address => TokenHolder) public holders;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            holders[addr] = TokenHolder({holder: addr, amount: 1, expiryDate: block.timestamp + 365 days});
        }
    }

    function keepTokenForOneYear(address _holder, uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(_holder != address(0), ""Invalid holder address"");

        TokenHolder memory holder = holders[_holder];

        if (holder.expiryDate < block.timestamp) {
            holder.amount = _amount;
            holder.expiryDate = block.timestamp + 365 days;
        } else {
            holder.amount = holder.amount.add(_amount);
            holder.expiryDate = holder.expiryDate.add(365 days);
        }

        holders[_holder] = holder;
    }
}"
6404,Adds multiple addresses to the administrator list .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AdminManagement is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public admins;

    event AdminAdded(address indexed account);

    function addManyAdmins(_accounts: address[]) external onlyOwner returns (bool) {
        for (uint8 i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            if (account != address(0) && !admins[account] && account != owner()) {
                admins[account] = true;
                emit AdminAdded(_accounts[i]);
            }
        }
        return true;
    }
}","[{'function': 'addManyAdmins', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""addAdministrators"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_administrators"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_administrators""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""At least one administrator must be provided""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_administrators""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""administrators""}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_administrators""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'addManyAdmins', 'complexity': 3}]",5.0,"
pragma solidity ^0.8.0;

contract AddAdministrators {
    using SafeMath for uint256;

    address[] public administrators;

    function addAdministrators(address[] memory _administrators) public {
        require(_administrators.length > 0, ""At least one administrator must be provided"");

        for (uint256 i = 0; i < _administrators.length; i++) {
            administrators.push(_administrators[i]);
        }
    }
}",2.352024555206299,addAdministrators,"[{'function': 'addAdministrators', 'complexity': 2}]",3.0,34.0,0.6578295531086968,0.1242974230832681,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract AddAdministrators {
    using SafeMath for uint256;

    address[] public administrators;
    bool public initialized = true;
    bytes32 public constant initBytes32 = bytes32('init');

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function addAdministrators(address[] memory _administrators) public {
        require(_administrators.length > 0, ""At least one administrator must be provided"");

        for (uint256 i = 0; i < _administrators.length; i++) {
            administrators.push(_administrators[i]);
        }
    }

    function initialize() public {
        if (!initialized) {
            initialized = true;
            // Initialize other state variables here
        }
    }
}"
892,Sets the default fee for burning CarbonDollar into a whitelisted stablecoin .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public defaultFee;

    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);

    function setDefaultFee(uint256 _fee) public onlyOwner {
        uint256 oldFee = defaultFee;
        defaultFee = _fee;
        if (oldFee != defaultFee) {
            emit DefaultFeeChanged(oldFee, _fee);
        }
    }
}","[{'function': 'setDefaultFee', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBurnFee"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_burnFee"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_whitelistedStablecoin"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_burnFee""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid burn fee""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_whitelistedStablecoin""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid whitelisted stablecoin""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whitelist""}, ""index"": {""type"": ""Identifier"", ""name"": ""_whitelistedStablecoin""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setDefaultFee', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract BurnFee {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public whitelist;

    constructor() public {
        owner = msg.sender;
    }

    function setBurnFee(uint256 _burnFee, address _whitelistedStablecoin) external onlyOwner {
        require(_burnFee > 0, ""Invalid burn fee"");
        require(_whitelistedStablecoin != address(0), ""Invalid whitelisted stablecoin"");
        whitelist[_whitelistedStablecoin] = true;
    }
}",3.011104106903076,setBurnFee,"[{'function': 'setBurnFee', 'complexity': 2}]",3.0,18.0,0.6107641808470615,0.0207434082863115,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BurnFee is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => bool) public whitelist;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables as per the rules:
        // - uint/uint256: Set to 1 (never 0)
        // - address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // - bool: Set to true
        // - string: Set to 'initialized'
        // - bytes32: Set to bytes32('init')
        // - For ERC20 or similar constructors requiring arguments, use placeholder values like 'MyToken'
        // Avoid setting any value to its zero/default state
    }

    function setBurnFee(uint256 _burnFee, address _whitelistedStablecoin) external onlyOwner {
        require(_burnFee > 0, ""Invalid burn fee"");
        require(_whitelistedStablecoin != address(0), ""Invalid whitelisted stablecoin"");
        whitelist[_whitelistedStablecoin] = true;
    }
}"
3332,"Gets all the open data orders , that is all the DataOrders that are still receiving new DataResponses .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract OpenOrdersWrapper is Ownable {
    using SafeMath for uint256;

    struct Order {
        address userAddress;
        uint256 amount;
    }

    mapping(uint256 => Order) public orders;
    uint256 public orderCount;

    function getOpenOrders() public view returns (address[] memory) {
        address[] memory openOrders = new address[](orderCount);
        for (uint256 i = 0; i < orderCount; i++) {
            openOrders[i] = orders[i].userAddress;
        }
        return openOrders;
    }
}","[{'function': 'getOpenOrders', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getOpenDataOrders"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""DataOrder""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""DataOrder""}, ""length"": None}, ""name"": ""orders"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""DataOrder""}, ""length"": None}}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""openDataOrders""}, ""memberName"": ""length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""orders""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""orders""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""openDataOrders""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}]}}, {""type"": ""Identifier"", ""name"": ""orders""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getOpenOrders', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./DataOrder.sol"";

contract DataMarket {
    mapping(address => uint256) public openDataOrders;

    function getOpenDataOrders() public view returns (DataOrder[] memory) {
        DataOrder[] memory orders = new DataOrder[](openDataOrders.length);
        for (uint256 i = 0; i < orders.length; i++) {
            orders[i] = openDataOrders[i];
        }
        return orders;
    }
}",2.5233607292175293,getOpenDataOrders,"[{'function': 'getOpenDataOrders', 'complexity': 1}]",2.0,6.0,0.8743891284832204,0.4347172946578883,"pragma solidity ^0.8.0;

import ""./Ownable.sol""; // Assuming Ownable is imported correctly from a standard library or another contract
import ""./DataOrder.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DataMarket is Ownable {
    mapping(address => uint256) public openDataOrders;

    constructor() Ownable(msg.sender) {
        for (uint256 i = 0; i < 10; i++) { // Initialize up to a reasonable number of orders, adjust as needed
            openDataOrders[address(i)] = 1; // Set each order to 1
        }
    }

    function getOpenDataOrders() public view returns (DataOrder[] memory) {
        DataOrder[] memory orders = new DataOrder[](openDataOrders.length);
        for (uint256 i = 0; i < orders.length; i++) {
            orders[i] = openDataOrders[address(i)]; // Assuming addresses are used as keys in the mapping
        }
        return orders;
    }
}"
2110,Sets a new converter ramp to delegate the pay of the loan,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public converterRamp;

    event SetConverterRamp(address oldConverterRamp, address newConverterRamp);

    function setConverterRamp(address _converterRamp) external onlyOwner returns (bool) {
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }
}","[{'function': 'setConverterRamp', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setRamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newRamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""New ramp must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_ramp""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRamp""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setConverterRamp', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract LoanConverter {
    using SafeMath for uint256;

    function setRamp(uint256 newRamp) public {
        // Additional logic can be added here
        require(newRamp > 0, ""New ramp must be greater than zero"");
        _ramp = newRamp;
    }

    function convert(uint256 amount) public view returns (uint256) {
        // Additional logic can be added here
        return amount.mul(_ramp);
    }
}",2.751291036605835,setRamp,"[{'function': 'setRamp', 'complexity': 1}, {'function': 'convert', 'complexity': 0}]",2.0,9.0,0.6527835867984183,0.0173130613399777,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract LoanConverter is Ownable {
    using SafeMath for uint256;

    uint256 private _ramp = 1; // Set to 1 (never 0)

    constructor() Ownable(msg.sender) {
        // Additional logic can be added here
    }

    function setRamp(uint256 newRamp) public {
        require(newRamp > 0, ""New ramp must be greater than zero"");
        _ramp = newRamp;
    }

    function convert(uint256 amount) public view returns (uint256) {
        return amount.mul(_ramp);
    }
}"
1438,Increase the amount of tokens that an owner allowed to a spender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;
    mapping(bytes => bool) public signatures;
    mapping(address => mapping(address => uint256)) public allowed;
    mapping(address => uint256) public balances;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event ApprovalPreSigned(address indexed owner, address indexed spender, address indexed delegate, uint256 value, uint256 fee);

    function increaseApprovalPreSignedHashing(address _token, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_token, _spender, _addedValue, _fee, _nonce));
    }

    function recover(bytes32 _hash, bytes memory _signature) public pure returns (address) {
        return ecrecover(_hash, 27 + uint8(_signature[64]), bytes32(_signature[:32]), bytes32(_signature[32:64]));
    }

    function increaseApprovalPreSigned(bytes memory _signature, address _spender, uint256 _addedValue, uint256 _fee, uint256 _nonce) public returns (bool) {
        require(_spender != address(0), ""Spender address is not provided"");
        require(signatures[_signature] == false, ""No Signature"");
        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);
        address from = recover(hashedTx, _signature);
        require(from != address(0), ""From address is not provided"");
        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);
        balances[from] = balances[from].sub(_fee);
        balances[msg.sender] = balances[msg.sender].add(_fee);
        signatures[_signature] = true;
        emit Approval(from, _spender, allowed[from][_spender]);
        emit Transfer(from, msg.sender, _fee);
        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);
        return true;
    }
}","[{'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'increaseApprovalPreSigned', 'complexity': 3}]",4.0,{},"[{'function': 'increaseApprovalPreSignedHashing', 'complexity': 0}, {'function': 'recover', 'complexity': 0}, {'function': 'increaseApprovalPreSigned', 'complexity': 3}]",4.0,"
contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private _allowances;

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0), ""ERC20: approve from the zero address"");

        _allowances[msg.sender][spender] = _allowances[msg.sender][spender].add(addedValue);

        emit Approval(msg.sender, spender, addedValue);

        return true;
    }
}",2.6808996200561523,increaseAllowance,"[{'function': 'increaseAllowance', 'complexity': 1}]",2.0,0.0,0.7274214554696827,0.0551955070183609,"contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _allowances;

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        require(spender != address(0), ""ERC20: approve from the zero address"");

        _allowances[msg.sender][spender] = _allowances[msg.sender][spender].add(addedValue);

        emit Approval(msg.sender, spender, addedValue);

        return true;
    }

    constructor() public Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _allowances[address(0x111)] = 1;
        _allowances[address(0x222)] = 1;
        _allowances[address(0x333)] = 1;
    }
}"
2532,Remove an address owned by a holder .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract HolderManager is Ownable {
    using SafeMath for uint256;

    struct HoldersData {
        mapping(address => uint) address2Index;
        mapping(uint => address) index2Address;
        uint holderAddressCount;
    }

    mapping(bytes32 => uint) public holderIndex;
    mapping(address => bytes32) public holderAddress2Id;
    HoldersData[] public holders;

    event HolderAddressRemoved(bytes32 indexed externalHolderId, address indexed removedAddress, uint holderIndex);

    function removeHolderAddress(bytes32 _externalHolderId, address _address) onlyOracleOrOwner external returns (uint) {
        uint _holderIndex = holderIndex[_externalHolderId];
        require(_holderIndex != 0);
        HoldersData storage _holderData = holders[_holderIndex];
        uint _tempIndex = _holderData.address2Index[_address];
        require(_tempIndex != 0);
        address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];
        _holderData.address2Index[_lastAddress] = _tempIndex;
        _holderData.index2Address[_tempIndex] = _lastAddress;
        delete _holderData.address2Index[_address];
        _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);
        delete holderAddress2Id[_address];
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
        return OK;
    }

    function _emitHolderAddressRemoved(bytes32 _externalHolderId, address _address, uint _holderIndex) internal {
        emit HolderAddressRemoved(_externalHolderId, _address, _holderIndex);
    }
}","[{'function': 'removeHolderAddress', 'complexity': 2}, {'function': '_emitHolderAddressRemoved', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""toRemove"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_owners""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only owners can remove ownership""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_owners""}, ""index"": {""type"": ""Identifier"", ""name"": ""toRemove""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'removeHolderAddress', 'complexity': 2}, {'function': '_emitHolderAddressRemoved', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract OwnedAddresses {
    using SafeMath for uint256;

    mapping(address => bool) private _owners;

    function removeOwnership(address owner, address toRemove) public {
        require(_owners[owner], ""Only owners can remove ownership"");
        _owners[toRemove] = false;
    }
}",2.063659429550171,removeOwnership,"[{'function': 'removeOwnership', 'complexity': 1}]",2.0,76.0,0.5946979175371763,0.0046260879383967,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";

contract OwnedAddresses {
    using SafeMath for uint256;

    mapping(address => bool) private _owners;

    constructor() {
        // Initialize the owner with a fixed address
        _owners[msg.sender] = true;
    }

    function removeOwnership(address owner, address toRemove) public {
        require(_owners[owner], ""Only owners can remove ownership"");
        _owners[toRemove] = false;
    }
}"
339,Returns all the relevant information about a specific card .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CardInterface {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
    }

    mapping(uint256 => address) public cardTokenToOwner;
    mapping(uint256 => uint256) public cardTokenToPosition;
    Card[] public cards;

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token) {
        address owner = cardTokenToOwner[_tokenId];
        require(owner != address(0));
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
    }
}","[{'function': 'getCard', 'complexity': 0}, {'function': 'getCard', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCardInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""CardInfo""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""CardInfo""}, ""name"": ""card"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CardInfo""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""id""}, {""type"": ""stringLiteral"", ""value"": ""Card Name""}, {""type"": ""stringLiteral"", ""value"": ""Card Description""}, {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""50"", ""subdenomination"": None}, {""type"": ""NumberLiteral"", ""number"": ""25"", ""subdenomination"": None}], ""names"": [""id"", ""name"", ""description"", ""rarity"", ""level"", ""health"", ""attack"", ""defense""]}}, {""type"": ""Identifier"", ""name"": ""card""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getCard', 'complexity': 0}, {'function': 'getCard', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract Card {
    struct CardInfo {
        uint256 id;
        string name;
        string description;
        uint256 rarity;
        uint256 level;
        uint256 health;
        uint256 attack;
        uint256 defense;
    }

    function getCardInfo(uint256 id) public view returns (CardInfo memory) {
        CardInfo memory card = CardInfo({
            id: id,
            name: ""Card Name"",
            description: ""Card Description"",
            rarity: 0,
            level: 1,
            health: 100,
            attack: 50,
            defense: 25
        });

        return card;
    }
}",3.5557727813720703,getCardInfo,"[{'function': 'getCardInfo', 'complexity': 0}]",1.0,36.0,0.6533329280308574,0.0951680740533635,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Card is Ownable {
    struct CardInfo {
        uint256 id;
        string name;
        string description;
        uint256 rarity;
        uint256 level;
        uint256 health;
        uint256 attack;
        uint256 defense;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        CardInfo memory card = CardInfo({
            id: 1,
            name: ""Card Name"",
            description: ""Card Description"",
            rarity: 1,
            level: 1,
            health: 100,
            attack: 50,
            defense: 25
        });
    }

    function getCardInfo(uint256 id) public view returns (CardInfo memory) {
        CardInfo memory card = CardInfo({
            id: id,
            name: ""Card Name"",
            description: ""Card Description"",
            rarity: 0,
            level: 1,
            health: 100,
            attack: 50,
            defense: 25
        });

        return card;
    }
}"
4993,"Reclaim an expired , non-empty swap into a multisig","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    struct Multisig {
        address owner;
        address authority;
        uint deposit;
    }

    struct Swap {
        uint amount;
        uint expirationTime;
    }

    mapping(bytes32 => Multisig) public hashIdToMultisig;
    mapping(bytes32 => Swap) public hashIdToSwap;

    function reclaimExpiredSwaps(bytes32 msigId, bytes32 swapId) public {
        require(hashIdToMultisig[msigId].owner == msg.sender || hashIdToMultisig[msigId].authority == msg.sender, ""Only the owner or authority of the multisig can reclaim expired swaps"");
        require(block.timestamp >= hashIdToSwap[swapId].expirationTime, ""The swap has not yet expired"");
        uint amount = hashIdToSwap[swapId].amount;
        assert(hashIdToMultisig[msigId].deposit.add(amount) >= hashIdToMultisig[msigId].deposit, ""Insufficient funds in the multisig to reclaim the swap"");
        delete hashIdToSwap[swapId];
        hashIdToMultisig[msigId].deposit = hashIdToMultisig[msigId].deposit.add(amount);
    }
}","[{'function': 'reclaimExpiredSwaps', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""reclaimExpiredSwap"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""expiration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""multisig"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""expiration""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""stringLiteral"", ""value"": ""Invalid swap""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""multisigBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Multisig""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""multisig""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""multisigBalance""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Multisig""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""multisig""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'reclaimExpiredSwaps', 'complexity': 4}]",5.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";
import ""./Multisig.sol"";

contract ReclaimSwap {
    using SafeMath for uint256;

    function reclaimExpiredSwap(uint256 expiration, address multisig) public returns (bool success) {
        // Check if the swap is expired and not empty
        require(block.timestamp > expiration && msg.value > 0, ""Invalid swap"");

        // Get the current balance of the multisig contract
        uint256 multisigBalance = Multisig(multisig).balanceOf(address(this));

        // Check if the multisig has enough balance to cover the swap amount
        require(multisigBalance >= msg.value, ""Insufficient funds"");

        // Transfer the expired swap amount to the multisig contract
        Multisig(multisig).transferFrom(address(this), msg.sender, msg.value);

        return true;
    }
}",4.587077856063843,reclaimExpiredSwap,"[{'function': 'reclaimExpiredSwap', 'complexity': 3}]",4.0,49.0,0.8179879685719593,0.0325624444246206,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Multisig.sol"";
import ""./Ownable.sol"";

contract ReclaimSwap is Multisig, Ownable {
    using SafeMath for uint256;

    // Fixed values for initialization
    address public constant MULTISIG_ADDRESS = 0x1111111111111111111111111111111111111111;
    address public constant DEFAULT_SENDER = 0x2222222222222222222222222222222222222222;
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize instance variables
        multisigAddress_ = MULTISIG_ADDRESS;
        senderAddress_ = DEFAULT_SENDER;
        initialized_ = initialized;
        initBytes32_ = INIT_BYTES32;
    }

    address public multisigAddress_;
    address public senderAddress_;
    bool public initialized_;
    bytes32 public initBytes32_;

    function reclaimExpiredSwap(uint256 expiration, address recipient) public returns (bool success) {
        // Check if the swap is expired and not empty
        require(block.timestamp > expiration && msg.value > 0, ""Invalid swap"");

        // Get the current balance of the multisig contract
        uint256 multisigBalance = Multisig(multisigAddress_).balanceOf(address(this));

        // Check if the multisig has enough balance to cover the swap amount
        require(multisigBalance >= msg.value, ""Insufficient funds"");

        // Transfer the expired swap amount to the recipient contract
        Multisig(multisigAddress_).transferFrom(address(this), recipient, msg.value);

        return true;
    }
}"
5531,Revoke vote for transaction Can be called only by authorized user,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RevokeWrapper {
    using SafeMath for uint256;

    function revoke(bytes32 _key) external returns (uint256) {
        return _revoke(_key, msg.sender);
    }

    function _revoke(bytes32 _key, address _account) internal virtual returns (uint256) {
        // Implementation of the revoke logic
    }
}","[{'function': 'revoke', 'complexity': 0}, {'function': '_revoke', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""revokeVote"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""transactionId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Transaction""}, ""name"": ""transaction"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""transactions""}, ""index"": {""type"": ""Identifier"", ""name"": ""transactionId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""transaction""}, ""memberName"": ""revoked""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Transaction already revoked""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""transaction""}, ""memberName"": ""revoked""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyAuthorized"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'revoke', 'complexity': 0}, {'function': '_revoke', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;
contract Voting {
    using SafeMath for uint256;
    struct Transaction {
        address sender;
        address recipient;
        uint256 amount;
        bool revoked;
    }
    mapping(uint256 => Transaction) public transactions;
    modifier onlyAuthorized() {
        require(msg.sender == owner, ""Only authorized user can revoke vote"");
        _;
    }
    function revokeVote(uint256 transactionId) public onlyAuthorized {
        Transaction storage transaction = transactions[transactionId];
        require(!transaction.revoked, ""Transaction already revoked"");
        transaction.revoked = true;
    }
}",3.169178009033203,revokeVote,"[{'function': 'revokeVote', 'complexity': 2}]",2.0,17.0,0.5441966930058681,0.0262503687370089,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Voting {
    using SafeMath for uint256;

    struct Transaction {
        address sender;
        address recipient;
        uint256 amount;
        bool revoked;
    }

    mapping(uint256 => Transaction) public transactions;
    address public owner = 0x1111111111111111111111111111111111111111; // fixed address
    bool public initialized = true; // set to true

    constructor() Ownable(msg.sender) {
        // Initialize instance variables with fixed, safe values
        owner = 0x1111111111111111111111111111111111111111; // fixed address
        initialized = true; // set to true
    }

    modifier onlyAuthorized() {
        require(msg.sender == owner, ""Only authorized user can revoke vote"");
        _;
    }

    function revokeVote(uint256 transactionId) public onlyAuthorized {
        Transaction storage transaction = transactions[transactionId];
        require(!transaction.revoked, ""Transaction already revoked"");
        transaction.revoked = true;
    }
}"
6063,A user has redeemed a top-up voucher for phone credit .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract VoucherRedemption {
    using SafeMath for uint256;

    mapping(address => Order) public orderBook;

    struct Order {
        uint256 price;
    }

    event VoucherRedeemed(uint256 voucherCode, address indexed voucherOwner, address indexed tokenSeller, uint256 quantity);

    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function redeemVoucher(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity) public payable onlyOwner {
        buy(tokenSeller, quantity, orderBook[tokenSeller].price);
        emit VoucherRedeemed(voucherCode, voucherOwner, tokenSeller, quantity);
    }

    function buy(address tokenSeller, uint256 quantity, uint256 price) internal {
        // Implementation of the buy logic
    }

    address private _owner;

    constructor() {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}","[{'function': 'redeemVoucher', 'complexity': 0}, {'function': 'buy', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""redeem"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""user""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid user""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""user""}, ""memberName"": ""balance""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""user""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newBalance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'redeemVoucher', 'complexity': 0}, {'function': 'buy', 'complexity': 0}, {'function': 'owner', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract TopUpVoucher {
    using SafeMath for uint256;

    function redeem(uint256 amount, address user) public {
        require(amount > 0, ""Invalid amount"");
        require(user != address(0), ""Invalid user"");

        // Additional logic can be added here

        uint256 newBalance = SafeMath.add(user.balance, amount);
        user.transfer(newBalance);
    }
}",2.663750648498535,redeem,"[{'function': 'redeem', 'complexity': 2}]",3.0,30.0,0.5940723063684916,0.0335421176966724,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract TopUpVoucher is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _owner = msg.sender; // address initialization
        initialized = true; // bool initialization
        tokenName = 'MyToken'; // string initialization for ERC20 placeholder
    }

    function redeem(uint256 amount, address user) public {
        require(amount > 0, ""Invalid amount"");
        require(user != address(0), ""Invalid user"");

        uint256 newBalance = SafeMath.add(user.balance, amount);
        user.transfer(newBalance);
    }
}"
6774,"Move to ceiling , used as a failsafe","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    uint256 public currentIndex = 0;

    function moveToNextCeiling() public onlyOwner {
        currentIndex = currentIndex.add(1);
    }
}","[{'function': 'moveToNextCeiling', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""moveToCeiling"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""totalSupply""}, ""arguments"": [], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newTotalSupply"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ceiling"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""ceiling""}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""newTotalSupply""}, ""right"": {""type"": ""Identifier"", ""name"": ""ceiling""}}, {""type"": ""stringLiteral"", ""value"": ""Exceeds ceiling""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'moveToNextCeiling', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract Ceiling {
    using SafeMath for uint256;

    function moveToCeiling(uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        uint256 totalSupply = IERC20(address(this)).totalSupply();
        uint256 newTotalSupply = totalSupply.add(_amount);
        uint256 ceiling = IERC20(address(this)).ceiling();
        require(newTotalSupply <= ceiling, ""Exceeds ceiling"");
        IERC20(address(this)).transferFrom(msg.sender, address(this), _amount);
    }
}",5.174280643463135,moveToCeiling,"[{'function': 'moveToCeiling', 'complexity': 2}]",3.0,55.0,0.6389762320440489,0.0171435569867059,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ceiling {
    using SafeMath for uint256;
    address public constant ZERO_ADDRESS = 0x0000000000000000000000000000000000000000;
    address public constant INIT_ADDRESS = 0x1111111111111111111111111111111111111111;
    bool public initialized = true;
    bytes32 public initBytes = bytes32('init');
    uint256 public totalSupply = 1000000000000000000;
    uint256 public ceiling = 10000000000;

    uint256 public totalSupply;

 constructor() Ownable(INIT_ADDRESS) {
        require(initialized == false, ""Contract already initialized"");
        initialized = true;
        emit Initialized();
    }

    function moveToCeiling(uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        uint256 newTotalSupply = totalSupply.add(_amount);
        require(newTotalSupply <= ceiling, ""Exceeds ceiling"");
        IERC20(address(this)).transferFrom(msg.sender, address(this), _amount);
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address public owner;

    uint256 public totalSupply;

 constructor(address _owner) public {
        require(_owner != ZERO_ADDRESS, ""Owner cannot be zero address"");
        owner = _owner;
    }

    function transferOwnership(address newOwner) public {
        require(newOwner != ZERO_ADDRESS, ""New owner cannot be zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract IERC20 {
    function totalSupply() public view returns uint256 {}
    function ceiling() public view returns uint256 {}
    function transferFrom(address recipient, address sender, uint256 amount) public virtual returns (bool) {}
}"
1493,A function which allows only the owner to change the address of totlePrimary,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;
    address public totlePrimary;

    function setTotle(address _totlePrimary) external onlyOwner {
        require(_totlePrimary != address(0x0));
        totlePrimary = _totlePrimary;
    }
}","[{'function': 'setTotle', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setTotlePrimary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_totlePrimary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_totlePrimary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totlePrimary""}, ""right"": {""type"": ""Identifier"", ""name"": ""_totlePrimary""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setTotle', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

contract TotlePrimaryManager {
    address public owner;
    address public totlePrimary;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Not the owner"");
        _;
    }

    function setTotlePrimary(address _totlePrimary) external onlyOwner {
        require(_totlePrimary != address(0), ""Invalid address"");
        totlePrimary = _totlePrimary;
    }
}",1.701791763305664,setTotlePrimary,"[{'function': 'setTotlePrimary', 'complexity': 1}]",2.0,1.0,0.9583231728202708,0.6636859108766658,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TotlePrimaryManager is Ownable {
    address public totlePrimary;

    constructor() Ownable(msg.sender) {
        totlePrimary = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner(), ""Not the owner"");
        _;
    }

    function setTotlePrimary(address _totlePrimary) external onlyOwner {
        require(_totlePrimary != address(0), ""Invalid address"");
        totlePrimary = _totlePrimary;
    }
}"
6875,Allow the token holder to upgrade some of their tokens to the new contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IUpgradeAgent {
    function upgradeFrom(address _from, uint256 _value) external;
}

abstract contract UpgradeableToken is Ownable {
    using SafeMath for uint256;

    enum UpgradeState { Unknown, NotAllowedToUpgrade, ReadyToUpgrade, Upgrading }

    mapping(address => uint256) public balances;
    uint256 public totalSupply_;
    uint256 public totalUpgraded;
    IUpgradeAgent public upgradeAgent;

    event Upgrade(address indexed _from, IUpgradeAgent indexed _agent, uint256 _value);

    function getUpgradeState() public view returns (UpgradeState) {
        if (!isAllowedToUpgrade()) return UpgradeState.NotAllowedToUpgrade;
        if (totalUpgraded == 0 && totalSupply_ > 0) return UpgradeState.ReadyToUpgrade;
        if (totalUpgraded > 0 && totalUpgraded < totalSupply_) return UpgradeState.Upgrading;
        return UpgradeState.Unknown;
    }

    function isAllowedToUpgrade() internal view returns (bool) {
        // Implement your logic to check if the caller is allowed to upgrade
        return true;
    }

    function upgrade(uint256 _value) public {
        require(getUpgradeState() == UpgradeState.ReadyToUpgrade || getUpgradeState() == UpgradeState.Upgrading, ""State must be correct for upgrade"");
        require(_value > 0, ""Upgrade value must be greater than zero"");

        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        totalUpgraded = totalUpgraded.add(_value);

        upgradeAgent.upgradeFrom(msg.sender, _value);
        emit Upgrade(msg.sender, upgradeAgent, _value);
    }
}","[{'function': 'upgradeFrom', 'complexity': 0}, {'function': 'getUpgradeState', 'complexity': 3}, {'function': 'isAllowedToUpgrade', 'complexity': 0}, {'function': 'upgrade', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""upgradeTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newBalance""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'upgradeFrom', 'complexity': 0}, {'function': 'getUpgradeState', 'complexity': 3}, {'function': 'isAllowedToUpgrade', 'complexity': 0}, {'function': 'upgrade', 'complexity': 3}]",5.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    function upgradeTokens(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than zero"");
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        uint256 newBalance = balances[msg.sender].sub(amount);
        balances[msg.sender] = newBalance;
    }
}",2.8190484046936035,upgradeTokens,"[{'function': 'upgradeTokens', 'complexity': 2}]",3.0,42.0,0.6393855081846391,0.1349739951281154,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[owner()] = 1; // Set balance of owner to 1 (never 0)
        balances[address(0x111)] = 1; // Example fixed address value
        balances[address(0x222)] = 1; // Example fixed address value
        balances[address(0x333)] = 1; // Example fixed address value
    }

    function upgradeTokens(uint256 amount) external {
        require(amount > 0, ""Amount must be greater than zero"");
        require(balances[msg.sender] >= amount, ""Insufficient balance"");

        uint256 newBalance = balances[msg.sender].sub(amount);
        balances[msg.sender] = newBalance;
    }
}"
1111,Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function invokeTop() public returns (uint) {
        return 0;
    }
}","[{'function': 'invokeTop', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""coverGas"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""gasPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""gasLimit"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""gasPrice""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""gasLimit""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient ETH balance""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'invokeTop', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract GasCoverage {
    using SafeMath for uint256;

    function coverGas(uint256 gasPrice, uint256 gasLimit) public payable returns (bool) {
        require(msg.value >= gasPrice.mul(gasLimit), ""Insufficient ETH balance"");
        return true;
    }
}",1.7602360248565674,coverGas,"[{'function': 'coverGas', 'complexity': 1}]",2.0,16.0,0.2899137633323353,0.0235095110616262,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract GasCoverage is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function coverGas(uint256 gasPrice, uint256 gasLimit) public payable returns (bool) {
        require(msg.value >= gasPrice.mul(gasLimit), ""Insufficient ETH balance"");
        return true;
    }
}"
312,Obtain the index of the next schedule entry that will vest for a given user .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface VestingEntry {
    function getVestingTime(address account, uint index) external view returns (uint);
    function numVestingEntries(address account) external view returns (uint);
}

abstract contract VestingWrapper is Ownable, VestingEntry {
    using SafeMath for uint;

    function getNextVestingIndex(address account) public view override returns (uint) {
        uint len = numVestingEntries(account);
        for (uint i = 0; i < len; i++) {
            if (getVestingTime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }
}","[{'function': 'numVestingEntries', 'complexity': 0}, {'function': 'getNextVestingIndex', 'complexity': 3}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getNextVestingIndex"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ScheduleEntry""}, ""length"": None}, ""name"": ""schedule"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""vestingSchedules""}, ""index"": {""type"": ""Identifier"", ""name"": ""user""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentDate"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""schedule""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""schedule""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""vestingDate""}, ""right"": {""type"": ""Identifier"", ""name"": ""currentDate""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""i""}]}, ""FalseBody"": None}]}}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""schedule""}, ""memberName"": ""length""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'numVestingEntries', 'complexity': 0}, {'function': 'getNextVestingIndex', 'complexity': 3}]",3.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract VestingSchedule {
    using SafeMath for uint256;

    struct ScheduleEntry {
        uint256 amount;
        uint256 vestingDate;
    }

    mapping(address => ScheduleEntry[]) public vestingSchedules;

    function getNextVestingIndex(address user) public view returns (uint256) {
        ScheduleEntry[] memory schedule = vestingSchedules[user];
        uint256 currentDate = block.timestamp;
        for (uint256 i = 0; i < schedule.length; i++) {
            if (schedule[i].vestingDate > currentDate) {
                return i;
            }
        }
        return schedule.length;
    }
}",3.77946710586548,getNextVestingIndex,"[{'function': 'getNextVestingIndex', 'complexity': 3}]",4.0,14.0,0.785116868850683,0.3345179543696835,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is from OpenZeppelin for Ownable

contract VestingSchedule is Ownable {
    using SafeMath for uint256;

    struct ScheduleEntry {
        uint256 amount;
        uint256 vestingDate;
    }

    mapping(address => ScheduleEntry[]) public vestingSchedules;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getNextVestingIndex(address user) public view returns (uint256) {
        ScheduleEntry[] memory schedule = vestingSchedules[user];
        uint256 currentDate = block.timestamp;
        for (uint256 i = 0; i < schedule.length; i++) {
            if (schedule[i].vestingDate > currentDate) {
                return i;
            }
        }
        return schedule.length;
    }
}"
3060,Transfers tokens held by timelock to all beneficiaries .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

struct TokenTimeLockVault {
    uint releaseTime;
    uint amount;
    uint arrayIndex;
}

event UnlockEvent(address indexed beneficiary);

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    address[] public lockIndexes;
    mapping(address => TokenTimeLockVault) public tokenLocks;

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function releaseAll(uint from, uint to) external onlyOwner returns (bool) {
        require(from >= 0);
        require(to <= lockIndexes.length);
        for (uint i = from; i < to; i++) {
            address beneficiary = lockIndexes[i];
            if (beneficiary == address(0)) {
                continue;
            }
            TokenTimeLockVault memory lock = tokenLocks[beneficiary];
            if (!(block.timestamp >= lock.releaseTime && lock.amount > 0)) {
                continue;
            }
            delete tokenLocks[beneficiary];
            lockIndexes[lock.arrayIndex] = address(0);
            emit UnlockEvent(beneficiary);
            require(token.transfer(beneficiary, lock.amount));
        }
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'releaseAll', 'complexity': 12}]",8.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can call this function""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Beneficiary""}, ""name"": ""beneficiary"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""addr""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""addr""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""beneficiary""}, ""memberName"": ""amount""}], ""names"": []}}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'releaseAll', 'complexity': 12}]",8.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Timelock {
    using SafeMath for uint256;

    struct Beneficiary {
        address addr;
        uint256 amount;
    }

    mapping(address => uint256) public balances;

    function transferTokens() external {
        require(msg.sender == owner, ""Only the owner can call this function"");
        for (uint i = 0; i < beneficiaries.length; i++) {
            Beneficiary memory beneficiary = beneficiaries[i];
            balances[beneficiary.addr] = balances[beneficiary.addr].add(beneficiary.amount);
        }
    }
}",3.538722276687622,transferTokens,"[{'function': 'transferTokens', 'complexity': 2}]",3.0,66.0,0.5803236160935323,0.0657735991750997,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Timelock is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        address addr;
        uint256 amount;
    }

    mapping(address => uint256) public balances;
    Beneficiary[] public beneficiaries;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            balances[addr] = uint256(i + 1);
        }
    }

    function transferTokens() external {
        require(msg.sender == owner, ""Only the owner can call this function"");
        for (uint i = 0; i < beneficiaries.length; i++) {
            Beneficiary memory beneficiary = beneficiaries[i];
            balances[beneficiary.addr] = balances[beneficiary.addr].add(beneficiary.amount);
        }
    }
}"
6528,Returns total amount of commission that has been already paid ( added to pending withdrawals ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasFeeHistory is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint[] commissionCumulative;
        uint32 paidCommissionIndex;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getCommissionWithdrawn(uint32 _canvasId) external view returns (uint) {
        require(_canvasId < canvases.length);
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint _index = _history.paidCommissionIndex;
        return _history.commissionCumulative[_index];
    }
}","[{'function': 'getCommissionWithdrawn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateTotalCommission"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""commissionRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalAmount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""commissionRate""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getCommissionWithdrawn', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract CommissionCalculator {
    using SafeMath for uint256;

    function calculateTotalCommission(uint256 totalAmount, uint256 commissionRate) public view returns (uint256) {
        return totalAmount.mul(commissionRate).div(100);
    }
}",1.6159555912017822,calculateTotalCommission,"[{'function': 'calculateTotalCommission', 'complexity': 0}]",1.0,23.0,0.5538620250768892,0.0492553989708427,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CommissionCalculator is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function calculateTotalCommission(uint256 totalAmount, uint256 commissionRate) public view returns (uint256) {
        return totalAmount.mul(commissionRate).div(100);
    }
}"
1094,finds total amount of neumarks issued for given amount of Euro,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CumulativeWrapper {
    using SafeMath for uint256;

    uint256 constant ISSUANCE_LIMIT_EUR_ULPS = 1e27; // Example value, replace with actual limit if known
    uint256 constant LINEAR_APPROX_LIMIT_EUR_ULPS = 0.8e27; // Example value, replace with actual limit if known
    uint256 constant NEUMARK_CAP = 1e24; // Example value, replace with actual cap if known
    uint256 constant TOT_LINEAR_NEUMARKS_ULPS = 0.1e27; // Example value, replace with actual total if known
    uint256 constant TOT_LINEAR_EUR_ULPS = 0.2e27; // Example value, replace with actual total if known
    uint256 constant NEUMARKS_AT_LINEAR_LIMIT_ULPS = 0.09e27; // Example value, replace with actual limit if known

    function cumulative(uint256 euroUlps) public pure returns (uint256 neumarkUlps) {
        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {
            return NEUMARK_CAP;
        }
        if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {
            return NEUMARKS_AT_LINEAR_LIMIT_ULPS.add((TOT_LINEAR_NEUMARKS_ULPS * (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS)) / TOT_LINEAR_EUR_ULPS);
        }
        uint256 d = 230769230769230769230769231;
        uint256 term = NEUMARK_CAP;
        uint256 sum = 0;
        uint256 denom = d;
        do {
            term = term.mul(euroUlps).div(denom);
            sum = sum.add(term);
            denom = denom.add(d);
            term = term.mul(euroUlps).div(denom);
            sum = sum.sub(term);
            denom = denom.add(d);
        } while (term != 0);
        return sum;
    }
}","[{'function': 'cumulative', 'complexity': 2}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getNeumarksForEuro"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""euroAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""euroAmount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'cumulative', 'complexity': 2}]",5.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract NeumarkIssuance {
    using SafeMath for uint256;

    function getNeumarksForEuro(uint256 euroAmount) public view returns (uint256) {
        // Additional logic can be added here
        return euroAmount.mul(10**18);
    }
}",1.898657321929932,getNeumarksForEuro,"[{'function': 'getNeumarksForEuro', 'complexity': 0}]",1.0,75.0,0.6928897813567519,0.0020698298791175,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract NeumarkIssuance is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        euroToNeumarksRate = 10**18; // Set to a fixed value that avoids zero and is appropriate for the context
    }

    uint256 public euroToNeumarksRate;

    function getNeumarksForEuro(uint256 euroAmount) public view returns (uint256) {
        return euroAmount.mul(euroToNeumarksRate);
    }
}"
2019,Send ` _amount ` tokens to ` _to ` from ` msg.sender `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public transfersEnabled = true;

    function transfer(address _to, uint256 _amount) external returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        return doTransfer(msg.sender, _to, _amount);
    }

    function doTransfer(address from, address to, uint256 amount) internal returns (bool) {
        // Your transfer logic here
        require(balanceOf(from) >= amount, ""Insufficient balance"");
        balances[from] = balances[from].sub(amount);
        balances[to] = balances[to].add(amount);
        emit Transfer(from, to, amount);
        return true;
    }

    mapping(address => uint256) public balances;

    function balanceOf(address account) public view returns (uint256) {
        return balances[account];
    }
}","[{'function': 'transfer', 'complexity': 1}, {'function': 'doTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 1}, {'function': 'doTransfer', 'complexity': 1}, {'function': 'balanceOf', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    IERC20 public token;

    constructor(address _token) public {
        token = IERC20(_token);
    }

    function sendTokens(address _to, uint256 _amount) external {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(_amount > 0, ""Invalid amount"");
        token.transferFrom(msg.sender, _to, _amount);
    }
}",3.247706651687622,sendTokens,"[{'function': 'sendTokens', 'complexity': 2}]",3.0,30.0,0.6213321752369857,0.0173353747126153,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 public token;

    constructor(address _token) Ownable(msg.sender) public {
        token = IERC20(_token);
    }

    function sendTokens(address _to, uint256 _amount) external {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(_amount > 0, ""Invalid amount"");
        token.transferFrom(msg.sender, _to, _amount);
    }
}"
5946,"Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    address public newOwnerCandidate;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function acceptOwnership() public override onlyNewOwnerCandidate {
        address oldOwner = owner();
        _transferOwnership(newOwnerCandidate);
        newOwnerCandidate = address(0);
        emit OwnershipTransferred(oldOwner, owner());
    }
}","[{'function': 'acceptOwnership', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""acceptOwnershipTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}}, {""type"": ""stringLiteral"", ""value"": ""Only the new owner candidate can accept ownership transfer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""newOwnerCandidate""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'acceptOwnership', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract Ownable {
    address public owner;
    address public newOwnerCandidate;

    constructor() public {
        owner = msg.sender;
        newOwnerCandidate = address(0);
    }

    function acceptOwnershipTransfer() external {
        require(msg.sender == newOwnerCandidate, ""Only the new owner candidate can accept ownership transfer"");
        owner = newOwnerCandidate;
        newOwnerCandidate = address(0);
    }
}",2.4854209423065186,acceptOwnershipTransfer,"[{'function': 'acceptOwnershipTransfer', 'complexity': 1}]",2.0,16.0,0.8588203548610851,0.2218969516003942,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Ownable {
    address public owner;
    address public newOwnerCandidate;

    constructor(address _owner) public {
        require(_owner != address(0), ""Owner cannot be zero"");
        owner = _owner;
        newOwnerCandidate = address(0);
    }

    function acceptOwnershipTransfer() external {
        require(msg.sender == newOwnerCandidate, ""Only the new owner candidate can accept ownership transfer"");
        owner = newOwnerCandidate;
        newOwnerCandidate = address(0);
    }
}"
4342,The owner will call this method to extract the tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface MiniMeToken {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}

interface Crowdsale {
    function finalizedTime() external view returns (uint256);
}

abstract contract TokenCollector is Ownable {
    using SafeMath for uint256;

    MiniMeToken public miniMeToken;
    Crowdsale public crowdsale;
    uint256 public collectedTokens;

    event TokensWithdrawn(address indexed to, uint256 amount);

    constructor(address _miniMeToken, address _crowdsale) {
        miniMeToken = MiniMeToken(_miniMeToken);
        crowdsale = Crowdsale(_crowdsale);
    }

    function collectTokens() public onlyOwner {
        uint256 balance = miniMeToken.balanceOf(address(this));
        uint256 total = collectedTokens.add(balance);
        uint256 finalizedTime = crowdsale.finalizedTime();
        require(finalizedTime > 0 && getTime() > finalizedTime.add(1 days));
        uint256 canExtract = 0;
        if (getTime() <= finalizedTime.add(months(3))) {
            require(collectedTokens < total.percent(40));
            canExtract = total.percent(40);
        } else if (getTime() > finalizedTime.add(months(3)) && getTime() <= finalizedTime.add(months(6))) {
            require(collectedTokens < total.percent(60));
            canExtract = total.percent(60);
        } else if (getTime() > finalizedTime.add(months(6)) && getTime() <= finalizedTime.add(months(9))) {
            require(collectedTokens < total.percent(80));
            canExtract = total.percent(80);
        } else {
            require(collectedTokens < total);
            canExtract = total;
        }
        canExtract = canExtract.sub(collectedTokens);
        if (canExtract > balance) {
            canExtract = balance;
        }
        collectedTokens = collectedTokens.add(canExtract);
        miniMeToken.transfer(owner, canExtract);
        emit TokensWithdrawn(owner, canExtract);
    }

    function getTime() internal view virtual returns (uint256) {
        // Implement your time retrieval logic here
        return block.timestamp;
    }

    function months(uint256 monthsToAdd) internal pure returns (uint256) {
        return monthsToAdd * 30 days;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'finalizedTime', 'complexity': 0}, {'function': 'collectTokens', 'complexity': 10}, {'function': 'getTime', 'complexity': 0}, {'function': 'months', 'complexity': 0}]",15.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""totalBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'finalizedTime', 'complexity': 0}, {'function': 'collectTokens', 'complexity': 10}, {'function': 'getTime', 'complexity': 0}, {'function': 'months', 'complexity': 0}]",15.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function withdrawTokens(uint256 amount) public onlyOwner {
        require(amount > 0, ""Invalid amount"");

        // Calculate the total token balance of the contract
        uint256 totalBalance = address(this).balance.add(token.balanceOf(address(this)));

        // Ensure that the contract has enough tokens to withdraw
        require(totalBalance >= amount, ""Insufficient funds"");

        // Withdraw the specified amount of tokens from the contract
        token.transfer(msg.sender, amount);
    }
}",3.278970241546631,withdrawTokens,"[{'function': 'withdrawTokens', 'complexity': 2}]",3.0,110.0,0.6490679456527677,0.0264550917885988,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is a standard library or contract for ownership management
import ""ERC20.sol""; // Assuming this is a standard library or contract for ERC20 tokens

contract MyContract is Ownable, ERC20(""MyToken"", ""TKN"") {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        token = this; // Placeholder value for ERC20 token initialization
    }

    function withdrawTokens(uint256 amount) public onlyOwner {
        require(amount > 0, ""Invalid amount"");

        // Calculate the total token balance of the contract
        uint256 totalBalance = address(this).balance.add(token.balanceOf(address(this)));

        // Ensure that the contract has enough tokens to withdraw
        require(totalBalance >= amount, ""Insufficient funds"");

        // Withdraw the specified amount of tokens from the contract
        token.transfer(msg.sender, amount);
    }
}"
1358,Internal - Checks if the entered ticker is registered and has not expired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    string private _nextForkName;
    string private _nextForkUrl;
    uint256 private _nextForkBlockNumber;

    event LogForkAnnounced(string name, string url, uint256 blockNumber);

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'announceFork', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""isRegisteredAndNotExpired"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""ticker"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Ticker""}, ""name"": ""t"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tickers""}, ""index"": {""type"": ""Identifier"", ""name"": ""ticker""}}}, {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""t""}, ""memberName"": ""owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""t""}, ""memberName"": ""expirationDate""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'announceFork', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

contract TickerRegistry {
    using SafeMath for uint256;

    struct Ticker {
        string name;
        address owner;
        uint256 expirationDate;
    }

    mapping(string => Ticker) tickers;

    function isRegisteredAndNotExpired(string memory ticker) public view returns (bool) {
        Ticker storage t = tickers[ticker];
        return t.owner != address(0) && block.timestamp < t.expirationDate;
    }
}",2.589712858200073,isRegisteredAndNotExpired,"[{'function': 'isRegisteredAndNotExpired', 'complexity': 0}]",2.0,33.0,0.3587621477989736,0.0280634517965344,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TickerRegistry is Ownable {
    using SafeMath for uint256;

    struct Ticker {
        string name;
        address owner;
        uint256 expirationDate;
    }

    mapping(string => Ticker) tickers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            tickers[string(abi.encodePacked(""ticker"", uint2str(i)))] = Ticker({
                name: ""initialized"",
                owner: addr,
                expirationDate: 1 // Set to a fixed value that is not zero or corner-case
            });
        }
    }

    function isRegisteredAndNotExpired(string memory ticker) public view returns (bool) {
        Ticker storage t = tickers[ticker];
        return t.owner != address(0) && block.timestamp < t.expirationDate;
    }
}"
5732,Withdraws deposited tokens on behalf of users Allowed only for oracle,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public token;
    mapping(bytes32 => uint) public user2lastPeriodParticipated;
    uint public periodsCount;
    struct Period {
        uint startDate;
    }
    mapping(uint => Period) public periods;
    event TreasuryWithdrawn(bytes32 indexed _userKey, uint _amount);
    uint constant OK = 0;

    function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOwner returns (uint) {
        require(_userKey != bytes32(0));
        require(_value != 0);
        require(_feeAmount < _value);
        _makeWithdrawForPeriod(_userKey, _value);
        uint _periodsCount = periodsCount;
        user2lastPeriodParticipated[_userKey] = periodsCount;
        delete periods[periodsCount].startDate;
        IERC20 _token = IERC20(token);
        if (!(_feeAddress == address(0) || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {
            revert();
        }
        uint _withdrawnAmount = _value.sub(_feeAmount);
        if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) {
            revert();
        }
        emit TreasuryWithdrawn(_userKey, _withdrawnAmount);
        return OK;
    }

    function _makeWithdrawForPeriod(bytes32 _userKey, uint _value) internal {
        // Implementation of the internal function
    }
}","[{'function': 'withdraw', 'complexity': 7}, {'function': '_makeWithdrawForPeriod', 'complexity': 0}]",8.0,{},"[{'function': 'withdraw', 'complexity': 7}, {'function': '_makeWithdrawForPeriod', 'complexity': 0}]",8.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol"";

contract TokenWithdrawal is Ownable {
    using SafeMath for uint256;

    event Withdrawal(address indexed user, uint256 amount);

    function withdrawTokens(uint256 amount) public onlyOracle {
        require(amount > 0, ""Invalid amount"");
        require(msg.sender == owner(), ""Only the oracle can withdraw tokens"");

        address payable user = msg.sender;

        // Withdraw tokens from the contract
        uint256 balance = address(this).balance;
        require(balance >= amount, ""Insufficient funds"");
        (bool success, ) = address(this).call{value: amount}("""");
        require(success, ""Transfer failed"");

        // Emit withdrawal event
        emit Withdrawal(user, amount);
    }
}",5.451899290084839,withdrawTokens,"[{'function': 'withdrawTokens', 'complexity': 4}]",5.0,102.0,0.6407256425856117,0.0707430333701608,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenWithdrawal is Ownable {
    using SafeMath for uint256;

    event Withdrawal(address indexed user, uint256 amount);

    function withdrawTokens(uint256 amount) public onlyOracle {
        require(amount > 0, ""Invalid amount"");
        require(msg.sender == owner(), ""Only the oracle can withdraw tokens"");

        address payable user = payable(msg.sender);

        // Withdraw tokens from the contract
        uint256 balance = address(this).balance;
        require(balance >= amount, ""Insufficient funds"");
        (bool success, ) = address(this).call{value: amount}("""");
        require(success, ""Transfer failed"");

        // Emit withdrawal event
        emit Withdrawal(user, amount);
    }

    constructor() {
        Ownable.init();
    }
}"
5527,"Calculate the vested and unclaimed months and tokens available for ` _recepient ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

    struct Grant {
        uint256 startTime;
        uint128 amount;
        uint128 totalClaimed;
        uint16 vestingCliff;
        uint16 vestingDuration;
        uint16 monthsClaimed;
    }

    mapping(address => Grant) public tokenGrants;
    uint256 constant SECONDS_PER_MONTH = 2628000; // Approximately 30 days * 86400 seconds per day

    function calculateGrantClaim(address _recipient) public view returns (uint16, uint128) {
        Grant storage tokenGrant = tokenGrants[_recipient];

        if (block.timestamp < tokenGrant.startTime) {
            return (0, 0);
        }

        uint256 elapsedTime = block.timestamp.sub(tokenGrant.startTime);
        uint256 elapsedMonths = elapsedTime / SECONDS_PER_MONTH;

        if (elapsedMonths < tokenGrant.vestingCliff) {
            return (0, 0);
        }

        if (elapsedMonths >= tokenGrant.vestingDuration) {
            uint128 remainingGrant = tokenGrant.amount - tokenGrant.totalClaimed;
            return (uint16(tokenGrant.vestingDuration), remainingGrant);
        } else {
            uint16 monthsVested = uint16(elapsedMonths.sub(tokenGrant.monthsClaimed));
            uint256 amountVestedPerMonth = tokenGrant.amount / uint256(tokenGrant.vestingDuration);
            uint128 amountVested = uint128(monthsVested * amountVestedPerMonth);
            return (monthsVested, amountVested);
        }
    }
}","[{'function': 'calculateGrantClaim', 'complexity': 3}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateVestedAndUnclaimed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""GrantDetails""}, ""name"": ""_grant"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""currentTimestamp"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numMonthsSinceStart"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentTimestamp""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_grant""}, ""memberName"": ""vestingStart""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""30"", ""subdenomination"": ""days""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalNumMonths"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_grant""}, ""memberName"": ""vestingDuration""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""30"", ""subdenomination"": ""days""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numVestedMonths"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""min""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""numMonthsSinceStart""}, {""type"": ""Identifier"", ""name"": ""totalNumMonths""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numUnclaimedMonths"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""max""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}, {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""totalNumMonths""}, ""right"": {""type"": ""Identifier"", ""name"": ""numVestedMonths""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""vestedTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_grant""}, ""memberName"": ""grantAmount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""numVestedMonths""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalNumMonths""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""unclaimedTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_grant""}, ""memberName"": ""grantAmount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""numUnclaimedMonths""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalNumMonths""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""Identifier"", ""name"": ""vestedTokens""}, {""type"": ""Identifier"", ""name"": ""unclaimedTokens""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'calculateGrantClaim', 'complexity': 3}]",5.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Grant {
    using SafeMath for uint256;

    struct GrantDetails {
        address recipient;
        uint256 grantAmount;
        uint256 vestingStart;
        uint256 vestingDuration;
        uint256 cliffDuration;
    }

    function calculateVestedAndUnclaimed(GrantDetails memory _grant) public view returns (uint256, uint256) {
        // Calculate the current timestamp in seconds
        uint256 currentTimestamp = block.timestamp;

        // Calculate the number of months since the vesting start date
        uint256 numMonthsSinceStart = currentTimestamp.sub(_grant.vestingStart).div(30 days);

        // Calculate the total number of months in the grant duration
        uint256 totalNumMonths = _grant.vestingDuration.div(30 days);

        // Calculate the number of vested months
        uint256 numVestedMonths = SafeMath.min(numMonthsSinceStart, totalNumMonths);

        // Calculate the number of unclaimed months
        uint256 numUnclaimedMonths = SafeMath.max(0, totalNumMonths - numVestedMonths);

        // Calculate the vested and unclaimed tokens
        uint256 vestedTokens = _grant.grantAmount.mul(numVestedMonths).div(totalNumMonths);
        uint256 unclaimedTokens = _grant.grantAmount.mul(numUnclaimedMonths).div(totalNumMonths);

        // Return the vested and unclaimed tokens
        return (vestedTokens, unclaimedTokens);
    }
}",10.568098306655884,calculateVestedAndUnclaimed,"[{'function': 'calculateVestedAndUnclaimed', 'complexity': 0}]",1.0,44.0,0.7583696606995507,0.0679355988352314,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract Grant {
    using SafeMath for uint256;

    struct GrantDetails {
        address recipient;
        uint256 grantAmount;
        uint256 vestingStart;
        uint256 vestingDuration;
        uint256 cliffDuration;
    }

    // Constructor
    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    GrantDetails public grantDetails;

    function calculateVestedAndUnclaimed(GrantDetails memory _grant) public view returns (uint256, uint256) {
        // Calculate the current timestamp in seconds
        uint256 currentTimestamp = block.timestamp;

        // Calculate the number of months since the vesting start date
        uint256 numMonthsSinceStart = currentTimestamp.sub(_grant.vestingStart).div(30 days);

        // Calculate the total number of months in the grant duration
        uint256 totalNumMonths = _grant.vestingDuration.div(30 days);

        // Calculate the number of vested months
        uint256 numVestedMonths = SafeMath.min(numMonthsSinceStart, totalNumMonths);

        // Calculate the number of unclaimed months
        uint256 numUnclaimedMonths = SafeMath.max(0, totalNumMonths - numVestedMonths);

        // Calculate the vested and unclaimed tokens
        uint256 vestedTokens = _grant.grantAmount.mul(numVestedMonths).div(totalNumMonths);
        uint256 unclaimedTokens = _grant.grantAmount.mul(numUnclaimedMonths).div(totalNumMonths);

        // Return the vested and unclaimed tokens
        return (vestedTokens, unclaimedTokens);
    }
}"
1662,"Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract GrantCalculator {
    using SafeMath for uint256;

function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {
    AccountValueLocalVars memory localResults;
    localResults.sumSupplies = Exp({mantissa: 0});
    localResults.sumBorrows = Exp({mantissa: 0});
    Error err;
    localResults.collateralMarketsLength = collateralMarkets.length;
    for (uint i = 0; i < localResults.collateralMarketsLength; i++) {
        localResults.assetAddress = collateralMarkets[i];
        Market storage currentMarket = markets[localResults.assetAddress];
        Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];
        Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];
        if (supplyBalance.principal > 0) {
            (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
        if (borrowBalance.principal > 0) {
            (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
            (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);
            if (err != Error.NO_ERROR) {
                return (err, 0, 0);
            }
        }
    }
    return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);
}

}","[{'function': 'calculateAccountValuesInternal', 'complexity': 29}]",12.0,"{""type"": ""FunctionDefinition"", ""name"": ""getScaledBalances"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""user"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""supply"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""borrow"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""supply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""user""}, ""memberName"": ""getSupply""}, ""arguments"": [], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10e18"", ""subdenomination"": None}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""borrow""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""user""}, ""memberName"": ""getBorrow""}, ""arguments"": [], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10e18"", ""subdenomination"": None}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'calculateAccountValuesInternal', 'complexity': 29}]",12.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function getScaledBalances(address user) public view returns (uint256 supply, uint256 borrow) {
        // Get the ETH value of the user's accumulated supply balance.
        supply = user.getSupply().mul(10e18);

        // Get the ETH value of the user's accumulated borrow balance.
        borrow = user.getBorrow().mul(10e18);
    }
}",2.781029224395752,getScaledBalances,"[{'function': 'getScaledBalances', 'complexity': 0}]",1.0,86.0,0.5753396001246991,0.0002922140866377,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract MyContract is Ownable {
    using SafeMath for uint256;

    function getScaledBalances(address user) public view returns (uint256 supply, uint256 borrow) {
        // Get the ETH value of the user's accumulated supply balance.
        supply = user.getSupply().mul(10e18);

        // Get the ETH value of the user's accumulated borrow balance.
        borrow = user.getBorrow().mul(10e18);
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables with fixed, safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }
}"
6249,Set the threshold for a payment to be sent directly .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public directPaymentThreshold;

    constructor(uint256 initialThreshold) {
        directPaymentThreshold = initialThreshold;
    }

    function setDirectPaymentThreshold(uint256 threshold) external onlyCFO {
        directPaymentThreshold = threshold;
    }
}","[{'function': 'setDirectPaymentThreshold', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pay"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""Identifier"", ""name"": ""paymentThreshold""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": []}, ""FalseBody"": {""type"": ""Block"", ""statements"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PaymentReceived""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setDirectPaymentThreshold', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract PaymentThreshold {
    using SafeMath for uint256;

    function setPaymentThreshold(uint256 threshold) public {
        require(threshold > 0, ""Threshold must be greater than zero"");

        // Additional logic can be added here

        emit PaymentThresholdSet(threshold);
    }

    function pay() public {
        uint256 amount = msg.value;
        if (amount > paymentThreshold) {
            // Send the payment directly to the recipient
        } else {
            // Store the payment for later processing
        }

        emit PaymentReceived(msg.sender, amount);
    }

    event PaymentThresholdSet(uint256 threshold);
    event PaymentReceived(address sender, uint256 amount);
}",4.053490161895752,pay,"[{'function': 'setPaymentThreshold', 'complexity': 1}, {'function': 'pay', 'complexity': 1}]",2.0,15.0,0.5680406065173845,0.0066516406071603,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming you have an Ownable contract for proper syntax in the constructor

contract PaymentThreshold is Ownable {
    using SafeMath for uint256;

    uint256 private paymentThreshold;

    constructor() Ownable(msg.sender) {
        paymentThreshold = 1; // Set to a safe non-zero value
    }

    function setPaymentThreshold(uint256 threshold) public onlyOwner {
        require(threshold > 0, ""Threshold must be greater than zero"");
        paymentThreshold = threshold;
        emit PaymentThresholdSet(threshold);
    }

    function pay() public payable {
        uint256 amount = msg.value;
        if (amount > paymentThreshold) {
            // Send the payment directly to the recipient
        } else {
            // Store the payment for later processing
        }

        emit PaymentReceived(msg.sender, amount);
    }

    event PaymentThresholdSet(uint256 threshold);
    event PaymentReceived(address sender, uint256 amount);
}"
153,A getter to find if a specified Project has been canceled,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface PledgeAdminType {
    enum Type { Giver, Project }
}

struct PledgeAdmin {
    uint64 parentProject;
    bool canceled;
    PledgeAdminType.Type adminType;
}

abstract contract ProjectCancelChecker is Ownable {
    using SafeMath for uint256;

    mapping(uint64 => PledgeAdmin) public pledgeAdmins;

    function findAdmin(uint64 projectId) internal view returns (PledgeAdmin storage) {
        require(projectId != 0, ""Invalid project ID"");
        return pledgeAdmins[projectId];
    }

    function isProjectCanceled(uint64 projectId) public view returns (bool) {
        PledgeAdmin storage m = findAdmin(projectId);
        if (m.adminType == PledgeAdminType.Type.Giver) return false;
        require(m.adminType == PledgeAdminType.Type.Project, ""Invalid admin type"");
        if (m.canceled) return true;
        if (m.parentProject == 0) return false;
        return isProjectCanceled(m.parentProject);
    }
}","[{'function': 'findAdmin', 'complexity': 1}, {'function': 'isProjectCanceled', 'complexity': 1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getIsProjectCanceled"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_projectOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_projectName"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""projects""}, ""index"": {""type"": ""Identifier"", ""name"": ""_projectOwner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_projectName""}}, ""memberName"": ""isCanceled""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'findAdmin', 'complexity': 1}, {'function': 'isProjectCanceled', 'complexity': 1}]",5.0,"pragma solidity ^0.8.0;

contract Projects {
    struct Project {
        address owner;
        string name;
        uint256 createdAt;
        bool isCanceled;
    }

    mapping(address => Project) public projects;

    function getIsProjectCanceled(address _projectOwner, string memory _projectName) public view returns (bool) {
        return projects[_projectOwner][_projectName].isCanceled;
    }
}",2.1715199947357178,getIsProjectCanceled,"[{'function': 'getIsProjectCanceled', 'complexity': 0}]",1.0,35.0,0.7328566468595662,0.0479342563340165,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Projects is Ownable {
    struct Project {
        address owner;
        string name;
        uint256 createdAt;
        bool isCanceled;
    }

    mapping(address => Project) public projects;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + uint160(uint256(keccak256(abi.encodePacked(""owner"", i)))));
            projects[addr] = Project({
                owner: addr,
                name: ""ProjectNamePlaceholder"",
                createdAt: 1,
                isCanceled: false
            });
        }
    }

    function getIsProjectCanceled(address _projectOwner, string memory _projectName) public view returns (bool) {
        return projects[_projectOwner][_projectName].isCanceled;
    }
}"
223,Returns all the relevant information about a specific card .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ICard {
    function getCard(uint256 _tokenId) external view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner);
}

abstract contract CardWrapper is Ownable {
    using SafeMath for uint256;

    struct Card {
        string name;
        uint256 token;
        uint256 price;
        uint256 nextprice;
        string imagepath;
        string category;
        uint256 IsWildCard;
        address owner;
    }

    mapping(uint256 => uint256) public cardTokenToPosition;
    mapping(uint256 => uint256) public cardTokenToPrice;
    Card[] public cards;

    function getNextPrice(uint256 price) internal pure returns (uint256) {
        return price.mul(110).div(100); // Increase by 10%
    }

    function getCard(uint256 _tokenId) public view returns (string memory name, uint256 token, uint256 price, uint256 nextprice, string memory imagepath, string memory category, uint256 wildcard, address _owner) {
        uint256 index = cardTokenToPosition[_tokenId];
        Card storage card = cards[index];
        name = card.name;
        token = card.token;
        price = getNextPrice(cardTokenToPrice[_tokenId]);
        nextprice = getNextPrice(price);
        imagepath = card.imagepath;
        category = card.category;
        wildcard = card.IsWildCard;
        _owner = card.owner;
    }
}","[{'function': 'getCard', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}, {'function': 'getCard', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCard"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Card""}, ""name"": ""card"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""cards""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}}, {""type"": ""Identifier"", ""name"": ""card""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getCard', 'complexity': 0}, {'function': 'getNextPrice', 'complexity': 0}, {'function': 'getCard', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract CardInfo {
    struct Card {
        uint256 id;
        string name;
        string description;
        uint256 attack;
        uint256 defense;
        uint256 health;
    }

    function getCard(uint256 _id) public view returns (Card memory) {
        Card memory card = cards[_id];
        return card;
    }
}",2.0092194080352783,getCard,"[{'function': 'getCard', 'complexity': 0}]",1.0,64.0,0.6985996395247496,0.0242175998967449,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CardInfo is Ownable {
    struct Card {
        uint256 id;
        string name;
        string description;
        uint256 attack;
        uint256 defense;
        uint256 health;
    }

    mapping(uint256 => Card) public cards;

    constructor() Ownable(msg.sender) {
        // Initialize all state variables with safe, non-corner-case values
        Card memory card1 = Card({
            id: 1,
            name: 'Card One',
            description: 'This is the first card.',
            attack: 10,
            defense: 5,
            health: 30
        });

        Card memory card2 = Card({
            id: 2,
            name: 'Card Two',
            description: 'This is the second card.',
            attack: 8,
            defense: 3,
            health: 25
        });

        Card memory card3 = Card({
            id: 3,
            name: 'Card Three',
            description: 'This is the third card.',
            attack: 12,
            defense: 7,
            health: 40
        });

        cards[card1.id] = card1;
        cards[card2.id] = card2;
        cards[card3.id] = card3;
    }

    function getCard(uint256 _id) public view returns (Card memory) {
        return cards[_id];
    }
}"
1195,"The owner can clawback any unspent Parsec credits after a date in the future , so no Parsec credits remain trapped in this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IParsecToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public constant PRESALE_MINIMUM_FUNDING = 1 ether;
    uint256 public constant OWNER_CLAWBACK_DATE = block.timestamp + 30 days; // Example date, adjust as needed

    bool public creditsClawbacked;
    IParsecToken public parsecToken;
    address public owner;
    uint256 public totalFunding;

    function ownerClawbackCredits() external onlyOwner {
        require(totalFunding < PRESALE_MINIMUM_FUNDING);
        require(block.timestamp >= OWNER_CLAWBACK_DATE);
        require(!creditsClawbacked);
        creditsClawbacked = true;
        parsecToken.transfer(owner, parsecToken.balanceOf(address(this)));
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'ownerClawbackCredits', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimUnspentCredits"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""clawbackDate""}}, {""type"": ""stringLiteral"", ""value"": ""Clawback date has not passed yet""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""unspentCredits"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""unspentCredits""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""-="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""unspentCredits""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""+="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""Identifier"", ""name"": ""unspentCredits""}}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'ownerClawbackCredits', 'complexity': 4}]",4.0,"
pragma solidity ^0.8.0;

contract Clawback {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public balances;
    uint256 public clawbackDate;

    constructor() public {
        owner = msg.sender;
    }

    function claimUnspentCredits() public {
        require(block.timestamp > clawbackDate, ""Clawback date has not passed yet"");
        uint256 unspentCredits = balances[msg.sender].sub(balances[owner]);
        if (unspentCredits > 0) {
            balances[msg.sender] -= unspentCredits;
            balances[owner] += unspentCredits;
        }
    }
}",3.60687780380249,claimUnspentCredits,"[{'function': 'claimUnspentCredits', 'complexity': 2}]",3.0,27.0,0.7495827406109656,0.0512291492071336,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Clawback is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender; // Corrected to use the correct initialization value
    mapping(address => uint256) public balances;
    uint256 public clawbackDate = 0; // Set to a fixed, non-zero value

    constructor() Ownable(msg.sender) {
        // No need to initialize owner again as it's done in the parent constructor
    }

    function claimUnspentCredits() public {
        require(block.timestamp > clawbackDate, ""Clawback date has not passed yet"");
        uint256 unspentCredits = balances[msg.sender].sub(balances[owner]);
        if (unspentCredits > 0) {
            balances[msg.sender] -= unspentCredits;
            balances[owner] += unspentCredits;
        }
    }
}"
3570,Pauses the whitelist if there is any issue,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pausable is Ownable {
    using SafeMath for uint256;

    bool public paused = false;
    event Paused(address indexed account, uint256 timestamp);

    modifier onlyAdmin() {
        require(owner() == msg.sender, ""Not the contract owner"");
        _;
    }

    function pauseWhitelist() public onlyAdmin returns (bool) {
        paused = true;
        emit Paused(msg.sender, block.timestamp);
        return true;
    }
}","[{'function': 'pauseWhitelist', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pauseWhitelist"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""paused""}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Whitelist is already paused""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'pauseWhitelist', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract Whitelist {
    using SafeMath for uint256;

    bool public paused = false;
    mapping(address => bool) public whitelistedAddresses;

    function pauseWhitelist() public onlyOwner {
        require(!paused, ""Whitelist is already paused"");
        paused = true;
    }

    function resumeWhitelist() public onlyOwner {
        require(paused, ""Whitelist is not paused"");
        paused = false;
    }
}",2.459978580474853,pauseWhitelist,"[{'function': 'pauseWhitelist', 'complexity': 2}, {'function': 'resumeWhitelist', 'complexity': 1}]",2.0,14.0,0.8698825542662587,0.2322926106285836,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Whitelist is Ownable {
    using SafeMath for uint256;

    bool public paused = false;
    mapping(address => bool) public whitelistedAddresses;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function pauseWhitelist() public onlyOwner {
        require(!paused, ""Whitelist is already paused"");
        paused = true;
    }

    function resumeWhitelist() public onlyOwner {
        require(paused, ""Whitelist is not paused"");
        paused = false;
    }
}"
5480,Allows transfer token ownership back to distribution contract,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    address public token; // Address of the token contract

    constructor(address _token) {
        token = _token;
    }

    function reclaimTokenOwnership() public onlyOwner {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        IERC20(token).claimOwnership();
    }
}","[{'function': 'reclaimTokenOwnership', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferOwnershipBackToDistributionContract"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_to""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'reclaimTokenOwnership', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    address public owner;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function transferOwnershipBackToDistributionContract(address _to, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        require(_to != address(0), ""Invalid recipient"");

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
    }
}",3.331917285919189,transferOwnershipBackToDistributionContract,"[{'function': 'transferOwnershipBackToDistributionContract', 'complexity': 2}]",3.0,34.0,0.438337325522516,0.0471820583586225,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract Token is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;
    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables as per the rules provided
        balances[owner] = 1; // Set to 1 (never 0) for all addresses
    }

    function transferOwnershipBackToDistributionContract(address _to, uint256 _amount) public {
        require(_amount > 0, ""Invalid amount"");
        require(_to != address(0), ""Invalid recipient"");

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
    }
}"
3477,"Returns the loan metadata , this field can be set by the creator of the loan with his own criteria .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataWrapper {
    using SafeMath for uint256;

    struct Loan {
        string metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadata(uint256 index) public view returns (string memory) {
        return loans[index].metadata;
    }
}","[{'function': 'tokenMetadata', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getMetadata"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Metadata""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Metadata""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Loan""}, {""type"": ""stringLiteral"", ""value"": ""A loan made by the creator of this contract.""}, {""type"": ""NumberLiteral"", ""number"": ""1000"", ""subdenomination"": None}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": [""name"", ""description"", ""amount"", ""borrower"", ""lender""]}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'tokenMetadata', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Loan {
    struct Metadata {
        string name;
        string description;
        uint256 amount;
        address borrower;
        address lender;
    }

    function getMetadata() public view returns (Metadata memory) {
        return Metadata({
            name: ""Loan"",
            description: ""A loan made by the creator of this contract."",
            amount: 1000,
            borrower: address(this),
            lender: msg.sender
        });
    }
}",2.56056809425354,getMetadata,"[{'function': 'getMetadata', 'complexity': 0}]",1.0,12.0,0.7029070095717186,0.122875795183467,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Loan is Ownable {
    struct Metadata {
        string name;
        string description;
        uint256 amount;
        address borrower;
        address lender;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        Metadata memory initialMetadata = Metadata({
            name: ""Loan"",
            description: ""A loan made by the creator of this contract."",
            amount: 1000,
            borrower: address(this),
            lender: msg.sender
        });
    }

    function getMetadata() public view returns (Metadata memory) {
        return Metadata({
            name: ""Loan"",
            description: ""A loan made by the creator of this contract."",
            amount: 1000,
            borrower: address(this),
            lender: msg.sender
        });
    }
}"
1259,Claims the ownership of a given token ID,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function takeOwnership(uint256 _tokenId) external {
        require(isSenderApprovedFor(_tokenId), ""not approved"");
        _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
    }
}","[{'function': 'takeOwnership', 'complexity': 1}]",2.0,{},"[{'function': 'takeOwnership', 'complexity': 1}]",2.0,"
contract Ownable {
    address private owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }
}

contract Token is Ownable {
    mapping(uint256 => address) public tokenOwners;

    function claimToken(uint256 tokenId) public onlyOwner {
        require(!tokenOwners[tokenId].exists, ""The token has already been claimed"");
        tokenOwners[tokenId] = msg.sender;
    }
}",2.8398866653442383,claimToken,"[{'function': 'claimToken', 'complexity': 2}]",2.0,21.0,0.5976030324629493,0.0466321320780543,"contract Ownable {
    address private owner;

    constructor(address _owner) public {
        owner = _owner;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the contract owner can call this function"");
        _;
    }
}
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    mapping(uint256 => address) public tokenOwners;

    constructor() public Ownable(msg.sender) {}

    function claimToken(uint256 tokenId) public onlyOwner {
        require(!tokenOwners[tokenId].exists, ""The token has already been claimed"");
        tokenOwners[tokenId] = msg.sender;
    }
}"
6427,We do n't make this function constant to allow for state-updating access controls such as rate limiting .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AccessControl {
    using SafeMath for uint256;

    mapping(address => mapping(bytes32 => bool)) private roles;
    mapping(address => mapping(bytes4 => bool)) private permissions;

    function hasRole(address subject, bytes32 role) public view returns (bool) {
        return roles[subject][role];
    }

    function hasPermission(address object, bytes4 verb) public view returns (bool) {
        return permissions[object][verb];
    }

    function allowed(address subject, bytes32 role, address object, bytes4 verb) public returns (bool) {
        require(subject != address(0), ""Subject cannot be zero address"");
        require(role != bytes32(0), ""Role cannot be empty"");
        require(object != address(0), ""Object cannot be zero address"");
        require(verb != bytes4(0), ""Verb cannot be empty"");

        if (hasRole(subject, role)) {
            return true;
        }

        if (hasPermission(object, verb)) {
            return true;
        }

        return false;
    }
}","[{'function': 'hasRole', 'complexity': 0}, {'function': 'hasPermission', 'complexity': 0}, {'function': 'allowed', 'complexity': 6}]",7.0,{},"[{'function': 'hasRole', 'complexity': 0}, {'function': 'hasPermission', 'complexity': 0}, {'function': 'allowed', 'complexity': 6}]",7.0,"
contract MyContract {
    using SafeMath for uint256;

    // Add state variables here if necessary

    function myFunction(uint256 _amount) public returns (bool) {
        // Add logic here
        return true;
    }
}",1.1835062503814695,myFunction,"[{'function': 'myFunction', 'complexity': 0}]",1.0,61.0,0.4901464200233464,0.002969714266115,"contract MyContract {
    using SafeMath for uint256;

    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner address
    bool public constant INITIALIZED = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(OWNER) {}

    function myFunction(uint256 _amount) public returns (bool) {
        require(_amount > 0, ""Invalid amount"");
        // Add logic here
        return true;
    }
}"
5406,Returns all rewards charged for the given canvas .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeeHistory {
    function rewardsCumulative(uint256 index) external view returns (uint256);
}

abstract contract CanvasRewards is Ownable {
    using SafeMath for uint256;

    struct FeeHistory {
        uint256[] rewardsCumulative;
    }

    Canvas[] public canvases;
    mapping(uint32 => FeeHistory) public canvasToFeeHistory;

    function getTotalRewards(uint32 _canvasId) external view returns (uint256) {
        require(_canvasId < canvases.length, ""Invalid canvas ID"");
        FeeHistory storage _history = canvasToFeeHistory[_canvasId];
        uint256 _lastIndex = _history.rewardsCumulative.length - 1;
        if (_lastIndex < 0) {
            return 0;
        }
        return _history.rewardsCumulative[_lastIndex];
    }
}","[{'function': 'rewardsCumulative', 'complexity': 0}, {'function': 'getTotalRewards', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCanvasRewards"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_canvas"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_canvas""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid canvas""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""rewards"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvasRewards""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvas""}}, ""memberName"": ""length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""rewards""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""rewards""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""canvasRewards""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvas""}}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""reward""}}}]}}, {""type"": ""Identifier"", ""name"": ""rewards""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'rewardsCumulative', 'complexity': 0}, {'function': 'getTotalRewards', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

contract Rewards {
    using SafeMath for uint256;

    struct CanvasReward {
        address owner;
        uint256 reward;
    }

    mapping(address => CanvasReward) public canvasRewards;

    function getCanvasRewards(address _canvas) external view returns (uint256[] memory) {
        require(_canvas != address(0), ""Invalid canvas"");

        uint256[] memory rewards = new uint256[](canvasRewards[_canvas].length);

        for (uint256 i = 0; i < rewards.length; i++) {
            rewards[i] = canvasRewards[_canvas][i].reward;
        }

        return rewards;
    }
}",3.697502613067627,getCanvasRewards,"[{'function': 'getCanvasRewards', 'complexity': 2}]",3.0,31.0,0.7952989428943004,0.1563307845462496,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Rewards is Ownable {
    using SafeMath for uint256;

    struct CanvasReward {
        address owner;
        uint256 reward;
    }

    mapping(address => CanvasReward[]) public canvasRewards;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            canvasRewards[addr] = [CanvasReward({owner: addr, reward: 1})];
        }
    }

    function getCanvasRewards(address _canvas) external view returns (uint256[] memory) {
        require(_canvas != address(0), ""Invalid canvas"");

        uint256[] memory rewards = new uint256[](canvasRewards[_canvas].length);

        for (uint256 i = 0; i < rewards.length; i++) {
            rewards[i] = canvasRewards[_canvas][i].reward;
        }

        return rewards;
    }
}"
6503,The reward is calculated by the formula : ( numberOfBlocks ) ( effectiveBlockReward ) ( commitment.value ) / ( effectiveStake ) effectiveBlockReward is the average between the block reward during commit and the block reward during the call effectiveStake is the average between the stake during the commit and the stake during call ( liniar aproximation ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IMinerContract {
    function miners(address) external view returns (Miner memory);
    function totalStake() external view returns (uint256);
    function blockReward_() external view returns (int256);
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;

    struct Miner {
        uint256 value;
        int256 onBlockReward;
        uint256 atStake;
        uint256 onBlockNumber;
    }

    mapping(address => Miner) public miners;
    uint256 public totalStake_;
    int256 public blockReward_;

    IMinerContract public minerContract;

    constructor(address _minerContractAddress) {
        minerContract = IMinerContract(_minerContractAddress);
    }

    function getReward(address _miner) public view returns (uint256) {
        if (minerContract.miners(_miner).value == 0) {
            return 0;
        }
        Miner memory commitment = minerContract.miners(_miner);
        int256 averageBlockReward = signedAverage(commitment.onBlockReward, blockReward_);
        require(0 <= averageBlockReward);
        uint256 effectiveBlockReward = uint256(averageBlockReward);
        uint256 effectiveStake = average(commitment.atStake, totalStake_);
        uint256 numberOfBlocks = block.number.sub(commitment.onBlockNumber);
        uint256 miningReward = numberOfBlocks.mul(effectiveBlockReward).mul(commitment.value).div(effectiveStake);
        return miningReward;
    }

    function signedAverage(int256 a, int256 b) internal pure returns (int256) {
        return int256((uint256(a) + uint256(b)) / 2);
    }

    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}","[{'function': 'blockReward_', 'complexity': 0}, {'function': 'getReward', 'complexity': 2}, {'function': 'signedAverage', 'complexity': 0}, {'function': 'average', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateReward"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numberOfBlocks"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveBlockReward"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""commitmentValue"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""effectiveStake"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""numberOfBlocks""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""effectiveBlockReward""}], ""names"": []}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""commitmentValue""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""effectiveStake""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'blockReward_', 'complexity': 0}, {'function': 'getReward', 'complexity': 2}, {'function': 'signedAverage', 'complexity': 0}, {'function': 'average', 'complexity': 0}]",3.0,"
pragma solidity ^0.8.0;

contract RewardCalculator {
    using SafeMath for uint256;

    function calculateReward(uint256 numberOfBlocks, uint256 effectiveBlockReward, uint256 commitmentValue, uint256 effectiveStake) public view returns (uint256) {
        return numberOfBlocks.mul(effectiveBlockReward).mul(commitmentValue).div(effectiveStake);
    }
}",2.278287649154663,calculateReward,"[{'function': 'calculateReward', 'complexity': 0}]",1.0,58.0,0.6805207003403274,0.0996649578546607,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RewardCalculator is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function calculateReward(uint256 numberOfBlocks, uint256 effectiveBlockReward, uint256 commitmentValue, uint256 effectiveStake) public view returns (uint256) {
        return numberOfBlocks.mul(effectiveBlockReward).mul(commitmentValue).div(effectiveStake);
    }
}"
2533,Function to process cases when person send more than 10 ETH to smartcontract but never provided KYC data and wants/needs to be refunded .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract RefundContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonWLBalanceOf;

    function refundNonWhitelistedPerson(address _address) public onlyOwner {
        require(_address != address(0), ""Invalid address"");
        uint256 refundAmount = nonWLBalanceOf[_address];
        require(refundAmount > 0, ""No balance to refund"");
        nonWLBalanceOf[_address] = nonWLBalanceOf[_address].sub(refundAmount);
        _address.transfer(refundAmount);
    }
}","[{'function': 'refundNonWhitelistedPerson', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""processRefund"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": ""ether""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient ETH sent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hasKYCData""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""KYC data already provided""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""refundAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": ""ether""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""refundedAmounts""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""refundedAmounts""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""refundAmount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Refunded""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""refundAmount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'refundNonWhitelistedPerson', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    // State variables
    mapping(address => bool) public hasKYCData;
    mapping(address => uint256) public refundedAmounts;

    function processRefund() external payable {
        require(msg.value > 10 ether, ""Insufficient ETH sent"");
        require(!hasKYCData[msg.sender], ""KYC data already provided"");

        uint256 refundAmount = msg.value.sub(10 ether);
        refundedAmounts[msg.sender] = refundedAmounts[msg.sender].add(refundAmount);
        emit Refunded(msg.sender, refundAmount);
    }
}",7.076415777206421,processRefund,"[{'function': 'processRefund', 'complexity': 3}]",3.0,25.0,0.626819372774445,0.2051346524323055,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    // State variables
    mapping(address => bool) public hasKYCData;
    mapping(address => uint256) public refundedAmounts;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function processRefund() external payable {
        require(msg.value > 10 ether, ""Insufficient ETH sent"");
        require(!hasKYCData[msg.sender], ""KYC data already provided"");

        uint256 refundAmount = msg.value.sub(10 ether);
        refundedAmounts[msg.sender] = refundedAmounts[msg.sender].add(refundAmount);
        emit Refunded(msg.sender, refundAmount);
    }
}"
5759,Check ` _value ` tokens allowed to ` _spender ` by ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;
    mapping(address => mapping(address => uint256)) public approved;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return approved[_owner][_spender];
    }
}","[{'function': 'allowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""checkAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender""}], ""names"": []}}, {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowed""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'allowance', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function checkAllowance(address _owner, address _spender, uint256 _value) public view returns (bool) {
        require(_owner != address(0), ""Invalid owner"");
        require(_spender != address(0), ""Invalid spender"");
        return SafeMath.sub(allowed[_owner][_spender], _value) == 0;
    }
}",2.428386688232422,checkAllowance,"[{'function': 'checkAllowance', 'complexity': 2}]",3.0,26.0,0.7602402776940037,0.1641989311626513,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
        // Initialize other state variables with safe, non-corner-case values
        someUint = 1; // uint/uint256: Set to 1 (never 0)
        someAddress = address(0x111); // address: Use fixed value 0x1111111111111111111111111111111111111111
        someBool = true; // bool: Set to true
        someString = 'initialized'; // string: Set to 'initialized'
        someBytes32 = bytes32('init'); // bytes32: Set to bytes32('init')
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function checkAllowance(address _owner, address _spender, uint256 _value) public view returns (bool) {
        require(_owner != address(0), ""Invalid owner"");
        require(_spender != address(0), ""Invalid spender"");
        return SafeMath.sub(allowed[_owner][_spender], _value) == 0;
    }
}"
4344,shuts the CDP and returns all the value in the form of Dai .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IFeed {
    function read() external view returns (bytes32);
}

interface ITub {
    function tab(bytes32 id) external view returns (uint256 debt);
    function ink(bytes32 id) external view returns (uint256 ink);
    function shut(bytes32 id) external;
    function bid(uint256 amount) external view returns (uint256 bought);
    function exit(uint256 amount) external;
}

interface IOTC {
    function sellAllAmount(address gem, uint256 amount, address pay, uint256 minPrice) external returns (uint256 bought);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    IERC20 public dai;
    ITub public tub;
    IFeed public feed;
    IOTC public otc;
    IERC20 public gem;
    uint256 public slippage;
    uint256 public WAD = 10**18;

    constructor(address _dai, address _tub, address _feed, address _otc, address _gem, uint256 _slippage) {
        dai = IERC20(_dai);
        tub = ITub(_tub);
        feed = IFeed(_feed);
        otc = IOTC(_otc);
        gem = IERC20(_gem);
        slippage = _slippage;
    }

    function shutForDai(uint _id) public onlyOwner {
        bytes32 id = bytes32(_id);
        uint debt = tub.tab(id);
        if (debt > 0) {
            require(dai.transferFrom(msg.sender, address(this), debt));
        }
        uint ink = tub.ink(id);
        tub.shut(id);
        uint gemBalance = tub.bid(ink);
        tub.exit(ink);
        uint price = uint(feed.read());
        uint bought = otc.sellAllAmount(address(gem), min(gemBalance, gem.balanceOf(address(this))), address(dai), wmul(WAD - slippage, wmul(gemBalance, price)));
        require(dai.transfer(msg.sender, bought));
    }

    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = x * y / WAD;
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'read', 'complexity': 0}, {'function': 'exit', 'complexity': 0}, {'function': 'sellAllAmount', 'complexity': 0}, {'function': 'shutForDai', 'complexity': 3}, {'function': 'wmul', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""shutdownCDP"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_cdpId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""daiAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""name"": ""owner"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112d41da0>}, {""type"": ""VariableDeclaration"", ""name"": ""collateral"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112d40600>}, {""type"": ""VariableDeclaration"", ""name"": ""debt"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""isStateVar"": False, ""isIndexed"": False, ""decl"": <solidity_parser.solidity_antlr4.SolidityParser.SolidityParser.VariableDeclarationContext object at 0x112c57a80>}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getCDPDetails""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_cdpId""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can shut down the CDP""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""daiAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""collateral""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": ""ether""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""debt""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""dai""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""daiAmount""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""shutdownCDP""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_cdpId""}], ""names"": []}}, {""type"": ""TupleExpression"", ""components"": [{""type"": ""BooleanLiteral"", ""value"": True}, {""type"": ""Identifier"", ""name"": ""daiAmount""}], ""isArray"": False}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'read', 'complexity': 0}, {'function': 'exit', 'complexity': 0}, {'function': 'sellAllAmount', 'complexity': 0}, {'function': 'shutForDai', 'complexity': 3}, {'function': 'wmul', 'complexity': 0}]",4.0,"
pragma solidity ^0.8.0;

contract MakerDAO {
    using SafeMath for uint256;

    function shutdownCDP(uint256 _cdpId) public returns (bool success, uint256 daiAmount) {
        // Get the CDP details
        (address owner, uint256 collateral, uint256 debt) = getCDPDetails(_cdpId);

        // Check if the caller is the owner of the CDP
        require(msg.sender == owner, ""Only the owner can shut down the CDP"");

        // Calculate the amount of Dai to be returned
        uint256 daiAmount = collateral.mul(1 ether).div(debt);

        // Transfer the Dai to the caller
        require(dai.transferFrom(address(this), msg.sender, daiAmount));

        // Shut down the CDP
        shutdownCDP(_cdpId);

        return (true, daiAmount);
    }

    function getCDPDetails(uint256 _cdpId) public view returns (address owner, uint256 collateral, uint256 debt) {
        // Get the CDP details from the MakerDAO contract
        (owner, collateral, debt) = makerDao.getCDPDetails(_cdpId);

        return (owner, collateral, debt);
    }

    function shutdownCDP(uint256 _cdpId) public {
        // Shut down the CDP by calling the MakerDAO contract
        makerDao.shutdownCDP(_cdpId);
    }
}",7.557126045227051,shutdownCDP,"[{'function': 'shutdownCDP', 'complexity': 2}, {'function': 'getCDPDetails', 'complexity': 0}, {'function': 'shutdownCDP', 'complexity': 0}]",6.0,65.0,0.6361533527448339,0.1042138707814199,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MakerDAO is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function shutdownCDP(uint256 _cdpId) public returns (bool success, uint256 daiAmount) {
        // Get the CDP details
        (address owner, uint256 collateral, uint256 debt) = getCDPDetails(_cdpId);

        // Check if the caller is the owner of the CDP
        require(msg.sender == owner, ""Only the owner can shut down the CDP"");

        // Calculate the amount of Dai to be returned
        daiAmount = collateral.mul(1 ether).div(debt);

        // Transfer the Dai to the caller
        require(dai.transferFrom(address(this), msg.sender, daiAmount));

        // Shut down the CDP
        shutdownCDP(_cdpId);

        return (true, daiAmount);
    }

    function getCDPDetails(uint256 _cdpId) public view returns (address owner, uint256 collateral, uint256 debt) {
        // Get the CDP details from the MakerDAO contract
        (owner, collateral, debt) = makerDao.getCDPDetails(_cdpId);

        return (owner, collateral, debt);
    }

    function shutdownCDP(uint256 _cdpId) public {
        // Shut down the CDP by calling the MakerDAO contract
        makerDao.shutdownCDP(_cdpId);
    }
}"
6386,Internal - Removes the owner of a ticker,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TickerContract {
    using SafeMath for uint256;

    function _deleteTickerOwnership(address _owner, string memory _ticker) internal {
        uint256 index = uint256(getUint(Encoder.getKey(""tickerIndex"", _ticker)));
        bytes32 ownerKey = Encoder.getKey(""userToTickers"", _owner);
        bytes32[] memory tickers = getArrayBytes32(ownerKey);
        assert(index < tickers.length);
        assert(_tickerOwner(_ticker) == _owner);
        deleteArrayBytes32(ownerKey, index);
        if (getArrayBytes32(ownerKey).length > index) {
            bytes32 switchedTicker = getArrayBytes32(ownerKey)[index];
            set(Encoder.getKey(""tickerIndex"", Util.bytes32ToString(switchedTicker)), index);
        }
    }
}","[{'function': '_deleteTickerOwnership', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_newOwner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""New owner cannot be the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the current owner can remove an owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""owner""}, ""right"": {""type"": ""Identifier"", ""name"": ""_newOwner""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': '_deleteTickerOwnership', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

contract Ticker {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function removeOwner(address _newOwner) public {
        require(_newOwner != address(0), ""New owner cannot be the zero address"");
        require(msg.sender == owner, ""Only the current owner can remove an owner"");
        owner = _newOwner;
    }
}",2.0432252883911133,removeOwner,"[{'function': 'removeOwner', 'complexity': 2}]",3.0,45.0,0.5353166497974501,0.0054979148201817,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Ticker is Ownable {
    address public owner;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function removeOwner(address _newOwner) public {
        require(_newOwner != address(0), ""New owner cannot be the zero address"");
        require(msg.sender == owner, ""Only the current owner can remove an owner"");
        owner = _newOwner;
    }
}"
5781,Get the allowance of an specified address to use another address balance .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleToken {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowed;

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}","[{'function': 'allowance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""memberName"": ""balance""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""spender""}, ""memberName"": ""balance""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'allowance', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function getAllowance(address owner, address spender) public view returns (uint256) {
        return owner.balance.sub(spender.balance);
    }
}",1.898742914199829,getAllowance,"[{'function': 'getAllowance', 'complexity': 0}]",1.0,5.0,0.8280862193788554,0.3124325727595954,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getAllowance(address owner, address spender) public view returns (uint256) {
        return owner.balance.sub(spender.balance);
    }
}"
5300,Last callback used to accept the ERC721 parcel tokens,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ERC721Receiver {
    using SafeMath for uint256;

    address public land;
    uint256 public flagReceiveLand;

    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns (bytes4) {
        if (msg.sender == land && flagReceiveLand == _tokenId) {
            flagReceiveLand = 0;
            return bytes4(0x150b7a02);
        }
    }
}","[{'function': 'onERC721Received', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""acceptParcelTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""length"": None}, ""name"": ""tokens"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No tokens provided""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc721""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc721""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onERC721Received', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC721/IERC721.sol"";
import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint;

    IERC721 public erc721;

    function acceptParcelTokens(uint[] memory tokens) public {
        require(tokens.length > 0, ""No tokens provided"");
        require(erc721.balanceOf(msg.sender) >= tokens.length, ""Insufficient balance"");

        for (uint i = 0; i < tokens.length; i++) {
            erc721.transferFrom(msg.sender, address(this), tokens[i]);
        }
    }
}",4.051749706268311,acceptParcelTokens,"[{'function': 'acceptParcelTokens', 'complexity': 3}]",4.0,43.0,0.513884994799535,0.0728705348523056,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC721/IERC721.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint;

    IERC721 public erc721;
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');

    mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        erc721 = IERC721(DEFAULT_ADDRESS);
    }

    function acceptParcelTokens(uint[] memory tokens) public {
        require(tokens.length > 0, ""No tokens provided"");
        require(erc721.balanceOf(msg.sender) >= tokens.length, ""Insufficient balance"");

        for (uint i = 0; i < tokens.length; i++) {
            erc721.transferFrom(msg.sender, address(this), tokens[i]);
        }
    }
}"
6110,Access point for the oracle to update the prices of havvens / eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IOracle {
    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external;
}

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint public usdToEthPrice;
    uint public usdToHavPrice;
    uint public lastPriceUpdateTime;
    uint public constant ORACLE_FUTURE_LIMIT = 1 hours; // Example limit, adjust as needed

    event PricesUpdated(uint indexed newEthPrice, uint indexed newHavvenPrice, uint indexed timeSent);

    modifier onlyOracle() {
        require(msg.sender == owner(), ""Only the oracle can call this function"");
        _;
    }

    function updatePrices(uint newEthPrice, uint newHavvenPrice, uint timeSent) external onlyOracle {
        require(lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT, ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"");
        usdToEthPrice = newEthPrice;
        usdToHavPrice = newHavvenPrice;
        lastPriceUpdateTime = timeSent;
        emit PricesUpdated(usdToEthPrice, usdToHavPrice, lastPriceUpdateTime);
    }
}","[{'function': 'updatePrices', 'complexity': 0}, {'function': 'updatePrices', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ethPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""havvenPrice"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the oracle can update prices""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""PriceUpdated""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""ethPrice""}, {""type"": ""Identifier"", ""name"": ""havvenPrice""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updatePrices', 'complexity': 0}, {'function': 'updatePrices', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract HavvenOracle {
    using SafeMath for uint256;

    event PriceUpdated(uint256 ethPrice, uint256 havvenPrice);

    function updatePrices(uint256 ethPrice, uint256 havvenPrice) external {
        require(msg.sender == address(this), ""Only the oracle can update prices"");
        emit PriceUpdated(ethPrice, havvenPrice);
    }
}",2.4426429271698,updatePrices,"[{'function': 'updatePrices', 'complexity': 1}]",2.0,22.0,0.8733829883541433,0.0329736369403813,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract HavvenOracle is Ownable {
    using SafeMath for uint256;

    event PriceUpdated(uint256 ethPrice, uint256 havvenPrice);

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        ethPrice = 1;
        havvenPrice = 1;
    }

    uint256 public ethPrice;
    uint256 public havvenPrice;

    function updatePrices(uint256 ethPrice, uint256 havvenPrice) external {
        require(msg.sender == address(this), ""Only the oracle can update prices"");
        emit PriceUpdated(ethPrice, havvenPrice);
    }
}"
1872,selfdestructs and sends the balance to ` escrowModerator ` or ` beneficiary `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Auction {
    function auctionState() external view returns (AuctionStates);
    function escrowModerator() external view returns (address);
    function beneficiary() external view returns (address);
}

abstract contract AuctionWrapper is Ownable, Auction {
    using SafeMath for uint256;

    enum AuctionStates { NotStarted, Active, Ended, Canceled }

    AuctionStates public auctionState;
    address public escrowModerator;
    address public beneficiary;

    function setAuctionState(AuctionStates state) external onlyOwner {
        auctionState = state;
    }

    function setEscrowModerator(address moderator) external onlyOwner {
        escrowModerator = moderator;
    }

    function setBeneficiary(address ben) external onlyOwner {
        beneficiary = ben;
    }

    function cleanUpAfterYourself() public {
        require(auctionState == AuctionStates.Ended, ""Auction is not ended."");
        if (escrowModerator != address(0)) {
            selfdestruct(escrowModerator);
        } else {
            selfdestruct(beneficiary);
        }
    }
}","[{'function': 'beneficiary', 'complexity': 0}, {'function': 'setAuctionState', 'complexity': 0}, {'function': 'setEscrowModerator', 'complexity': 0}, {'function': 'setBeneficiary', 'complexity': 0}, {'function': 'cleanUpAfterYourself', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""selfdestructAndSendBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""escrowModerator""}}}, {""type"": ""stringLiteral"", ""value"": ""Only beneficiary or moderator can call this function""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""min""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""recipient"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Conditional"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""beneficiary""}}, ""TrueExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""beneficiary""}], ""names"": []}, ""FalseExpression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""escrowModerator""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""selfdestruct""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'beneficiary', 'complexity': 0}, {'function': 'setAuctionState', 'complexity': 0}, {'function': 'setEscrowModerator', 'complexity': 0}, {'function': 'setBeneficiary', 'complexity': 0}, {'function': 'cleanUpAfterYourself', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    address public escrowModerator;
    address public beneficiary;

    function selfdestructAndSendBalance(uint256 amount) external {
        require(msg.sender == beneficiary || msg.sender == escrowModerator, ""Only beneficiary or moderator can call this function"");
        uint256 balance = address(this).balance;
        if (amount > 0) {
            amount = SafeMath.min(amount, balance);
            address payable recipient = msg.sender == beneficiary ? payable(beneficiary) : payable(escrowModerator);
            recipient.transfer(amount);
        } else {
            selfdestruct(recipient);
        }
    }
}",4.074622869491577,selfdestructAndSendBalance,"[{'function': 'selfdestructAndSendBalance', 'complexity': 5}]",4.0,16.0,0.5966393840769623,0.1730312035622254,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    address public escrowModerator;
    address public beneficiary;

    constructor() Ownable(msg.sender) {
        escrowModerator = 0x1111111111111111111111111111111111111111; // Replace with actual address
        beneficiary = 0x2222222222222222222222222222222222222222; // Replace with actual address
    }

    function selfdestructAndSendBalance(uint256 amount) external {
        require(msg.sender == beneficiary || msg.sender == escrowModerator, ""Only beneficiary or moderator can call this function"");
        uint256 balance = address(this).balance;
        if (amount > 0) {
            amount = SafeMath.min(amount, balance);
            address payable recipient = msg.sender == beneficiary ? payable(beneficiary) : payable(escrowModerator);
            recipient.transfer(amount);
        } else {
            selfdestruct(recipient);
        }
    }
}"
4928,Sets the contract which implements a specific interface for an address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC820ImplementerInterface {
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns (bytes4);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    bytes4 constant private ERC820_ACCEPT_MAGIC = 0xffffffff;
    mapping(address => mapping(bytes32 => address)) public interfaces;

    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address implementer);

    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == 0 ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, ""Not the manager"");
        require(!isERC165Interface(_interfaceHash), ""Must not be a ERC165 hash"");
        if (_implementer != 0 && _implementer != msg.sender) {
            require(ERC820ImplementerInterface(_implementer).canImplementInterfaceForAddress(_interfaceHash, addr) == ERC820_ACCEPT_MAGIC, ""Does not implement the interface"");
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    function getManager(address addr) internal view returns (address) {
        // Implement logic to retrieve the manager for the address
        return owner();
    }

    function isERC165Interface(bytes32 interfaceHash) internal pure returns (bool) {
        // Implement logic to check if the interface hash is an ERC165 hash
        return false;
    }
}","[{'function': 'canImplementInterfaceForAddress', 'complexity': 0}, {'function': 'setInterfaceImplementer', 'complexity': 7}, {'function': 'getManager', 'complexity': 0}, {'function': 'isERC165Interface', 'complexity': 0}]",6.0,{},"[{'function': 'canImplementInterfaceForAddress', 'complexity': 0}, {'function': 'setInterfaceImplementer', 'complexity': 7}, {'function': 'getManager', 'complexity': 0}, {'function': 'isERC165Interface', 'complexity': 0}]",6.0,"
contract InterfaceSet {
    mapping(address => uint256) public interfaceId;

    function setInterface(address _address, uint256 _interfaceId) external {
        require(_address != address(0), ""Address cannot be zero"");
        require(_interfaceId > 0, ""Interface ID must be greater than zero"");
        interfaceId[_address] = _interfaceId;
    }
}",1.7217094898223877,setInterface,"[{'function': 'setInterface', 'complexity': 2}]",3.0,58.0,0.7306301799142884,0.037623331183376,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract InterfaceSet is Ownable {
    mapping(address => uint256) public interfaceId;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setInterface(address _address, uint256 _interfaceId) external {
        require(_address != address(0), ""Address cannot be zero"");
        require(_interfaceId > 0, ""Interface ID must be greater than zero"");
        interfaceId[_address] = _interfaceId;
    }
}"
1268,"This creates a Pledge with an initial amount of 0 if one is not created already ; otherwise it finds the pledge with the specified attributes ; all pledges technically exist , if the pledge has n't been created in this system yet it simply is n't in the hash array hPledge2idx [ ] yet","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeManager is Ownable {
    using SafeMath for uint256;

    struct Pledge {
        uint256 amount;
        uint64 owner;
        uint64[] delegationChain;
        uint64 intendedProject;
        uint64 commitTime;
        uint64 oldPledge;
        PledgeState state;
    }

    enum PledgeState { Active, Canceled, Refunded }

    mapping(bytes32 => uint64) public hPledge2idx;
    Pledge[] public pledges;

    function findOrCreatePledge(uint64 owner, uint64[] memory delegationChain, uint64 intendedProject, uint64 commitTime, uint64 oldPledge, PledgeState state) internal returns (uint64) {
        bytes32 hPledge = keccak256(abi.encodePacked(owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        uint64 idx = hPledge2idx[hPledge];
        if (idx > 0) return idx;
        idx = uint64(pledges.length);
        hPledge2idx[hPledge] = idx;
        pledges.push(Pledge(0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));
        return idx;
    }
}","[{'function': 'findOrCreatePledge', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""createPledge"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_pledgeAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""index"": {""type"": ""Identifier"", ""name"": ""_pledgeAddress""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""index"": {""type"": ""Identifier"", ""name"": ""_pledgeAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""hPledge2idx""}, ""memberName"": ""length""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_pledgeAddress""}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""index"": {""type"": ""Identifier"", ""name"": ""_pledgeAddress""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""index"": {""type"": ""Identifier"", ""name"": ""_pledgeAddress""}}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'findOrCreatePledge', 'complexity': 0}]",2.0,"
pragma solidity ^0.8.0;

contract Pledge {
    using SafeMath for uint256;

    mapping (address => uint256) public pledges;
    mapping (uint256 => address) public hPledge2idx;

    function createPledge(address _pledgeAddress, uint256 _amount) public {
        if (pledges[_pledgeAddress] == 0) {
            pledges[_pledgeAddress] = _amount;
            hPledge2idx[hPledge2idx.length] = _pledgeAddress;
        } else {
            pledges[_pledgeAddress] = SafeMath.add(pledges[_pledgeAddress], _amount);
        }
    }
}",3.499606370925904,createPledge,"[{'function': 'createPledge', 'complexity': 1}]",2.0,56.0,0.609692545922354,0.0057019754226272,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Pledge is Ownable {
    using SafeMath for uint256;

    mapping (address => uint256) public pledges;
    mapping (uint256 => address) public hPledge2idx;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        uint256 initialAmount = 1; // Set to a non-zero, safe value for uint256
        pledges[address(0x111)] = initialAmount;
        hPledge2idx[hPledge2idx.length] = address(0x111);

        if (pledges[address(0x222)] == 0) {
            pledges[address(0x222)] = initialAmount;
            hPledge2idx[hPledge2idx.length] = address(0x222);
        } else {
            pledges[address(0x222)] = SafeMath.add(pledges[address(0x222)], initialAmount);
        }

        if (pledges[address(0x333)] == 0) {
            pledges[address(0x333)] = initialAmount;
            hPledge2idx[hPledge2idx.length] = address(0x333);
        } else {
            pledges[address(0x333)] = SafeMath.add(pledges[address(0x333)], initialAmount);
        }
    }

    function createPledge(address _pledgeAddress, uint256 _amount) public {
        if (pledges[_pledgeAddress] == 0) {
            pledges[_pledgeAddress] = _amount;
            hPledge2idx[hPledge2idx.length] = _pledgeAddress;
        } else {
            pledges[_pledgeAddress] = SafeMath.add(pledges[_pledgeAddress], _amount);
        }
    }
}"
6042,Returns all the relevant information about a specific library .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract LibraryWrapper is Ownable {
    using SafeMath for uint256;

    struct Library {
        string name;
        string language;
        uint256 price;
    }

    mapping(uint256 => Library) public libraries;
    mapping(uint256 => address) public libraryIndexToFounder;
    mapping(uint256 => uint256) public libraryIndexToFunds;
    mapping(uint256 => uint256) public libraryIndexToPrice;
    mapping(uint256 => address) public libraryIndexToOwner;

    function getLibrary(uint256 _tokenId) public view returns (string memory language, string memory libraryName, uint256 tokenPrice, uint256 funds, address tokenOwner, address founder) {
        Library storage x = libraries[_tokenId];
        libraryName = x.name;
        language = x.language;
        founder = libraryIndexToFounder[_tokenId];
        funds = libraryIndexToFunds[_tokenId];
        tokenPrice = libraryIndexToPrice[_tokenId];
        tokenOwner = libraryIndexToOwner[_tokenId];
    }
}","[{'function': 'getLibrary', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLibraryInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_libraryAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""LibraryInfo""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""libraries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_libraryAddress""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getLibrary', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Library {
    struct LibraryInfo {
        address owner;
        string name;
        uint256 books;
        uint256 copies;
    }

    mapping(address => LibraryInfo) public libraries;

    function getLibraryInfo(address _libraryAddress) public view returns (LibraryInfo memory) {
        return libraries[_libraryAddress];
    }
}",1.8278493881225584,getLibraryInfo,"[{'function': 'getLibraryInfo', 'complexity': 0}]",1.0,48.0,0.6609896236647425,0.0301371843546468,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Library is Ownable {
    struct LibraryInfo {
        address owner;
        string name;
        uint256 books;
        uint256 copies;
    }

    mapping(address => LibraryInfo) public libraries;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            libraries[addr] = LibraryInfo({
                owner: msg.sender,
                name: 'initialized',
                books: 1,
                copies: uint256(bytes32('init'))
            });
        }
    }

    function getLibraryInfo(address _libraryAddress) public view returns (LibraryInfo memory) {
        return libraries[_libraryAddress];
    }
}"
1213,Get the token balance for a specified address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function balanceOf(address tokenOwner) external view returns (uint balance);
}

abstract contract ERC20Wrapper is Ownable {
    using SafeMath for uint;

    mapping(address => uint) public balances;

 function balanceOf (address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; }


}","[{'function': 'balanceOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTokenBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'balanceOf ', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function getTokenBalance(address _owner) public view returns (uint256 balance) {
        return IERC20(tokenAddress).balanceOf(_owner);
    }
}",1.6625962257385254,getTokenBalance,"[{'function': 'getTokenBalance', 'complexity': 0}]",1.0,4.0,0.8121988944316293,0.2677353447271197,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;
    address public constant tokenAddress = 0x1111111111111111111111111111111111111111; // Replace with actual token address

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getTokenBalance(address _owner) public view returns (uint256 balance) {
        return IERC20(tokenAddress).balanceOf(_owner);
    }
}"
6726,transfers tokens in ERC20 compatible way using signature to recover token sender,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TransferWrapper is Ownable {
    using SafeMath for uint256;

    function transferWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig) public returns (bool) {
        doSendWithSignature(_to, _amount, _fee, _data, _nonce, _sig, false);
        return true;
    }

    function doSendWithSignature(address _to, uint256 _amount, uint256 _fee, bytes memory _data, uint256 _nonce, bytes memory _sig, bool) internal {
        // Implementation of the original function logic would go here.
    }
}","[{'function': 'transferWithSignature', 'complexity': 0}, {'function': 'doSendWithSignature', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""signature"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Recipient cannot be the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""signature""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""65"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Signature length must be 65 bytes""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenSender"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""recoverTokenSender""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""signature""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""transferAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""safeSub""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""10000"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenSender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""transferAmount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferWithSignature', 'complexity': 0}, {'function': 'doSendWithSignature', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _tokenAddress) public {
        token = IERC20(_tokenAddress);
    }

    function transferTokens(uint256 amount, address recipient, bytes memory signature) public {
        require(amount > 0, ""Amount must be greater than zero"");
        require(recipient != address(0), ""Recipient cannot be the zero address"");
        require(signature.length == 65, ""Signature length must be 65 bytes"");

        // Recover token sender from signature
        address tokenSender = recoverTokenSender(amount, recipient, signature);

        // Transfer tokens to recipient
        uint256 transferAmount = amount.safeSub(10000);
        require(token.transferFrom(tokenSender, recipient, transferAmount), ""Transfer failed"");
    }

    function recoverTokenSender(uint256 amount, address recipient, bytes memory signature) private pure returns (address) {
        // Recover token sender from signature
        return ECDSA.recover(keccak256(abi.encodePacked(amount, recipient)), signature);
    }
}",10.810147762298584,transferTokens,"[{'function': 'transferTokens', 'complexity': 4}, {'function': 'recoverTokenSender', 'complexity': 0}]",5.0,46.0,0.6593234059200841,0.0170227713012476,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    IERC20 public token;

    constructor(address _tokenAddress) public Ownable(msg.sender) {
        token = IERC20(_tokenAddress);
    }

    function transferTokens(uint256 amount, address recipient, bytes memory signature) public {
        require(amount > 0, ""Amount must be greater than zero"");
        require(recipient != address(0), ""Recipient cannot be the zero address"");
        require(signature.length == 65, ""Signature length must be 65 bytes"");

        // Recover token sender from signature
        address tokenSender = recoverTokenSender(amount, recipient, signature);

        // Transfer tokens to recipient
        uint256 transferAmount = amount.safeSub(10000);
        require(token.transferFrom(tokenSender, recipient, transferAmount), ""Transfer failed"");
    }

    function recoverTokenSender(uint256 amount, address recipient, bytes memory signature) private pure returns (address) {
        // Recover token sender from signature
        return ECDSA.recover(keccak256(abi.encodePacked(amount, recipient)), signature);
    }
}"
6123,"` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 amount, address tokenContract, bytes calldata extraData) external;
}

abstract contract TokenRecipient is Ownable {
    using SafeMath for uint256;

    function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {
        if (!approve(_spender, _amount)) throw;
        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);
        return true;
    }
}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'receiveApproval', 'complexity': 0}, {'function': 'approveAndCall', 'complexity': 1}]",2.0,"a pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_amount > 0, ""Invalid amount"");
        // Additional logic can be added here
        return true;
    }
}",2.2234203815460205,approve,"[{'function': 'approve', 'complexity': 2}]",3.0,19.0,0.8327513816814739,0.3025360953337131,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(_spender != address(0), ""Invalid spender address"");
        require(_amount > 0, ""Invalid amount"");
        // Additional logic can be added here
        return true;
    }
}"
240,Used to check if an address is a delegate or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName is Ownable {
    using SafeMath for uint256;

    function checkDelegate(address _potentialDelegate) external view returns (bool) {
        // Implementation of the checkDelegate function
    }
}","[{'function': 'checkDelegate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""isDelegate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_addr"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_addr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_addr""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}], ""names"": []}}], ""isArray"": False}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'checkDelegate', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract DelegateChecker {
    using SafeMath for uint256;

    function isDelegate(address _addr) public view returns (bool) {
        return (_addr == address(this)) || (_addr == address(owner));
    }
}",1.4483447074890137,isDelegate,"[{'function': 'isDelegate', 'complexity': 0}]",2.0,21.0,0.751116307078533,0.1685173335664709,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DelegateChecker is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        owner = msg.sender;
    }

    function isDelegate(address _addr) public view returns (bool) {
        return (_addr == address(this)) || (_addr == address(owner));
    }
}"
3785,Clear collection # ` ( _collectionIndex ) `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/utils/SafeMath.sol"";

abstract contract PixelConContract is Ownable {
    using SafeMath for uint256;

    struct PixelCon {
        uint256 tokenId;
        uint64 collectionIndex;
    }

    uint256 public totalCollections;
    mapping(uint256 => uint64[]) public collectionTokens;
    mapping(uint256 => string) public collectionNames;
    mapping(uint64 => PixelCon) public pixelcons;

    event ClearCollection(uint256 indexed _collectionIndex);

    modifier validIndex(uint256 _collectionIndex) {
        require(_collectionIndex < totalCollections(), ""Collection does not exist"");
        _;
    }

    function clearCollection(uint256 _collectionIndex) public validIndex(_collectionIndex) returns (uint64) {
        uint64[] storage collection = collectionTokens[_collectionIndex];
        require(collection.length > 0, ""Collection is already cleared"");
        for (uint i = 0; i < collection.length; i++) {
            PixelCon storage pixelcon = pixelcons[collection[i]];
            require(isCreatorAndOwner(msg.sender, pixelcon.tokenId), ""Sender is not the creator and owner of the PixelCons"");
            pixelcon.collectionIndex = 0;
        }
        delete collectionNames[_collectionIndex];
        delete collectionTokens[_collectionIndex];
        emit ClearCollection(_collectionIndex);
        return _collectionIndex;
    }

    function totalCollections() public view returns (uint256) {
        return totalCollections;
    }
}","[{'function': 'clearCollection', 'complexity': 3}, {'function': 'totalCollections', 'complexity': 0}]",4.0,{},"[{'function': 'clearCollection', 'complexity': 3}, {'function': 'totalCollections', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function clearCollection(uint256 _collectionIndex) public {
        // Additional logic can be added here
    }
}",2.0268442630767822,clearCollection,"[{'function': 'clearCollection', 'complexity': 0}]",1.0,76.0,0.83854583867351,0.0044051440327228,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        collectionIndex = 1;
        address1 = address(0x111);
        address2 = address(0x222);
        address3 = address(0x333);
        isInitialized = true;
        tokenName = 'MyToken';
    }

    uint256 private collectionIndex;
    address private address1;
    address private address2;
    address private address3;
    bool private isInitialized;
    string private tokenName;

    function clearCollection(uint256 _collectionIndex) public {
        // Additional logic can be added here
    }
}"
3163,` proxyPayment ( ) ` allows the caller to send ether to the Campaign but does not create tokens .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ProxyPayment is Ownable {
    using SafeMath for uint256;

    function proxyPayment(address _owner) public payable returns (bool) {
        doTakerPayment();
        return true;
    }

    function doTakerPayment() internal virtual;
}","[{'function': 'proxyPayment', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""proxyPayment"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid payment""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ProxyPayment""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'proxyPayment', 'complexity': 0}]",2.0,"
pragma solidity ^0.8.0;

contract Campaign {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    receive() external payable {
        require(msg.value > 0, ""Invalid payment"");
        emit PaymentReceived(msg.sender, msg.value);
    }

    function proxyPayment() external payable {
        require(msg.value > 0, ""Invalid payment"");
        owner.transfer(msg.value);
        emit ProxyPayment(msg.sender, msg.value);
    }

    event PaymentReceived(address indexed _from, uint256 _amount);
    event ProxyPayment(address indexed _from, uint256 _amount);
}",3.3485145568847656,proxyPayment,"[{'function': 'proxyPayment', 'complexity': 1}]",2.0,22.0,0.7599599243095921,0.0502111958576134,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Campaign is Ownable {
    address public owner;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    receive() external payable {
        require(msg.value > 0, ""Invalid payment"");
        emit PaymentReceived(msg.sender, msg.value);
    }

    function proxyPayment() external payable {
        require(msg.value > 0, ""Invalid payment"");
        owner.transfer(msg.value);
        emit ProxyPayment(msg.sender, msg.value);
    }

    event PaymentReceived(address indexed _from, uint256 _amount);
    event ProxyPayment(address indexed _from, uint256 _amount);
}"
4854,A constant getter that returns the total number of pledges,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Pledges {
    using SafeMath for uint256;

    mapping(uint => address) public pledges;

    function numberOfPledges() public view returns (uint) {
        return pledges.length.sub(1);
    }
}","[{'function': 'numberOfPledges', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""totalPledges"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""Identifier"", ""name"": ""_totalPledges""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'numberOfPledges', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract Pledge {
    using SafeMath for uint256;

    function totalPledges() public view returns (uint256) {
        return _totalPledges;
    }
}",1.2682735919952393,totalPledges,"[{'function': 'totalPledges', 'complexity': 0}]",1.0,4.0,0.845657796829417,0.3518844119717831,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Pledge is Ownable {
    using SafeMath for uint256;

    uint256 private _totalPledges = 1;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function totalPledges() public view returns (uint256) {
        return _totalPledges;
    }
}"
6206,Returns owner of a given Asset ( Token ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public assetIndexToOwner;

    function ownerOf(uint256 _tokenId) public view returns (address owner) {
        return assetIndexToOwner[_tokenId];
    }
}","[{'function': 'ownerOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAssetOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""assetAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC721""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC721""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""assetAddress""}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""ownerOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""assetAddress""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'ownerOf', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/token/ERC721/IERC721.sol"";

contract AssetOwner {
    function getAssetOwner(address assetAddress) public view returns (address owner) {
        IERC721 token = IERC721(assetAddress);
        return token.ownerOf(assetAddress);
    }
}",2.4417998790740967,getAssetOwner,"[{'function': 'getAssetOwner', 'complexity': 0}]",1.0,8.0,0.7582921086345011,0.2958675749494724,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/token/ERC721/IERC721.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetOwner is Ownable {
    constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function getAssetOwner(address assetAddress) public view returns (address owner) {
        IERC721 token = IERC721(assetAddress);
        return token.ownerOf(assetAddress);
    }
}"
780,Checks if two strings are equal or not .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract EqualsWrapper {
    using SafeMath for uint256;

    function equals(string memory a, string memory b) internal pure returns (bool result) {
    if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {
        return true;
    }
    return false;
}
}","[{'function': 'equals', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""equals"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""a"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""b"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""a""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""b""}], ""names"": []}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'equals', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

library StringUtils {
    using SafeMath for uint256;

    function equals(string memory a, string memory b) public pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}",1.6480607986450195,equals,"[{'function': 'equals', 'complexity': 0}]",1.0,2.0,0.9623110620766948,0.6228856406332864,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

library StringUtils {
    using SafeMath for uint256;

    function equals(string memory a, string memory b) public pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}
import ""openzeppelin/SafeMath.sol"";
contract StringUtilsContract is Ownable, StringUtils {
    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        uintValue = 1;
        addressValue = address(uint160(uint256(keccak256('address1'))));
        boolValue = true;
        stringValue = 'initialized';
        bytes32Value = bytes32('init');
    }

    uint public uintValue;
    address public addressValue;
    bool public boolValue;
    string public stringValue;
    bytes32 public bytes32Value;
}"
6276,"The fallback function : If the contract 's controller has not been set to 0 , the ether is sent to the controller ( normally the token creation contract ) using the ` proxyPayment ` method .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function proxyPayment() external payable returns (bool);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    address public controller;

    constructor(address _controller) {
        require(_controller != address(0), ""Invalid controller address"");
        controller = _controller;
    }

    receive() external payable {
        if (controller == address(0)) revert();
        if (isContract(controller)) {
            TokenController tokenController = TokenController(controller);
            require(tokenController.proxyPayment{value: msg.value}(msg.sender), ""Proxy payment failed"");
        } else {
            require(controller.send(msg.value), ""Send value failed"");
        }
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","[{'function': 'proxyPayment', 'complexity': 0}, {'function': 'isContract', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""fallback"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""controller""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""proxyPayment""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}], ""names"": []}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Controller not set""}], ""names"": []}}]}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": True, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'proxyPayment', 'complexity': 0}, {'function': 'isContract', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    address public controller;

    constructor() public {
        controller = msg.sender;
    }

    fallback() external payable {
        if (controller != 0) {
            proxyPayment(msg.value);
        } else {
            revert(""Controller not set"");
        }
    }

    function proxyPayment(uint256 value) private {
        controller.transfer(value);
    }
}",5.747488260269165,proxyPayment,"[{'function': 'proxyPayment', 'complexity': 0}]",1.0,12.0,0.3104618161632345,0.0076608086754178,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract MyContract is Ownable {
    using SafeMath for uint256;

    address public controller = msg.sender;

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables here as they are already initialized in the parent constructor
    }

    fallback() external payable {
        if (controller != 0) {
            proxyPayment(msg.value);
        } else {
            revert(""Controller not set"");
        }
    }

    function proxyPayment(uint256 value) private {
        controller.transfer(value);
    }
}"
321,Function used by the main partner to set the start time of the funding,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function setFundingStartTime(uint _startTime) external onlyOwner {
        // Assuming startTime is stored in a state variable named fundingStartTime
        require(_startTime > block.timestamp, ""Start time must be in the future"");
        fundingStartTime = _startTime;
    }

    uint256 public fundingStartTime;
}","[{'function': 'setFundingStartTime', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setStartTime"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""startTime"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""partner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the main partner can set the start time""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""startTime""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}}, {""type"": ""stringLiteral"", ""value"": ""The start time must be in the future""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_startTime""}, ""right"": {""type"": ""Identifier"", ""name"": ""startTime""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setFundingStartTime', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Funding {
    using SafeMath for uint256;

    function setStartTime(uint256 startTime) external {
        require(msg.sender == partner, ""Only the main partner can set the start time"");
        require(startTime > block.timestamp, ""The start time must be in the future"");
        _startTime = startTime;
    }
}",2.1345858573913574,setStartTime,"[{'function': 'setStartTime', 'complexity': 2}]",3.0,9.0,0.7859355061416359,0.2206099613424276,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract Funding is Ownable {
    using SafeMath for uint256;
    uint256 public _startTime = 1; // Set to 1 (never 0)
    address public _partnerAddress = 0x1111111111111111111111111111111111111111; // Use fixed values in order
    bool public _isInitialized = true; // Set to true

    constructor() Ownable(msg.sender) {
        _startTime = block.timestamp + 1; // Set to a future time
        _partnerAddress = 0x2222222222222222222222222222222222222222; // Use fixed values in order
        _isInitialized = true;
    }

    function setStartTime(uint256 startTime) external {
        require(msg.sender == partner, ""Only the main partner can set the start time"");
        require(startTime > block.timestamp, ""The start time must be in the future"");
        _startTime = startTime;
    }
}"
2712,Only owner is allowed to perform this operation .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function burn(uint256 _value) external;
}

abstract contract Token is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping (address => uint256) public balances;
    uint256 public tokenTotalSupply;

    event Burn(address indexed from, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function burn(uint256 _value) onlyOwner external {
        require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        tokenTotalSupply = tokenTotalSupply.sub(_value);
        emit Burn(msg.sender, _value);
        emit Transfer(msg.sender, address(0x0), _value);
    }
}","[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""restrictedOperation"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can perform this operation""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'burn', 'complexity': 0}, {'function': 'burn', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract OwnerRestricted {
    address private owner;

    constructor() public {
        owner = msg.sender;
    }

    function restrictedOperation() public view returns (bool) {
        require(msg.sender == owner, ""Only the owner can perform this operation"");

        return true;
    }
}",1.6812269687652588,restrictedOperation,"[{'function': 'restrictedOperation', 'complexity': 1}]",3.0,42.0,0.4067608706832372,0.0248649218964112,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract OwnerRestricted is Ownable {
    address private _owner;

    constructor() public Ownable(msg.sender) {
        _owner = msg.sender;
    }

    function restrictedOperation() public view returns (bool) {
        require(msg.sender == owner(), ""Only the owner can perform this operation"");
        return true;
    }
}"
3285,Enable or disable approval for a third party ( `` operator '' ) to manage all your asset .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract ERC1155Wrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) private _operatorApprovals;

    event ApprovalForAll(address indexed operator, address indexed owner, bool approved);

    function setApprovalForAll(address _operator, bool _approved) external {
        require(_operator != address(0), ""ERC1155: setting approval status for the zero address"");
        require(msg.sender == _operator || isApprovedForAll(msg.sender, _operator), ""ERC1155: must be approved to set approval for all"");

        _operatorApprovals[_operator] = _approved;
        emit ApprovalForAll(_operator, msg.sender, _approved);
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[operator];
    }
}","[{'function': 'setApprovalForAll', 'complexity': 3}, {'function': 'isApprovedForAll', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""setOperatorApproval"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""approved"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operators""}, ""index"": {""type"": ""Identifier"", ""name"": ""operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""approved""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setApprovalForAll', 'complexity': 3}, {'function': 'isApprovedForAll', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol"";

contract AssetManager {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public operators;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can perform this action"");
        _;
    }

    function setOperatorApproval(address operator, bool approved) external onlyOwner {
        operators[operator] = approved;
    }
}",3.2645418643951416,setOperatorApproval,"[{'function': 'setOperatorApproval', 'complexity': 0}]",1.0,31.0,0.8153132217928766,0.0017939649395017,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AssetManager is Ownable {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public operators;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, ""Only the owner can perform this action"");
        _;
    }

    function setOperatorApproval(address operator, bool approved) external onlyOwner {
        operators[operator] = approved;
    }
}"
382,"Rent out an area of blocks at coordinates [ fromX , fromY , toX , toY ] at a price for each block in wei","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract RentalArea is Ownable {
    using SafeMath for uint256;

    struct Rental {
        address renter;
        uint rentPricePerPeriodWei;
        uint[] rentedBlocks;
    }

    mapping(uint => Rental) public rentals;
    uint public rentalCount;

    event LogRentsOut(uint id, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei);

    function isLegalCoordinates(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (bool) {
        // Implement the logic to check if coordinates are legal
        return true;
    }

    function blocksList(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) internal pure returns (uint[] memory) {
        // Implement the logic to generate a list of block IDs based on coordinates
        uint length = (toX - fromX + 1) * (toY - fromY + 1);
        uint[] memory blocks = new uint[](length);
        for (uint i = 0; i < length; i++) {
            blocks[i] = i;
        }
        return blocks;
    }

    function rentOutArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint rentPricePerPeriodWei) external whenNotPaused {
        require(isLegalCoordinates(fromX, fromY, toX, toY));
        uint id = rentals.rentOutBlocks(msg.sender, rentPricePerPeriodWei, blocksList(fromX, fromY, toX, toY));
        emit LogRentsOut(id, fromX, fromY, toX, toY, rentPricePerPeriodWei);
    }
}","[{'function': 'isLegalCoordinates', 'complexity': 0}, {'function': 'blocksList', 'complexity': 1}, {'function': 'rentOutArea', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""rentArea"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fromX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""fromY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""toX"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""toY"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""pricePerBlock"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""*"", ""left"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""toX""}, ""right"": {""type"": ""Identifier"", ""name"": ""fromX""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""isArray"": False}, ""right"": {""type"": ""TupleExpression"", ""components"": [{""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""toY""}, ""right"": {""type"": ""Identifier"", ""name"": ""fromY""}}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}], ""isArray"": False}}, ""right"": {""type"": ""Identifier"", ""name"": ""pricePerBlock""}}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient payment""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""x"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""fromX""}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""x""}, ""right"": {""type"": ""Identifier"", ""name"": ""toX""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""x""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""y"", ""storageLocation"": None}], ""initialValue"": {""type"": ""Identifier"", ""name"": ""fromY""}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""y""}, ""right"": {""type"": ""Identifier"", ""name"": ""toY""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""y""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": []}}]}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'isLegalCoordinates', 'complexity': 0}, {'function': 'blocksList', 'complexity': 1}, {'function': 'rentOutArea', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract Rental {
    using SafeMath for uint256;

    function rentArea(uint256 fromX, uint256 fromY, uint256 toX, uint256 toY, uint256 pricePerBlock) public payable returns (bool success) {
        require(msg.value >= (toX - fromX + 1) * (toY - fromY + 1) * pricePerBlock, ""Insufficient payment"");

        for (uint256 x = fromX; x <= toX; x++) {
            for (uint256 y = fromY; y <= toY; y++) {
                // Rent out the block at coordinates [x, y]
            }
        }

        return true;
    }
}",3.842424154281616,rentArea,"[{'function': 'rentArea', 'complexity': 4}]",4.0,32.0,0.5153017982967387,0.2457620489940614,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract Rental is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        fromX = 1;
        fromY = 1;
        toX = 2;
        toY = 2;
        pricePerBlock = 100; // Example value, adjust as needed
    }

    uint256 public fromX;
    uint256 public fromY;
    uint256 public toX;
    uint256 public toY;
    uint256 public pricePerBlock;

    function rentArea(uint256 fromX, uint256 fromY, uint256 toX, uint256 toY, uint256 pricePerBlock) public payable returns (bool success) {
        require(msg.value >= (toX - fromX + 1) * (toY - fromY + 1) * pricePerBlock, ""Insufficient payment"");

        for (uint256 x = fromX; x <= toX; x++) {
            for (uint256 y = fromY; y <= toY; y++) {
                // Rent out the block at coordinates [x, y]
            }
        }

        return true;
    }
}"
1424,Allows the owner to revoke the vesting .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Basic {
    function balanceOf(address account) external view returns (uint256);
    function safeTransfer(address to, uint256 value) external;
}

abstract contract RevocableToken is Ownable {
    using SafeMath for uint256;

    bool public revocable;
    mapping(ERC20Basic => bool) public revoked;

    event Revoked();

    function revoke(ERC20Basic _token) public onlyOwner {
        require(revocable, ""Revoke: Contract is not revocable"");
        require(!revoked[_token], ""Revoke: Token already revoked"");
        uint256 balance = _token.balanceOf(address(this));
        uint256 unreleased = releasableAmount(_token);
        uint256 refund = balance.sub(unreleased);
        revoked[_token] = true;
        _token.safeTransfer(owner(), refund);
        emit Revoked();
    }

    function releasableAmount(ERC20Basic token) internal view returns (uint256) {
        // Implement your logic to calculate the releasable amount here
        return 0; // Placeholder, replace with actual implementation
    }
}","[{'function': 'safeTransfer', 'complexity': 0}, {'function': 'revoke', 'complexity': 3}, {'function': 'releasableAmount', 'complexity': 0}]",3.0,{},"[{'function': 'safeTransfer', 'complexity': 0}, {'function': 'revoke', 'complexity': 3}, {'function': 'releasableAmount', 'complexity': 0}]",3.0,"contract Vesting {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function revokeVesting() public onlyOwner {
        // Additional logic can be added here
    }
}",1.738298416137695,revokeVesting,"[{'function': 'revokeVesting', 'complexity': 0}]",1.0,57.0,0.6987713485852926,0.0032593213010457,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Vesting is Ownable {
    address public owner;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner can call this function"");
        _;
    }

    function revokeVesting() public onlyOwner {
        // Additional logic can be added here
    }
}"
4864,Function to send multiple token transfers in one tx,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Multisender is Ownable {
    using SafeMath for uint256;

    uint256 public constant multiSendLimit = 100; // Example limit, adjust as needed

    function multisend(address[] memory _recipients, uint256[] memory _balances) public onlyOwner {
        require(_recipients.length == _balances.length, ""not equal length"");
        require(_recipients.length <= multiSendLimit, ""more than limit"");

        for (uint256 i = 0; i < _balances.length; i++) {
            require(address(this).balance >= _balances[i], ""insufficient balance"");
            payable(_recipients[i]).transfer(_balances[i]);
        }
    }
}","[{'function': 'multisend', 'complexity': 4}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferMultiple"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""to"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""amount"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""to""}, ""memberName"": ""length""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Arrays must be of equal length""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""to""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""to""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""value"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""amount""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1e18"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid transfer amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""value""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'multisend', 'complexity': 4}]",5.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract TokenTransfer {
    using SafeMath for uint256;

    function transferMultiple(address[] memory to, uint256[] memory amount) public {
        require(to.length == amount.length, ""Arrays must be of equal length"");

        for (uint256 i = 0; i < to.length; i++) {
            address recipient = to[i];
            uint256 value = amount[i].mul(1e18); // Convert amount to wei
            require(value > 0, ""Invalid transfer amount"");
            _transfer(recipient, value);
        }
    }
}",3.298922777175904,transferMultiple,"[{'function': 'transferMultiple', 'complexity': 3}]",4.0,33.0,0.6800689225656462,0.2704517339956895,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract TokenTransfer is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables here
    }

    function transferMultiple(address[] memory to, uint256[] memory amount) public {
        require(to.length == amount.length, ""Arrays must be of equal length"");

        for (uint256 i = 0; i < to.length; i++) {
            address recipient = to[i];
            uint256 value = amount[i].mul(1e18); // Convert amount to wei
            require(value > 0, ""Invalid transfer amount"");
            _transfer(recipient, value);
        }
    }
}"
5466,The user sends Ether to the pool .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function() public payable {
        deposit(msg.sender);
    }

    function deposit(address user) internal {
        // Your logic here
    }
}","[{'function': '', 'complexity': 0}, {'function': 'deposit', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""deposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect amount sent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': '', 'complexity': 0}, {'function': 'deposit', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Pool {
    using SafeMath for uint256;

    function deposit(uint256 amount) public payable {
        require(msg.value == amount, ""Incorrect amount sent"");
        address(this).transfer(amount);
    }
}",1.447946548461914,deposit,"[{'function': 'deposit', 'complexity': 1}]",2.0,12.0,0.6834986613358918,0.1317213082746384,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Pool is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender;
        address _owner = msg.sender;
        bool _initialized = true;
        bytes32 _initBytes = bytes32('init');
        string memory _tokenName = 'MyToken';
    }

    function deposit(uint256 amount) public payable {
        require(msg.value == amount, ""Incorrect amount sent"");
        address(this).transfer(amount);
    }
}"
906,Create group Can be called only by contract owner,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract GroupManager is Ownable {
    using SafeMath for uint256;

    event GroupCreated(bytes32 indexed groupName);

    struct Group {
        bytes32 name;
        uint priority;
        uint index;
    }

    mapping(bytes32 => uint) public groupName2index;
    mapping(uint => bytes32) public index2groupName;
    mapping(bytes32 => Group) public groupName2group;
    uint public groupsCount;

    function createGroup(bytes32 _groupName, uint _priority) external onlyOwner returns (uint) {
        require(_groupName != bytes32(0));
        if (isGroupExists(_groupName)) {
            return _emitError(USER_MANAGER_GROUP_ALREADY_EXIST);
        }
        uint _groupsCount = groupsCount.add(1);
        groupName2index[_groupName] = _groupsCount;
        index2groupName[_groupsCount] = _groupName;
        groupName2group[_groupName] = Group(_groupName, _priority, _groupsCount);
        groupsCount = _groupsCount;
        emit GroupCreated(_groupName);
        return OK;
    }

    function isGroupExists(bytes32 _groupName) internal view returns (bool) {
        return groupName2index[_groupName] != 0;
    }

    function _emitError(uint _errorCode) internal pure returns (uint) {
        revert(""Error: ""); // This should be replaced with the actual error handling logic.
    }
}","[{'function': 'createGroup', 'complexity': 2}, {'function': 'isGroupExists', 'complexity': 0}, {'function': '_emitError', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""createGroup"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""maxMembers"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Group""}, ""name"": ""group"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Group""}}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""name""}, {""type"": ""Identifier"", ""name"": ""maxMembers""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""members""}, ""index"": {""type"": ""Identifier"", ""name"": ""group""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'createGroup', 'complexity': 2}, {'function': 'isGroupExists', 'complexity': 0}, {'function': '_emitError', 'complexity': 0}]",3.0,"
pragma solidity ^0.8.0;
contract Group {
    address public owner;
    mapping(address => bool) public members;

    constructor() public {
        owner = msg.sender;
    }

    function createGroup(string memory name, uint256 maxMembers) public {
        require(msg.sender == owner);
        Group group = new Group(name, maxMembers);
        members[group] = true;
    }
}",2.00629997253418,createGroup,"[{'function': 'createGroup', 'complexity': 1}]",2.0,43.0,0.649157838946146,0.0189101881467451,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Group is Ownable {
    address public owner;
    mapping(address => bool) public members;

    constructor(string memory name, uint256 maxMembers) Ownable(msg.sender) {
        owner = msg.sender;
    }

    function createGroup(string memory name, uint256 maxMembers) public {
        require(msg.sender == owner);
        Group group = new Group(name, maxMembers);
        members[address(group)] = true;
    }
}"
1722,Allow users to buy tokens for ` newTokenSaleHardCap ` XCR,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenSale {
    using SafeMath for uint256;

    uint256 public tokenSaleHardCap;
    address private authorizedAddress;

    constructor(uint256 initialTokenSaleHardCap) {
        tokenSaleHardCap = initialTokenSaleHardCap;
        authorizedAddress = msg.sender;
    }

    modifier onlyAuthorized() {
        require(msg.sender == authorizedAddress, ""Only authorized address can call this function"");
        _;
    }

    function setTokenSaleHardCap(uint256 newTokenSaleHardCap) public onlyAuthorized {
        tokenSaleHardCap = newTokenSaleHardCap;
    }
}","[{'function': 'setTokenSaleHardCap', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount sent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""newTokenSaleHardCap""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""numTokens"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""tokenContract"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenContractAddress""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""tokenContract""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""numTokens""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'setTokenSaleHardCap', 'complexity': 0}]",1.0,"example of a Solidity smart contract function that allows users to buy tokens for a hard cap amount:
```
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract TokenSale {
    using SafeMath for uint256;

    // Define the hard cap amount of tokens that can be bought in this sale
    uint256 public newTokenSaleHardCap = 1000000;

    // Define the token contract address
    address public tokenContractAddress;

    constructor(address _tokenContractAddress) {
        tokenContractAddress = _tokenContractAddress;
    }

    function buyTokens() external payable {
        require(msg.value > 0, ""Invalid amount sent"");
        require(newTokenSaleHardCap >= msg.value, ""Insufficient balance"");

        // Calculate the number of tokens to be minted
        uint256 numTokens = msg.value.div(10**18);

        // Mint the tokens and transfer them to the buyer's address
        IERC20 tokenContract = IERC20(tokenContractAddress);
        tokenContract.mint(msg.sender, numTokens);
    }
}",7.690316438674927,buyTokens,"[{'function': 'buyTokens', 'complexity': 2}]",3.0,38.0,0.5034905492072108,0.0042426577851335,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/interfaces/IERC20.sol"";

contract TokenSale is Ownable {
    using SafeMath for uint256;

    // Define the hard cap amount of tokens that can be bought in this sale
    uint256 public newTokenSaleHardCap = 1000000;

    // Define the token contract address
    address public tokenContractAddress;

    constructor(address _tokenContractAddress) Ownable(msg.sender) {
        tokenContractAddress = _tokenContractAddress;
    }

    function buyTokens() external payable {
        require(msg.value > 0, ""Invalid amount sent"");
        require(newTokenSaleHardCap >= msg.value, ""Insufficient balance"");

        // Calculate the number of tokens to be minted
        uint256 numTokens = msg.value.div(10**18);

        // Mint the tokens and transfer them to the buyer's address
        IERC20 tokenContract = IERC20(tokenContractAddress);
        tokenContract.mint(msg.sender, numTokens);
    }
}"
3988,Pause sale just in case we have some troubles Note that time marks are not updated,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract {
    using SafeMath for uint256;

    enum CampaignState { Initial, Active, Paused }
    CampaignState public campaignState;
    bool public paused;

    event CampaignPaused(uint timestamp);

    address public controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only controller can call this function"");
        _;
    }

    constructor() {
        campaignState = CampaignState.Active;
        paused = false;
        controller = msg.sender;
    }

    function pauseSale() public onlyController {
        require(campaignState == CampaignState.Active, ""Campaign must be active to pause"");
        paused = true;
        campaignState = CampaignState.Paused;
        emit CampaignPaused(block.timestamp);
    }
}","[{'function': 'pauseSale', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pauseSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_paused"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""Identifier"", ""name"": ""_paused""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'pauseSale', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract Sale {
    bool public paused = false;

    modifier whenNotPaused() {
        require(!paused, ""Sale is currently paused"");
        _;
    }

    function pauseSale(bool _paused) external onlyOwner {
        paused = _paused;
    }
}",1.6126794815063477,pauseSale,"[{'function': 'pauseSale', 'complexity': 0}]",1.0,20.0,0.8127567507443233,0.0216207554692802,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Sale is Ownable {
    bool public paused = false;

    modifier whenNotPaused() {
        require(!paused, ""Sale is currently paused"");
        _;
    }

    function pauseSale(bool _paused) external onlyOwner {
        paused = _paused;
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        paused = false;
    }
}"
4761,update the price based on the remaining count of resources,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public initialSellPrice;
    uint256 public initialBuyPrice;
    uint256 public initialSupply;
    uint256 public totalSupply;

    constructor(uint256 _initialSellPrice, uint256 _initialBuyPrice, uint256 _initialSupply) {
        initialSellPrice = _initialSellPrice;
        initialBuyPrice = _initialBuyPrice;
        initialSupply = _initialSupply;
    }

    function updatePrice() public onlyOwner {
        sellPrice = initialSellPrice.mul(initialSupply).div(totalSupply);
        buyPrice = initialBuyPrice.mul(initialSupply).div(totalSupply);
    }
}","[{'function': 'updatePrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""updatePrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""resourceCount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""price"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""price""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""resourceCount""}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': 'updatePrice', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract ResourcePriceUpdater {
    using SafeMath for uint256;

    function updatePrice(uint256 resourceCount, uint256 price) public pure returns (uint256) {
        return price.mul(resourceCount).div(100);
    }
}",1.7748212814331057,updatePrice,"[{'function': 'updatePrice', 'complexity': 0}]",1.0,20.0,0.6415945944809869,0.0832148060659828,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming Ownable is imported correctly

contract ResourcePriceUpdater is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        resourceCount = 1;
        price = 1;
    }

    uint256 public resourceCount;
    uint256 public price;

    function updatePrice(uint256 _resourceCount, uint256 _price) public pure returns (uint256) {
        return _price.mul(_resourceCount).div(100);
    }
}"
609,Checks that a given kitten is able to breed ( i.e .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract DogBreeding {
    using SafeMath for uint256;

    struct Dog {
        // Define the structure of a dog here
    }

    mapping(uint256 => Dog) public dogs;

    function isReadyToBreed(uint256 _dogId) public view returns (bool) {
        require(_dogId > 1);
        Dog storage dog = dogs[_dogId];
        return _isReadyToBreed(dog);
    }

    function _isReadyToBreed(Dog storage dog) internal view returns (bool) {
        // Implement the logic to check if a dog is ready to breed here
        // This is just a placeholder for your actual implementation
        return true;
    }
}","[{'function': 'isReadyToBreed', 'complexity': 1}, {'function': '_isReadyToBreed', 'complexity': 0}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""canBreed"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Kitten""}, ""name"": ""kitten"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""kitten""}, ""memberName"": ""age""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""kitten""}, ""memberName"": ""breed""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, ""right"": {""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""kitten""}, ""memberName"": ""isMale""}, ""isPrefix"": True}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'isReadyToBreed', 'complexity': 1}, {'function': '_isReadyToBreed', 'complexity': 0}]",8.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract KittenBreeding {
    using SafeMath for uint256;

    struct Kitten {
        string name;
        uint256 age;
        uint256 breed;
        bool isMale;
    }

    mapping(uint256 => Kitten) public kittens;

    function canBreed(Kitten memory kitten) external view returns (bool) {
        return kitten.age >= 1 && kitten.breed != 0 && !kitten.isMale;
    }
}",2.86395525932312,canBreed,"[{'function': 'canBreed', 'complexity': 0}]",3.0,16.0,0.5345514752149674,0.1667843233605379,"pragma solidity ^0.8.0;

import ""./Ownable.sol""; // Assuming Ownable is imported correctly
import ""openzeppelin/SafeMath.sol"";
contract KittenBreeding is Ownable {
    using SafeMath for uint256;

    struct Kitten {
        string name;
        uint256 age;
        uint256 breed;
        bool isMale;
    }

    mapping(uint256 => Kitten) public kittens;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            kittens[i].name = 'Kitten';
            kittens[i].age = 1;
            kittens[i].breed = 1;
            kittens[i].isMale = true; // Assuming all initial kittens are male for simplicity
        }
    }

    function canBreed(Kitten memory kitten) external view returns (bool) {
        return kitten.age >= 1 && kitten.breed != 0 && !kitten.isMale;
    }
}"
4790,Approve the passed address to spend the specified amount of tokens on behalf of msg.sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MyToken is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public name = ""My Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    constructor(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
        totalSupply = initialSupply;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        require(0 == value || 0 == allowance(msg.sender, spender));
        allowance[msg.sender][spender] = value;
        return true;
    }
}","[{'function': 'approve', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    function approve(address _spender, uint256 _amount) public {
        require(_spender != address(0), ""Invalid spender"");
        require(_amount > 0, ""Invalid amount"");

        // Additional logic can be added here to check if the sender has enough balance

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        allowances[msg.sender][_spender] = _amount;
    }
}",3.305572271347046,approve,"[{'function': 'approve', 'complexity': 2}]",3.0,26.0,0.8043175917675794,0.0844053710572021,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance to 1 (never 0)
        allowances[msg.sender][address(this)] = 1; // Allowance for contract itself
    }

    function approve(address _spender, uint256 _amount) public {
        require(_spender != address(0), ""Invalid spender"");
        require(_amount > 0, ""Invalid amount"");

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        allowances[msg.sender][_spender] = _amount;
    }
}"
4695,A participant 's contribution will be rejected if the Private Sale has been funded to the maximum amount,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PrivateSale {
    using SafeMath for uint256;

    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 1 ether;
    uint256 public constant PRIVATESALE_START_DATE = 1672502400; // Example start date, replace with actual value
    uint256 public constant PRIVATESALE_END_DATE = 1675180800;   // Example end date, replace with actual value

    mapping(address => uint256) private balances;

    function addBalance() public payable {
        require(now >= PRIVATESALE_START_DATE && now <= PRIVATESALE_END_DATE, ""Private sale period not active"");
        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT, ""Minimum participation amount not met"");
        balances[msg.sender] = balances[msg.sender].add(msg.value);
    }
}","[{'function': 'addBalance', 'complexity': 3}]",4.0,{},"[{'function': 'addBalance', 'complexity': 3}]",4.0,"
contract PrivateSale {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public participants;
    uint256 public maxAmount;
    uint256 public totalContributions;

    constructor() public {
        owner = msg.sender;
        maxAmount = 1000000000000000000000000; // 1 billion wei
        totalContributions = 0;
    }

    function contribute() public payable {
        require(participants[msg.sender] == false, ""Participant has already contributed"");
        require(totalContributions < maxAmount, ""Private Sale is fully funded"");

        participants[msg.sender] = true;
        totalContributions = totalContributions.add(msg.value);
    }
}",3.912150859832764,contribute,"[{'function': 'contribute', 'complexity': 2}]",3.0,36.0,0.6965466379671618,0.2868396222698809,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PrivateSale is Ownable {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public participants;
    uint256 public maxAmount;
    uint256 public totalContributions;

    constructor() Ownable(msg.sender) public {
        owner = msg.sender;
        maxAmount = 1000000000000000000000000; // 1 billion wei
        totalContributions = 0;
    }

    function contribute() public payable {
        require(participants[msg.sender] == false, ""Participant has already contributed"");
        require(totalContributions < maxAmount, ""Private Sale is fully funded"");

        participants[msg.sender] = true;
        totalContributions = totalContributions.add(msg.value);
    }
}"
2989,Get a description of the validator at account ` validator ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ValidatorWrapper is Ownable {
    using SafeMath for uint256;

    function getValidatorInformation(address validator) external view returns (string memory description) {
        // Your formatting logic goes here
        return ""Your formatting logic should be placed here."";
    }
}","[{'function': 'getValidatorInformation', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getValidatorDescription"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_validator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Name: ""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_validator""}}, ""memberName"": ""name""}, {""type"": ""stringLiteral"", ""value"": ""\\nWebsite: ""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_validator""}}, ""memberName"": ""website""}, {""type"": ""stringLiteral"", ""value"": ""\\nContact Email: ""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""validators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_validator""}}, ""memberName"": ""contactEmail""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getValidatorInformation', 'complexity': 0}]",3.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Validator {
    using SafeMath for uint256;

    struct ValidatorInfo {
        address validatorAddress;
        string name;
        string website;
        string contactEmail;
        bool isActive;
        uint256 lastUpdatedTime;
    }

    mapping(address => ValidatorInfo) public validators;

    function getValidatorDescription(address _validator) public view returns (string memory) {
        return string(abi.encodePacked(""Name: "", validators[_validator].name, ""\nWebsite: "", validators[_validator].website, ""\nContact Email: "", validators[_validator].contactEmail));
    }
}",3.339513063430786,getValidatorDescription,"[{'function': 'getValidatorDescription', 'complexity': 0}]",1.0,19.0,0.8190468058296931,0.1177981446735037,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is from OpenZeppelin for proper initialization

contract Validator is Ownable {
    using SafeMath for uint256;

    struct ValidatorInfo {
        address validatorAddress;
        string name;
        string website;
        string contactEmail;
        bool isActive;
        uint256 lastUpdatedTime;
    }

    mapping(address => ValidatorInfo) public validators;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            validators[addr] = ValidatorInfo({
                validatorAddress: addr,
                name: ""ValidatorName"",
                website: ""http://validator.com"",
                contactEmail: ""contact@validator.com"",
                isActive: true,
                lastUpdatedTime: block.timestamp
            });
        }
    }

    function getValidatorDescription(address _validator) public view returns (string memory) {
        ValidatorInfo storage info = validators[_validator];
        return string(abi.encodePacked(""Name: "", info.name, ""\nWebsite: "", info.website, ""\nContact Email: "", info.contactEmail));
    }
}"
4597,Returns how many pixels has been already set .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasStorage {
    using SafeMath for uint256;

    struct Canvas {
        uint32 paintedPixelsCount;
    }

    mapping(uint32 => Canvas) private canvases;

    function _getCanvas(uint32 _canvasId) internal view returns (Canvas storage) {
        return canvases[_canvasId];
    }
}

abstract contract CanvasManager is Ownable, CanvasStorage {
    using SafeMath for uint256;

    function getCanvasPaintedPixelsCount(uint32 _canvasId) public view returns (uint32) {
        return _getCanvas(_canvasId).paintedPixelsCount;
    }
}","[{'function': '_getCanvas', 'complexity': 0}, {'function': 'getCanvasPaintedPixelsCount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getPixelCount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pixelCount""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': '_getCanvas', 'complexity': 0}, {'function': 'getCanvasPaintedPixelsCount', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract PixelCounter {
    using SafeMath for uint256;

    mapping(address => uint256) public pixelCount;

    function getPixelCount() public view returns (uint256) {
        return pixelCount[msg.sender];
    }
}",1.504915714263916,getPixelCount,"[{'function': 'getPixelCount', 'complexity': 0}]",1.0,4.0,0.3861732173913396,0.1090305150570067,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PixelCounter is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public pixelCount;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        pixelCount[owner()] = 1; // Use owner address and set initial count to 1
    }

    function getPixelCount() public view returns (uint256) {
        return pixelCount[msg.sender];
    }
}"
1962,Get value for Uint associated with bytes32 id key,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract StorageWrapper is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => uint256) private uIntStorage;

    function getUint(bytes32 _key) public view returns (uint256 _value) {
        return uIntStorage[_key];
    }
}","[{'function': 'getUint', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getValueForId"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint""}, ""name"": ""value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_idToValue""}, ""index"": {""type"": ""Identifier"", ""name"": ""id""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getUint', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint;

    mapping(bytes32 => uint) private _idToValue;

    function getValueForId(bytes32 id) public view returns (uint value) {
        return _idToValue[id];
    }
}",1.683112621307373,getValueForId,"[{'function': 'getValueForId', 'complexity': 0}]",1.0,0.0,0.6301726792509166,0.329340597116918,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is how you import OpenZeppelin contracts

contract MyContract is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => uint) private _idToValue;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _idToValue[bytes32('init')] = 1; // Use bytes32('init') instead of 'init' for consistency
    }

    function getValueForId(bytes32 id) public view returns (uint value) {
        return _idToValue[id];
    }
}"
629,"Calculate the vested and unclaimed months and tokens available for ` _grantId ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IGrant {
    function tokenGrants(uint256 _grantId) external view returns (Grant memory);
}

struct Grant {
    uint256 amount;
    uint256 startTime;
    uint256 vestingCliff;
    uint256 vestingDuration;
    uint256 totalClaimed;
    uint256 daysClaimed;
}

abstract contract GrantCalculator {
    using SafeMath for uint256;

    IGrant public grantContract;

    constructor(address _grantAddress) {
        grantContract = IGrant(_grantAddress);
    }

    function currentTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    function calculateGrantClaim(uint256 _grantId) public view returns (uint256, uint256) {
        Grant memory tokenGrant = grantContract.tokenGrants(_grantId);
        if (currentTime() < tokenGrant.startTime) {
            return (0, 0);
        }
        uint256 elapsedTime = currentTime().sub(tokenGrant.startTime);
        uint256 elapsedDays = elapsedTime.div(SECONDS_PER_DAY);
        if (elapsedDays < tokenGrant.vestingCliff) {
            return (elapsedDays, 0);
        }
        if (elapsedDays >= tokenGrant.vestingDuration) {
            uint256 remainingGrant = tokenGrant.amount.sub(tokenGrant.totalClaimed);
            return (tokenGrant.vestingDuration, remainingGrant);
        } else {
            uint256 daysVested = elapsedDays.sub(tokenGrant.daysClaimed);
            uint256 amountVestedPerDay = tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));
            uint256 amountVested = uint256(daysVested.mul(amountVestedPerDay));
            return (daysVested, amountVested);
        }
    }
}","[{'function': 'tokenGrants', 'complexity': 0}, {'function': 'currentTime', 'complexity': 0}, {'function': 'calculateGrantClaim', 'complexity': 3}]",5.0,{},"[{'function': 'tokenGrants', 'complexity': 0}, {'function': 'currentTime', 'complexity': 0}, {'function': 'calculateGrantClaim', 'complexity': 3}]",5.0,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract GrantVesting {
    using SafeMath for uint256;

    struct Grant {
        address grantor;
        address grantee;
        uint256 amount;
        uint256 duration; // in months
        uint256 cliff; // in months
        uint256 startDate; // in seconds since the Unix epoch
    }

    mapping(uint256 => Grant) public grants;

    function getVestedAndUnclaimedMonthsAndTokens(uint256 _grantId) external view returns (uint256, uint256) {
        Grant memory grant = grants[_grantId];
        if (block.timestamp < grant.startDate + grant.cliff * 30 days) {
            return (0, 0);
        }
        uint256 vestedMonths = SafeMath.div(SafeMath.mul(block.timestamp - grant.startDate, 1 months), 30 days);
        uint256 unclaimedMonths = SafeMath.sub(grant.duration, vestedMonths);
        if (vestedMonths >= grant.duration) {
            return (grant.amount, 0);
        }
        return (SafeMath.mul(grant.amount, vestedMonths), SafeMath.mul(grant.amount, unclaimedMonths));
    }
}",6.942201614379883,getVestedAndUnclaimedMonthsAndTokens,"[{'function': 'getVestedAndUnclaimedMonthsAndTokens', 'complexity': 2}]",4.0,81.0,0.7626065868982732,0.2401545195520523,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract GrantVesting is Ownable {
    using SafeMath for uint256;

    struct Grant {
        address grantor;
        address grantee;
        uint256 amount;
        uint256 duration; // in months
        uint256 cliff; // in months
        uint256 startDate; // in seconds since the Unix epoch
    }

    mapping(uint256 => Grant) public grants;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe values as per the rules provided
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function getVestedAndUnclaimedMonthsAndTokens(uint256 _grantId) external view returns (uint256, uint256) {
        Grant memory grant = grants[_grantId];
        if (block.timestamp < grant.startDate + grant.cliff * 30 days) {
            return (0, 0);
        }
        uint256 vestedMonths = SafeMath.div(SafeMath.mul(block.timestamp - grant.startDate, 1 months), 30 days);
        uint256 unclaimedMonths = SafeMath.sub(grant.duration, vestedMonths);
        if (vestedMonths >= grant.duration) {
            return (grant.amount, 0);
        }
        return (SafeMath.mul(grant.amount, vestedMonths), SafeMath.mul(grant.amount, unclaimedMonths));
    }
}"
4567,Called by the ModuleFactory owner to register new modules for SecurityTokens to use,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IFeatureRegistry {
    function getFeatureStatus(string memory feature) external view returns (bool);
}

interface IOwnable {
    function owner() external view returns (address);
}

interface IModuleFactory {
    function getTypes() external pure returns (uint8[] memory);
}

abstract contract ModuleRegistry is Ownable {
    using SafeMath for uint256;

    mapping(bytes32 => mapping(address => uint256)) private registry;
    mapping(uint256 => address[]) private moduleList;

    event ModuleRegistered(address indexed moduleFactory, address owner);

    function getAddress(bytes32 key) internal pure returns (address addr) {
        assembly {
            addr := shr(96, calldataload(add(key, 0x20)))
        }
    }

    function getUint(bytes32 key) internal pure returns (uint256 value) {
        assembly {
            value := calldataload(add(key, 0x20))
        }
    }

    function set(bytes32 key, uint256 value) internal {
        bytes memory data = abi.encodePacked(value);
        for (uint256 i = 0; i < data.length; i++) {
            assembly {
                mstore8(add(key, add(0x20, i)), data[i])
            }
        }
    }

    function getArrayAddress(bytes32 key) internal pure returns (address[] memory array) {
        assembly {
            array := calldataload(add(key, 0x20))
        }
    }

    function pushArray(bytes32 key, address value) internal {
        uint256 length;
        assembly {
            length := sload(key)
            sstore(add(key, 0x20), add(length, 1))
            mstore(0, value)
            sstore(add(key, mul(length, 32)), value)
        }
    }

    function registerModule(address _moduleFactory) external whenNotPausedOrOwner {
        if (IFeatureRegistry(getAddress(Encoder.getKey(""featureRegistry""))).getFeatureStatus(""customModulesAllowed"")) {
            require(msg.sender == IOwnable(_moduleFactory).owner() || msg.sender == owner(), ""msg.sender must be the Module Factory owner or registry curator"");
        } else {
            require(msg.sender == owner(), ""Only owner allowed to register modules"");
        }
        require(getUint(Encoder.getKey(""registry"", _moduleFactory)) == 0, ""Module factory should not be pre-registered"");
        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);
        uint256 i;
        uint256 j;
        uint8[] memory moduleTypes = moduleFactory.getTypes();
        for (i = 1; i < moduleTypes.length; i++) {
            for (j = 0; j < i; j++) {
                require(moduleTypes[i] != moduleTypes[j], ""Type mismatch"");
            }
        }
        require(moduleTypes.length != 0, ""Factory must have type"");
        uint8 moduleType = moduleFactory.getTypes()[0];
        set(Encoder.getKey(""registry"", _moduleFactory), uint256(moduleType));
        set(Encoder.getKey(""moduleListIndex"", _moduleFactory), uint256(getArrayAddress(Encoder.getKey(""moduleList"", uint256(moduleType))).length));
        pushArray(Encoder.getKey(""moduleList"", uint256(moduleType)), _moduleFactory);
        emit ModuleRegistered(_moduleFactory, IOwnable(_moduleFactory).owner());
    }
}","[{'function': 'getFeatureStatus', 'complexity': 0}, {'function': 'owner', 'complexity': 0}, {'function': 'getTypes', 'complexity': 0}, {'function': 'getAddress', 'complexity': 0}, {'function': 'getUint', 'complexity': 0}, {'function': 'set', 'complexity': 1}, {'function': 'getArrayAddress', 'complexity': 0}, {'function': 'pushArray', 'complexity': 0}, {'function': 'registerModule', 'complexity': 10}]",15.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerModule"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_moduleAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid module address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""UnaryOperation"", ""operator"": ""!"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isModuleRegistered""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleAddress""}}, ""isPrefix"": True}, {""type"": ""stringLiteral"", ""value"": ""Module already registered""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""isModuleRegistered""}, ""index"": {""type"": ""Identifier"", ""name"": ""_moduleAddress""}}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getFeatureStatus', 'complexity': 0}, {'function': 'owner', 'complexity': 0}, {'function': 'getTypes', 'complexity': 0}, {'function': 'getAddress', 'complexity': 0}, {'function': 'getUint', 'complexity': 0}, {'function': 'set', 'complexity': 1}, {'function': 'getArrayAddress', 'complexity': 0}, {'function': 'pushArray', 'complexity': 0}, {'function': 'registerModule', 'complexity': 10}]",15.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeMath.sol"";

contract ModuleFactory {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public isModuleRegistered;

    constructor() public {
        owner = msg.sender;
    }

    function registerModule(address _moduleAddress) external onlyOwner {
        require(_moduleAddress != address(0), ""Invalid module address"");
        require(!isModuleRegistered[_moduleAddress], ""Module already registered"");

        isModuleRegistered[_moduleAddress] = true;
    }
}",4.180632591247559,registerModule,"[{'function': 'registerModule', 'complexity': 3}]",3.0,36.0,0.7696620378210839,0.000476248299882,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    address public owner;
    mapping(address => bool) public isModuleRegistered;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function registerModule(address _moduleAddress) external onlyOwner {
        require(_moduleAddress != address(0), ""Invalid module address"");
        require(!isModuleRegistered[_moduleAddress], ""Module already registered"");

        isModuleRegistered[_moduleAddress] = true;
    }
}"
2433,Total hash rate of a miner in a halving,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Miner {
    using SafeMath for uint256;
    mapping(uint256 => MinerHashRate) public hashRate;
}

abstract contract MinerWrapper is Ownable {
    using SafeMath for uint256;
    struct MinerHashRate {
        uint256 rate;
        bool carried;
    }

    mapping(address => Miner) public miners;

    function getMinerHalving() public pure returns (uint256) {
        // This should be implemented in the actual contract.
        return 0; // Placeholder for actual implementation.
    }

    function getMinerHalvingHashRateOf(address _miner) public view returns (uint256) {
        require(block.number >= block.timestamp, ""Not before genesis"");
        Miner miner = miners[_miner];
        uint256 halving = getMinerHalving();
        MinerHashRate memory hashRate = miner.hashRate[halving];
        if (halving == 0) {
            return hashRate.rate;
        } else {
            if (!hashRate.carried) {
                return hashRate.rate.add(miner.hashRate[halving - 1].rate);
            } else {
                return hashRate.rate;
            }
        }
    }
}","[{'function': 'getMinerHalving', 'complexity': 0}, {'function': 'getMinerHalvingHashRateOf', 'complexity': 6}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalHashRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Halving""}, ""name"": ""halving"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""halving""}, ""memberName"": ""totalHashRate""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getMinerHalving', 'complexity': 0}, {'function': 'getMinerHalvingHashRateOf', 'complexity': 6}]",5.0,"
pragma solidity ^0.8.0;

contract Miner {
    using SafeMath for uint256;

    struct Halving {
        uint256 totalHashRate;
    }

    function getTotalHashRate(Halving memory halving) public view returns (uint256) {
        return halving.totalHashRate;
    }
}",1.701121807098389,getTotalHashRate,"[{'function': 'getTotalHashRate', 'complexity': 0}]",1.0,38.0,0.6966076547026334,0.0189892298010046,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Miner is Ownable {
    using SafeMath for uint256;

    struct Halving {
        uint256 totalHashRate;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        halving = Halving({totalHashRate: 1});
    }

    Halving public halving;

    function getTotalHashRate(Halving memory h) public pure returns (uint256) {
        return h.totalHashRate;
    }
}"
915,"Get the budget avaliable of a campaign Based on the Campaign id , return the total value avaliable to pay for proofs of attention .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Campaign {
    function getBudget() external view returns (uint);
}

abstract contract CampaignRegistry is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => address) public campaigns;

    function setCampaign(bytes32 bidId, address campaignAddress) public onlyOwner {
        campaigns[bidId] = campaignAddress;
    }

    function getCampaignBudgetById(bytes32 bidId) public view returns (uint budget) {
        return Campaign(campaigns[bidId]).getBudget();
    }
}","[{'function': 'getBudget', 'complexity': 0}, {'function': 'setCampaign', 'complexity': 0}, {'function': 'getCampaignBudgetById', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAvailableBudget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""campaignId"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Campaign""}, ""name"": ""campaign"", ""storageLocation"": ""storage""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""campaigns""}, ""index"": {""type"": ""Identifier"", ""name"": ""campaignId""}}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""campaign""}, ""memberName"": ""totalBudget""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""campaign""}, ""memberName"": ""proofOfAttention""}, ""index"": {""type"": ""Identifier"", ""name"": ""campaignId""}}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getBudget', 'complexity': 0}, {'function': 'setCampaign', 'complexity': 0}, {'function': 'getCampaignBudgetById', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract AttentionCampaign {
    using SafeMath for uint256;

    struct Campaign {
        string id;
        uint256 totalBudget;
        mapping(string => uint256) proofOfAttention;
    }

    function getAvailableBudget(string memory campaignId) public view returns (uint256) {
        Campaign storage campaign = campaigns[campaignId];
        return campaign.totalBudget.sub(campaign.proofOfAttention[campaignId]);
    }
}",2.653841018676758,getAvailableBudget,"[{'function': 'getAvailableBudget', 'complexity': 0}]",1.0,16.0,0.5252993313466072,0.0210165488415618,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AttentionCampaign is Ownable {
    using SafeMath for uint256;

    struct Campaign {
        string id;
        uint256 totalBudget;
        mapping(string => uint256) proofOfAttention;
    }

    mapping(string => Campaign) public campaigns;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        for (uint i = 1; i <= 3; i++) {
            campaigns[string(abi.encodePacked(""campaign"", uint2str(i)))] = Campaign({
                id: string(abi.encodePacked(""campaign"", uint2str(i))),
                totalBudget: 1 ether * i // Set to 1 ether multiplied by the index (safe, non-zero value)
            });
        }
    }

    function getAvailableBudget(string memory campaignId) public view returns (uint256) {
        Campaign storage campaign = campaigns[campaignId];
        return campaign.totalBudget.sub(campaign.proofOfAttention[campaignId]);
    }

    // Helper function to convert uint to string for campaign IDs
    function uint2str(uint _i) internal pure returns (string memory str) {
        if (_i == 0) {
            return ""0"";
        }
        uint j = _i;
        uint length;
        while (j != 0) {
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint k = length;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }
}"
2907,Sets the ICO Contract Address variable to be used with the ` onlyIcoContract ` modifier .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => bool) public freezeBypassing;
    address public icoContractAddress;

    function setIcoContractAddress(address contractAddress) public onlyOwner {
    freezeBypassing[contractAddress] = true;
    icoContractAddress = contractAddress;
}
}","[{'function': 'setIcoContractAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setIcoContractAddress"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_icoContractAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""icoContractAddress""}, ""right"": {""type"": ""Identifier"", ""name"": ""_icoContractAddress""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setIcoContractAddress', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract MyContract {
    address public icoContractAddress;

    function setIcoContractAddress(address _icoContractAddress) public {
        icoContractAddress = _icoContractAddress;
    }
}",1.1296663284301758,setIcoContractAddress,"[{'function': 'setIcoContractAddress', 'complexity': 0}]",1.0,7.0,0.8352272440648155,0.2170356430885741,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public icoContractAddress;

    constructor() Ownable(msg.sender) {
        icoContractAddress = address(1); // 0x1111111111111111111111111111111111111111
    }

    function setIcoContractAddress(address _icoContractAddress) public {
        require(_icoContractAddress != address(0), ""Invalid address"");
        icoContractAddress = _icoContractAddress;
    }
}"
5542,Enables the owner of a parcel to update the data field,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface LandInterface {
    function decodeTokenId(uint256 tokenId) external pure returns (int256 x, int256 y);
    function updateLandData(int256 x, int256 y, string memory data) external;
}

abstract contract LandWrapper is Ownable {
    using SafeMath for uint256;

    struct Mortgage {
        uint256 landId;
    }

    mapping(uint256 => Mortgage) public mortgages;
    LandInterface public land;

    event UpdatedLandData(address indexed sender, uint256 id, string data);

    constructor(address _landAddress) {
        land = LandInterface(_landAddress);
    }

    function updateLandData(uint256 id, string memory data) external onlyOwner returns (bool) {
        require(_isAuthorized(msg.sender, id), ""Sender not authorized"");
        (int256 x, int256 y) = land.decodeTokenId(mortgages[id].landId);
        land.updateLandData(x, y, data);
        emit UpdatedLandData(msg.sender, id, data);
        return true;
    }

    function _isAuthorized(address sender, uint256 id) internal view returns (bool) {
        // Implement your authorization logic here
        return owner() == sender || mortgages[id].landId != 0;
    }
}","[{'function': 'updateLandData', 'complexity': 0}, {'function': 'updateLandData', 'complexity': 1}, {'function': '_isAuthorized', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateData"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""newData"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can update data""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""data""}, ""right"": {""type"": ""Identifier"", ""name"": ""newData""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updateLandData', 'complexity': 0}, {'function': 'updateLandData', 'complexity': 1}, {'function': '_isAuthorized', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

contract Parcel {
    address public owner;
    string public data;

    constructor(address _owner, string memory _data) public {
        owner = _owner;
        data = _data;
    }

    function updateData(string memory newData) public {
        require(msg.sender == owner, ""Only the owner can update data"");
        data = newData;
    }
}",2.00736665725708,updateData,"[{'function': 'updateData', 'complexity': 1}]",2.0,32.0,0.6111492057563194,0.0153224768398292,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Parcel is Ownable {
    address public owner;
    string public data;

    constructor() public Ownable(msg.sender) {
        owner = msg.sender;
        data = 'initialized';
    }

    function updateData(string memory newData) public {
        require(msg.sender == owner, ""Only the owner can update data"");
        data = newData;
    }
}"
6660,"Set the `` approved taker '' for your deed , or revoke approval by setting the zero address .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function approve(address _to, uint256 _deedId) external payable {
        // Function body
    }
}","[{'function': 'approve', 'complexity': 0}]",1.0,{},"[{'function': 'approve', 'complexity': 0}]",1.0,"contract DeedApproval {
    address public owner;
    mapping(address => bool) public approvedTakers;

    constructor() public {
        owner = msg.sender;
    }

    function setApprovedTaker(address taker, bool approve) public {
        require(msg.sender == owner);
        approvedTakers[taker] = approve;
    }
}",1.726266622543335,setApprovedTaker,"[{'function': 'setApprovedTaker', 'complexity': 1}]",2.0,0.0,0.5959703832602667,0.0259816126471483,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DeedApproval is Ownable {
    mapping(address => bool) public approvedTakers;

    constructor() Ownable(msg.sender) {
        // No need to initialize owner here as it's done in the parent constructor
    }

    function setApprovedTaker(address taker, bool approve) public onlyOwner {
        approvedTakers[taker] = approve;
    }
}"
2749,"Set budget for ` _token.symbol ( ) : string ` to ` @ tokenAmount ( _token , _amount , false ) ` , effective immediately","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract BudgetSetter is Ownable {
    using SafeMath for uint256;

    struct Settings {
        mapping(address => uint256) budgets;
        mapping(address => bool) hasBudget;
    }

    Settings private settings;

    event SetBudget(address indexed token, uint256 amount, bool indexed success);

    modifier authP(bytes32 role, bytes memory data) {
        require(hasRole(role, msg.sender), ""Unauthorized"");
        _;
    }

    function setBudget(address _token, uint256 _amount) external authP(keccak256(""CHANGE_BUDGETS_ROLE""), abi.encodePacked(_token, _amount, settings.budgets[_token], settings.hasBudget[_token] ? 1 : 0)) {
        require(_amount > 0, ""Amount must be greater than zero"");

        if (!settings.hasBudget[_token]) {
            settings.hasBudget[_token] = true;
        }

        settings.budgets[_token] = _amount;
        emit SetBudget(_token, _amount, true);
    }
}","[{'function': 'setBudget', 'complexity': 4}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setBudget"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_tokenSymbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenSymbol""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setBudget', 'complexity': 4}]",3.0,"
pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract BudgetSetter {
    using SafeMath for uint256;

    function setBudget(string memory _tokenSymbol, uint256 _amount) public {
        IERC20 token = IERC20(_tokenSymbol);
        require(token.balanceOf(msg.sender) >= _amount, ""Not enough balance"");
        token.transferFrom(msg.sender, address(this), _amount);
    }
}",3.2239930629730225,setBudget,"[{'function': 'setBudget', 'complexity': 1}]",2.0,37.0,0.8425022635001046,0.0823194579311984,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract BudgetSetter is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setBudget(string memory _tokenSymbol, uint256 _amount) public {
        IERC20 token = IERC20(_tokenSymbol);
        require(token.balanceOf(msg.sender) >= _amount, ""Not enough balance"");
        token.transferFrom(msg.sender, address(this), _amount);
    }
}"
5294,"Only to be used when this contract is significantly broken , and an upgrade is required .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    address public upgradedContractAddress;

    event ContractUpgrade(address indexed newContractAddress);

    function setUpgradedContractAddress(address _upgradedContractAddress) external onlyOwner whenPaused {
        upgradedContractAddress = _upgradedContractAddress;
        emit ContractUpgrade(_upgradedContractAddress);
    }
}","[{'function': 'setUpgradedContractAddress', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""upgrade"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newVersion"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newVersion""}, ""right"": {""type"": ""Identifier"", ""name"": ""version""}}, {""type"": ""stringLiteral"", ""value"": ""New version must be greater than current version""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""version""}, ""right"": {""type"": ""Identifier"", ""name"": ""newVersion""}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setUpgradedContractAddress', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract Upgradeable {
    address public owner;
    uint256 public version;

    constructor() public {
        owner = msg.sender;
        version = 1;
    }

    function upgrade(uint256 newVersion) external onlyOwner {
        require(newVersion > version, ""New version must be greater than current version"");
        version = newVersion;
    }
}",2.0082757472991943,upgrade,"[{'function': 'upgrade', 'complexity': 1}]",2.0,6.0,0.5526900349359442,0.0490518283258345,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Upgradeable {
    address public owner;
    uint256 public version;

    constructor() {
        owner = msg.sender;
        version = 1;
    }

    function upgrade(uint256 newVersion) external onlyOwner {
        require(newVersion > version, ""New version must be greater than current version"");
        version = newVersion;
    }
}"
598,Send ` _value ` tokens to ` _to ` from your account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public onlyOwner {
        require(now > 1508840297);
        _transfer(msg.sender, _to, _value);
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        // Implementation of the transfer logic
    }
}","[{'function': 'transfer', 'complexity': 1}, {'function': '_transfer', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_to""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 1}, {'function': '_transfer', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function sendTokens(address _to, uint256 _value) public {
        require(_to != address(0), ""Invalid recipient"");
        require(_value > 0, ""Invalid value"");

        // Transfer tokens from the sender's account to the recipient's account
        uint256 balance = SafeMath.sub(address(this).balance, _value);
        address(this).transfer(_to, _value);
    }
}",2.841984510421753,sendTokens,"[{'function': 'sendTokens', 'complexity': 2}]",3.0,25.0,0.678331210327131,0.1899533004117997,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is for Ownable contract

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balance = 1; // uint256: Set to 1 (never 0)
        ownerAddress = address(this); // address: Use fixed value 0x1111111111111111111111111111111111111111
        isInitialized = true; // bool: Set to true
        tokenName = 'initialized'; // string: Set to 'initialized'
        tokenSymbol = bytes32('init'); // bytes32: Set to bytes32('init')
    }

    uint256 public balance;
    address public ownerAddress;
    bool public isInitialized;
    string public tokenName;
    bytes32 public tokenSymbol;

    function sendTokens(address _to, uint256 _value) public {
        require(_to != address(0), ""Invalid recipient"");
        require(_value > 0, ""Invalid value"");

        // Transfer tokens from the sender's account to the recipient's account
        uint256 balance = SafeMath.sub(address(this).balance, _value);
        address(this).transfer(_to, _value);
    }
}"
2600,This function will set the conversion rate .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint public rateMe;

    function setRate(uint _rateMe) public onlyOwner {
        rateMe = _rateMe;
    }
}","[{'function': 'setRate', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setConversionRate"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_conversionRate"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_conversionRate""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid conversion rate""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""conversionRate""}, ""right"": {""type"": ""Identifier"", ""name"": ""_conversionRate""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setRate', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract ConversionRate {
    using SafeMath for uint256;

    // Function to set the conversion rate
    function setConversionRate(uint256 _conversionRate) public {
        require(_conversionRate > 0, ""Invalid conversion rate"");
        conversionRate = _conversionRate;
    }
}",1.861611604690552,setConversionRate,"[{'function': 'setConversionRate', 'complexity': 1}]",2.0,8.0,0.7135972105731024,0.0239565656127602,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract ConversionRate is Ownable {
    using SafeMath for uint256;

    uint256 public conversionRate = 1;

    constructor() Ownable(msg.sender) {
        // No need to initialize conversionRate as it's already initialized in the state variable declaration
    }

    // Function to set the conversion rate
    function setConversionRate(uint256 _conversionRate) public {
        require(_conversionRate > 0, ""Invalid conversion rate"");
        conversionRate = _conversionRate;
    }
}"
2777,Calls approve on the token and reverts if the call fails .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface CompatibleERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

abstract contract SafeApproveWrapper is Ownable {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 amount) internal {
        CompatibleERC20(token).approve(spender, amount);
        require(previousReturnValue(), ""approve failed"");
    }

    function previousReturnValue() private pure returns (bool) {
        // This is a placeholder for the actual logic to check if the approve call succeeded.
        // In practice, this would involve checking the return value of the approve function.
        // For simplicity, we assume it always succeeds in this example.
        return true;
    }
}","[{'function': 'approve', 'complexity': 0}, {'function': 'safeApprove', 'complexity': 1}, {'function': 'previousReturnValue', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""spender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Approval failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 0}, {'function': 'safeApprove', 'complexity': 1}, {'function': 'previousReturnValue', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function approveToken(address spender, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        IERC20 token = IERC20(msg.sender);
        require(token.approve(spender, amount), ""Approval failed"");
    }
}",2.135855197906494,approveToken,"[{'function': 'approveToken', 'complexity': 2}]",3.0,16.0,0.4092056079071953,0.005361323651611,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists
// import ""IERC20.sol""; // If IERC20 interface is used, include it here

contract MyContract is Ownable {
    using SafeMath for uint256;

    function approveToken(address spender, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        // Assuming IERC20 token = IERC20(msg.sender); is correct usage
        IERC20 token = IERC20(msg.sender);
        require(token.approve(spender, amount), ""Approval failed"");
    }

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        uint256 safeUint = 1;
        address safeAddress = address(uint160(uint256(keccak256('a'))));
        bool safeBool = true;
        string memory initializedString = 'initialized';
        bytes32 safeBytes32 = bytes32('init');
    }
}"
2639,"The total SNX owned by this account , both escrowed and unescrowed , against which synths can be issued .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract CollateralWrapper {
    using SafeMath for uint256;

    address public tokenState;
    address public escrow;

    constructor(address _tokenState, address _escrow) {
        tokenState = _tokenState;
        escrow = _escrow;
    }

    function collateral(address account) public view returns (uint256) {
        uint256 balance = ITokenState(tokenState).balanceOf(account);
        if (escrow != address(0)) {
            balance = balance.add(IEscrow(escrow).balanceOf(account));
        }
        return balance;
    }
}","[{'function': 'collateral', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""issueSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalSnx"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""account""}, ""memberName"": ""snxEscrowed""}, ""arguments"": [], ""names"": []}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""account""}, ""memberName"": ""snxUnescrowed""}, ""arguments"": [], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSnx""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient SNX balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Synth""}, ""name"": ""synth"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""NewExpression"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Synth""}}, ""arguments"": [], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""synth""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""totalSupply""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'collateral', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

contract SynthIssuance {
    using SafeMath for uint256;

    function issueSynth(address account, uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");

        // Get the total SNX owned by this account
        uint256 totalSnx = SafeMath.add(account.snxEscrowed(), account.snxUnescrowed());

        // Check that the total amount of SNX is sufficient to issue the synths
        require(totalSnx >= amount, ""Insufficient SNX balance"");

        // Issue the synths and update the total supply
        Synth synth = new Synth();
        synth.mint(amount);
        totalSupply = SafeMath.add(totalSupply, amount);
    }
}",3.8964478969573975,issueSynth,"[{'function': 'issueSynth', 'complexity': 2}]",3.0,41.0,0.4197800030952893,0.0276647856471855,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract SynthIssuance is Ownable {
    using SafeMath for uint256;

    function issueSynth(address account, uint256 amount) public {
        require(amount > 0, ""Amount must be greater than zero"");

        // Get the total SNX owned by this account
        uint256 totalSnx = SafeMath.add(account.snxEscrowed(), account.snxUnescrowed());

        // Check that the total amount of SNX is sufficient to issue the synths
        require(totalSnx >= amount, ""Insufficient SNX balance"");

        // Issue the synths and update the total supply
        Synth synth = new Synth();
        synth.mint(amount);
        totalSupply = SafeMath.add(totalSupply, amount);
    }
}"
4569,Returns all the relevant information about a specific whale .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WhaleMarketplace is Ownable {
    using SafeMath for uint256;

    struct Whale {
        string name;
    }

    mapping(uint256 => Whale) public whales;
    mapping(uint256 => uint256) public whaleIndexToPrice;
    mapping(uint256 => address) public whaleIndexToOwner;

    function getWhale(uint256 _tokenId) public view returns (uint256 Id, string memory whaleName, uint256 sellingPrice, address owner) {
        Whale storage whale = whales[_tokenId];
        Id = _tokenId;
        whaleName = whale.name;
        sellingPrice = whaleIndexToPrice[_tokenId];
        owner = whaleIndexToOwner[_tokenId];
    }
}","[{'function': 'getWhale', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getWhaleInfo"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_id"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""WhaleInfo""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""whales""}, ""index"": {""type"": ""Identifier"", ""name"": ""_id""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getWhale', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Whale {
    struct WhaleInfo {
        uint256 id;
        string name;
        string species;
        uint256 length;
        uint256 weight;
        string location;
        string description;
    }

    mapping(uint256 => WhaleInfo) public whales;

    function getWhaleInfo(uint256 _id) public view returns (WhaleInfo memory) {
        return whales[_id];
    }
}",2.3550448417663574,getWhaleInfo,"[{'function': 'getWhaleInfo', 'complexity': 0}]",1.0,31.0,0.760486682315434,0.0677650138259385,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Whale is Ownable {
    struct WhaleInfo {
        uint256 id;
        string name;
        string species;
        uint256 length;
        uint256 weight;
        string location;
        string description;
    }

    mapping(uint256 => WhaleInfo) public whales;

    constructor() Ownable(msg.sender) {
        // Initialize all instance variables to fixed, safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            whales[i] = WhaleInfo({
                id: i,
                name: ""Whale"",
                species: ""Blue Whale"",
                length: 70, // in meters
                weight: 180, // in tons
                location: ""Pacific Ocean"",
                description: ""A large whale found in the Pacific.""
            });
        }
    }

    function getWhaleInfo(uint256 _id) public view returns (WhaleInfo memory) {
        return whales[_id];
    }
}"
3314,deliberately authorized the sender of the message via some mechanism,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SCComplianceService {
    function validate(address _from, address _to, uint256 _amount) external view returns (bool);
}

abstract contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowed;
    bool public stopInEmergency = false;

    SCComplianceService public complianceService;

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    constructor(uint256 initialSupply) {
        balances[msg.sender] = initialSupply;
    }

    function setComplianceService(address _complianceService) public onlyOwner {
        complianceService = SCComplianceService(_complianceService);
    }

    function transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {
        if (balances[_from] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the token balance of the source');
        }

        if (allowed[_from][msg.sender] < _amount) {
            revert('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');
        }

        if (!complianceService.validate(_from, _to, _amount)) {
            revert('transferFrom: not allowed by the compliance service');
        }

        balances[_from] = balances[_from].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        emit Transfer(_from, _to, _amount);

        return true;
    }

    function setStopInEmergency(bool _stop) public onlyOwner {
        stopInEmergency = _stop;
    }
}","[{'function': 'validate', 'complexity': 0}, {'function': 'setComplianceService', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 4}, {'function': 'setStopInEmergency', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendMessage"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_message"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""_sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""MessageSent""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_message""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'validate', 'complexity': 0}, {'function': 'setComplianceService', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 4}, {'function': 'setStopInEmergency', 'complexity': 0}]",4.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function sendMessage(address _sender, string memory _message) public {
        require(_sender == msg.sender);
        emit MessageSent(_message, block.timestamp);
    }
}",3.2813808917999268,sendMessage,"[{'function': 'sendMessage', 'complexity': 1}]",2.0,67.0,0.3623711020061363,0.0016704391515015,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        _owner = msg.sender; // Ensure the owner is set correctly
    }

    function sendMessage(address _sender, string memory _message) public {
        require(_sender == msg.sender);
        emit MessageSent(_message, block.timestamp);
    }
}"
3619,Get the tags related to the module factory,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TagProvider {
    using SafeMath for uint256;

    function getTags() public view returns (bytes32[] memory) {
        bytes32[] memory availableTags = new bytes32[](2);
        availableTags[0] = ""Count"";
        availableTags[1] = ""Transfer Restriction"";
        return availableTags;
    }
}","[{'function': 'getTags', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTags"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_moduleAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""length"": None}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Module""}, ""name"": ""module"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Module""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_moduleAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""length"": None}, ""name"": ""tags"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""module""}, ""memberName"": ""getTags""}, ""arguments"": [], ""names"": []}}, {""type"": ""Identifier"", ""name"": ""tags""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getTags', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC20/SafeMath.sol"";

contract ModuleFactory {
    using SafeMath for uint256;

    function getTags(address _moduleAddress) public view returns (string[] memory) {
        // Get the module at the given address
        Module module = Module(_moduleAddress);

        // Get the tags associated with the module
        string[] memory tags = module.getTags();

        return tags;
    }
}",2.569654703140259,getTags,"[{'function': 'getTags', 'complexity': 0}]",1.0,20.0,0.7124654488421459,0.1390321210974696,"pragma solidity ^0.8.0;

import ""openzeppelin-solidity/contracts/token/ERC20/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract ModuleFactory is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // No state variables to initialize in this contract
    }

    function getTags(address _moduleAddress) public view returns (string[] memory) {
        Module module = Module(_moduleAddress);
        return module.getTags();
    }
}"
3235,Invoke ` onERC721Received ` on a target address ( not executed if the target address is not a contract ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC721Receiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);
}

abstract contract ERC721Wrapper is Ownable {
    using SafeMath for uint256;

    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) internal returns (bool) {
        if (!_to.isContract()) return true;
        bytes4 retval = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
        return (retval == 0x150b7a02); // ERC721_RECEIVED is the keccak-256 hash of ""onERC721Received(address,address,uint256,bytes)""
    }
}","[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'checkAndCallSafeTransfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""onERC721Received"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""data"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes4""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0x150b7a02"", ""subdenomination"": None}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onERC721Received', 'complexity': 0}, {'function': 'checkAndCallSafeTransfer', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeMath.sol"";

contract MyContract is IERC721Receiver {
    using Address for address;
    using SafeMath for uint256;

    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external override returns (bytes4) {
        // Additional logic can be added here
        return 0x150b7a02;
    }
}",4.500776767730713,onERC721Received,"[{'function': 'onERC721Received', 'complexity': 0}]",1.0,21.0,0.5802440569877335,0.0093484848705434,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is IERC721Receiver, Ownable {
    using Address for address;
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _owner = msg.sender;
        someUint = 1;
        someAddress = address(uint160(uint256(keccak256('address1'))));
        someBool = true;
        someString = 'initialized';
        someBytes32 = bytes32('init');
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external override returns (bytes4) {
        // Additional logic can be added here
        return 0x150b7a02;
    }
}"
4896,Set whether prices can be changed manually .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public allowChangePrice;

    function setAllowChangePrice(bool _allowChangePrice) external onlyCFO {
        allowChangePrice = _allowChangePrice;
    }
}","[{'function': 'setAllowChangePrice', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setPriceManualOverride"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_priceManualOverride"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can change the price manual override setting""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""priceManualOverride""}, ""right"": {""type"": ""Identifier"", ""name"": ""_priceManualOverride""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setAllowChangePrice', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract PriceControl {
    bool public priceManualOverride;

    constructor() {
        priceManualOverride = false;
    }

    function setPriceManualOverride(bool _priceManualOverride) external {
        require(msg.sender == owner, ""Only the contract owner can change the price manual override setting"");
        priceManualOverride = _priceManualOverride;
    }
}",1.9187662601470947,setPriceManualOverride,"[{'function': 'setPriceManualOverride', 'complexity': 1}]",2.0,9.0,0.660640914338115,0.0214545915655746,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PriceControl is Ownable {
    bool public priceManualOverride;

    constructor() Ownable(msg.sender) {
        priceManualOverride = false;
    }

    function setPriceManualOverride(bool _priceManualOverride) external onlyOwner {
        require(msg.sender == owner, ""Only the contract owner can change the price manual override setting"");
        priceManualOverride = _priceManualOverride;
    }
}"
5609,Updates registration status for multiple addresses for participation,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    function changeRegistrationStatus(address target, bool isRegistered) public onlyOwner {
        // Implementation of changing registration status
    }

    function changeRegistrationStatuses(address[] memory targets, bool isRegistered) public onlyOwner {
        for (uint i = 0; i < targets.length; i++) {
            changeRegistrationStatus(targets[i], isRegistered);
        }
    }
}","[{'function': 'changeRegistrationStatus', 'complexity': 0}, {'function': 'changeRegistrationStatuses', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""updateRegistrationStatus"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""length"": None}, ""name"": ""_addrs"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_registered"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Addresses array cannot be empty""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""memberName"": ""addr""}, ""right"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""addresses""}, ""index"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""_addrs""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, ""memberName"": ""registered""}, ""right"": {""type"": ""Identifier"", ""name"": ""_registered""}}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changeRegistrationStatus', 'complexity': 0}, {'function': 'changeRegistrationStatuses', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract Registration {
    using SafeMath for uint256;

    struct Address {
        address addr;
        bool registered;
    }

    mapping(address => Address) public addresses;

    function updateRegistrationStatus(address[] memory _addrs, bool _registered) public {
        require(_addrs.length > 0, ""Addresses array cannot be empty"");

        for (uint256 i = 0; i < _addrs.length; i++) {
            addresses[_addrs[i]].addr = _addrs[i];
            addresses[_addrs[i]].registered = _registered;
        }
    }
}",3.4282712936401367,updateRegistrationStatus,"[{'function': 'updateRegistrationStatus', 'complexity': 2}]",3.0,23.0,0.6706671693815913,0.173630136306663,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract Registration is Ownable {
    using SafeMath for uint256;

    struct Address {
        address addr;
        bool registered;
    }

    mapping(address => Address) public addresses;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            addresses[address(uint160(i << 160))] = Address({addr: address(uint160(i << 160)), registered: true});
        }
    }

    function updateRegistrationStatus(address[] memory _addrs, bool _registered) public {
        require(_addrs.length > 0, ""Addresses array cannot be empty"");

        for (uint256 i = 0; i < _addrs.length; i++) {
            addresses[_addrs[i]].addr = _addrs[i];
            addresses[_addrs[i]].registered = _registered;
        }
    }
}"
3896,Allows the owner to destroy a beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract BeneficiaryManager is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    IERC20 public token;
    mapping(address => Beneficiary) public beneficiaries;
    address[] public addresses;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _token, address[] memory initialBeneficiaries) {
        token = IERC20(_token);
        for (uint i = 0; i < initialBeneficiaries.length; i++) {
            beneficiaries[initialBeneficiaries[i]] = Beneficiary({isBeneficiary: true, vested: 0, released: 0});
        }
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(beneficiaries[_beneficiary].isBeneficiary, ""Beneficiary does not exist"");
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        token.transfer(owner(), balance);
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        for (uint i = 0; i < addresses.length - 1; i++) {
            if (addresses[i] == _beneficiary) {
                addresses[i] = addresses[addresses.length - 1];
                break;
            }
        }
        addresses.pop();
        emit BeneficiaryDestroyed(_beneficiary);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'destroyBeneficiary', 'complexity': 5}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""destroyBeneficiary"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid beneficiary""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""beneficiaries""}, ""index"": {""type"": ""Identifier"", ""name"": ""_beneficiary""}}, ""isPrefix"": True}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'destroyBeneficiary', 'complexity': 5}]",5.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract DestroyBeneficiary {
    using SafeMath for uint256;

    address private owner;
    mapping(address => bool) private beneficiaries;

    constructor() public {
        owner = msg.sender;
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(_beneficiary != address(0), ""Invalid beneficiary"");
        delete beneficiaries[_beneficiary];
    }
}",2.6215052604675293,destroyBeneficiary,"[{'function': 'destroyBeneficiary', 'complexity': 1}]",2.0,74.0,0.919371788382942,0.0265333468012591,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from

contract DestroyBeneficiary is Ownable {
    using SafeMath for uint256;

    address private owner;
    mapping(address => bool) private beneficiaries;

    constructor() Ownable(msg.sender) {
        owner = msg.sender;
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        require(_beneficiary != address(0), ""Invalid beneficiary"");
        delete beneficiaries[_beneficiary];
    }
}"
2053,Create ` msg.value ` ETH worth of GMT,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint256 public tokenExchangeRate = 1000; // Example rate, adjust as needed
    uint256 public totalSupply = 1000000 * (10 ** 18); // Example total supply, adjust as needed
    uint256 public assignedSupply;
    uint256 public gmtFund;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public purchases;

    event ClaimGMT(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function isWithinCap(uint256 tokens) internal view returns (bool) {
        return assignedSupply.add(tokens) <= totalSupply;
    }

    function claimTokens() public payable {
        require(msg.value > 0, ""Value must be greater than zero"");
        uint256 tokens = msg.value.mul(tokenExchangeRate);
        require(isWithinCap(tokens), ""Claim exceeds the token cap"");
        uint256 checkedSupply = assignedSupply.add(tokens);
        require(checkedSupply.add(gmtFund) <= totalSupply, ""Total supply would be exceeded"");
        balances[msg.sender] = balances[msg.sender].add(tokens);
        purchases[msg.sender] = purchases[msg.sender].add(tokens);
        assignedSupply = checkedSupply;
        emit ClaimGMT(msg.sender, tokens);
        emit Transfer(address(0), msg.sender, tokens);
    }
}","[{'function': 'isWithinCap', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient ETH""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isWithinCap', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract GMT is IERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;

    function mint(uint256 amount) public {
        require(msg.value >= amount, ""Insufficient ETH"");
        _mint(msg.sender, amount);
    }
}",3.554166793823242,mint,"[{'function': 'mint', 'complexity': 1}]",2.0,73.0,0.4494005175014723,0.0095036389616365,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract GMT is IERC20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        _balances[owner()] = 1; // Set balance to 1 for the owner
    }

    function mint(uint256 amount) public payable {
        require(msg.value >= amount, ""Insufficient ETH"");
        _mint(msg.sender, amount);
    }
}"
306,How many HEAL tokens do this contract have,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface EthealToken {
    function balanceOf(address account) external view returns (uint256);
}

interface EthealController {
    function ethealToken() external view returns (EthealToken);
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    EthealController public ethealController;

    constructor(address _ethealController) {
        require(_ethealController != address(0), ""Invalid controller address"");
        ethealController = EthealController(_ethealController);
    }

    function getHealBalance() view public returns (uint256) {
        return ethealController.ethealToken().balanceOf(address(this));
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'ethealToken', 'complexity': 0}, {'function': 'getHealBalance', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getTotalSupply"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""index"": {""type"": ""Identifier"", ""name"": ""_owner""}}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'ethealToken', 'complexity': 0}, {'function': 'getHealBalance', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

    function getTotalSupply() public view returns (uint256) {
        return balanceOf[msg.sender].add(balanceOf[_owner]);
    }
}",1.6455438137054443,getTotalSupply,"[{'function': 'getTotalSupply', 'complexity': 0}]",1.0,4.0,0.5427346085420678,0.2835111423723787,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set initial balance for owner
    }

    function getTotalSupply() public view returns (uint256) {
        return balanceOf[msg.sender].add(balanceOf[_owner]);
    }
}"
3644,"Pledges fees to the token holders , later to be claimed by burning","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeFeesWrapper {
    using SafeMath for uint256;

    uint public totalPledgedFees;
    mapping(uint => uint) public totalPledgedFeesHistory;
    address private controller;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor() {
        controller = msg.sender;
    }

    function pledgeFees(uint _value) public onlyController returns (bool) {
        uint curTotalFees = totalPledgedFees();
        require(curTotalFees + _value >= curTotalFees, ""SafeMath: addition overflow"");
        updateValueAtNow(totalPledgedFeesHistory, curTotalFees.add(_value));
        return true;
    }

    function totalPledgedFees() public view returns (uint) {
        return totalPledgedFees;
    }

    function updateValueAtNow(mapping(uint => uint) storage _map, uint _value) internal {
        totalPledgedFees = _value;
    }
}","[{'function': 'pledgeFees', 'complexity': 1}, {'function': 'totalPledgedFees', 'complexity': 0}, {'function': 'updateValueAtNow', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""pledgeFees"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""_amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Pledge""}, ""name"": ""newPledge"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Pledge""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": [""owner"", ""amount""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""pledges""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""newPledge""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'pledgeFees', 'complexity': 1}, {'function': 'totalPledgedFees', 'complexity': 0}, {'function': 'updateValueAtNow', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

contract Token {
    using SafeMath for uint256;

    struct Pledge {
        address owner;
        uint256 amount;
    }

    mapping(address => Pledge) public pledges;

    function pledgeFees(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(msg.sender.balance >= _amount, ""Insufficient balance"");

        Pledge memory newPledge = Pledge({owner: msg.sender, amount: _amount});
        pledges[msg.sender] = newPledge;
    }
}",3.140106678009033,pledgeFees,"[{'function': 'pledgeFees', 'complexity': 2}]",3.0,26.0,0.7480524257035515,0.089003031439704,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Token is Ownable {
    using SafeMath for uint256;

    struct Pledge {
        address owner;
        uint256 amount;
    }

    mapping(address => Pledge) public pledges;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function pledgeFees(uint256 _amount) external {
        require(_amount > 0, ""Amount must be greater than zero"");
        require(msg.sender.balance >= _amount, ""Insufficient balance"");

        Pledge memory newPledge = Pledge({owner: msg.sender, amount: _amount});
        pledges[msg.sender] = newPledge;
    }
}"
6330,Helper function that calculates the valuation of the asset in terms of an ART token quantity .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    uint256 public oracle_price_decimals_factor = 10**18; // Example factor, adjust as needed
    uint256 public decimal_precission_difference_factor = 10**18; // Example factor, adjust as needed

    function convert_valuation_to_art(uint256 _valuation, uint256 _art_price) public view returns (uint256 amount) {
        amount = ((_valuation.mul(oracle_price_decimals_factor)).div(_art_price)).mul(decimal_precission_difference_factor);
    }

    function announceFork(string memory name, string memory url, uint256 blockNumber) public onlyOwner {
        require(blockNumber == 0 || blockNumber > block.number);
        _nextForkName = name;
        _nextForkUrl = url;
        _nextForkBlockNumber = blockNumber;
        emit LogForkAnnounced(_nextForkName, _nextForkUrl, _nextForkBlockNumber);
    }
}","[{'function': 'convert_valuation_to_art', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,{},"[{'function': 'convert_valuation_to_art', 'complexity': 0}, {'function': 'announceFork', 'complexity': 2}]",3.0,"
contract AssetValuation {
    using SafeMath for uint256;

    function calculateAssetValuation(uint256 _assetValue, uint256 _artTokenSupply) public view returns (uint256) {
        return _assetValue.mul(_artTokenSupply).div(10**18);
    }
}",1.595573663711548,calculateAssetValuation,"[{'function': 'calculateAssetValuation', 'complexity': 0}]",1.0,39.0,0.1811165766238447,0.0272329161107751,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AssetValuation is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function calculateAssetValuation(uint256 _assetValue, uint256 _artTokenSupply) public pure returns (uint256) {
        return _assetValue.mul(_artTokenSupply).div(10**18);
    }
}"
5296,"Remove a node from the list , and fix the previous and next pointers that are pointing to the removed node .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract List {
    using SafeMath for uint256;

    struct Node {
        address previous;
        address next;
        bool inList;
    }

    mapping(address => Node) public list;

    function isInList(List storage self, address node) internal view returns (bool) {
        return self.list[node].inList;
    }

    function remove(List storage self, address node) internal {
        require(isInList(self, node), ""not in list"");
        if (node == address(0)) {
            return;
        }
        address p = self.list[node].previous;
        address n = self.list[node].next;
        self.list[p].next = n;
        self.list[n].previous = p;
        self.list[node].inList = false;
        delete self.list[node];
    }
}","[{'function': 'isInList', 'complexity': 0}, {'function': 'remove', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""removeNode"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""index"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Index out of bounds""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""lastIndex"", ""storageLocation"": None}], ""initialValue"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""lastIndex""}, ""right"": {""type"": ""Identifier"", ""name"": ""index""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""lastIndex""}}, ""isPrefix"": True}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Node""}, ""name"": ""previousNode"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""-"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Node""}, ""name"": ""nextNode"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""BinaryOperation"", ""operator"": ""+"", ""left"": {""type"": ""Identifier"", ""name"": ""index""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""previousNode""}, ""memberName"": ""next""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nextNode""}, ""memberName"": """"}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""nextNode""}, ""memberName"": ""previous""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""previousNode""}, ""memberName"": """"}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""nodes""}, ""index"": {""type"": ""Identifier"", ""name"": ""index""}}, ""isPrefix"": True}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isInList', 'complexity': 0}, {'function': 'remove', 'complexity': 2}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract List {
    using SafeMath for uint256;

    struct Node {
        uint256 value;
        address next;
        address previous;
    }

    mapping(uint256 => Node) public nodes;

    function removeNode(uint256 index) public {
        require(index < nodes.length, ""Index out of bounds"");

        uint256 lastIndex = nodes.length - 1;

        if (lastIndex == index) {
            delete nodes[lastIndex];
        } else {
            Node memory previousNode = nodes[index - 1];
            Node memory nextNode = nodes[index + 1];

            previousNode.next = nextNode.address;
            nextNode.previous = previousNode.address;

            delete nodes[index];
        }
    }
}",4.126206874847412,removeNode,"[{'function': 'removeNode', 'complexity': 2}]",3.0,42.0,0.6232138329462736,0.0301069647895306,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract List is Ownable {
    using SafeMath for uint256;

    struct Node {
        uint256 value;
        address next;
        address previous;
    }

    mapping(uint256 => Node) public nodes;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function removeNode(uint256 index) public {
        require(index < nodes.length, ""Index out of bounds"");

        uint256 lastIndex = nodes.length - 1;

        if (lastIndex == index) {
            delete nodes[lastIndex];
        } else {
            Node memory previousNode = nodes[index - 1];
            Node memory nextNode = nodes[index + 1];

            previousNode.next = nextNode.address;
            nextNode.previous = previousNode.address;

            delete nodes[index];
        }
    }

    function addNode(uint256 value) public onlyOwner {
        require(value > 0, ""Value must be greater than zero"");

        Node memory newNode = Node({
            value: value,
            next: address(0),
            previous: address(0)
        });

        uint256 lastIndex = nodes.length - 1;

        if (lastIndex == 0) {
            nodes[0] = newNode;
        } else {
            Node memory lastNode = nodes[lastIndex];

            lastNode.next = address(this);
            newNode.previous = address(lastNode);

            nodes[lastIndex + 1] = newNode;
        }

        emit NewNode(value);
    }
}"
1009,Function that registers new synth as they are isseud .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface SynthetixState {
    function incrementTotalIssuerCount() external;
    function setCurrentIssuanceData(address issuer, uint debtPercentage) external;
    function appendDebtLedgerValue(uint value) external;
    function lastDebtLedgerEntry() external view returns (uint);
    function hasIssued(address account) external view returns (bool);
    function debtLedgerLength() external view returns (int);
}

interface Synth {
    function effectiveValue(bytes4 currencyKey, uint amount, bytes32 destinationCurrencyKey) external pure returns (uint);
    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);
}

interface DebtCache {
    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);
}

abstract contract DebtRegisterWrapper is Ownable {
    using SafeMath for uint;
    using SafeDecimalMath for uint;

    SynthetixState public synthetixState;
    Synth public synth;
    DebtCache public debtCache;

    constructor(address _synthetixState, address _synth, address _debtCache) {
        synthetixState = SynthetixState(_synthetixState);
        synth = Synth(_synth);
        debtCache = DebtCache(_debtCache);
    }

    function _addToDebtRegister(bytes4 currencyKey, uint amount) external optionalProxy {
        require(msg.sender == address(this), ""Only callable by this contract"");

        uint xdrValue = synth.effectiveValue(currencyKey, amount, ""XDR"");
        uint totalDebtIssued = synth.totalIssuedSynths(""XDR"");
        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);
        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);
        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);
        uint existingDebt = debtCache.debtBalanceOf(msg.sender, ""XDR"");

        if (existingDebt > 0) {
            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);
        }

        if (!synthetixState.hasIssued(msg.sender)) {
            synthetixState.incrementTotalIssuerCount();
        }

        synthetixState.setCurrentIssuanceData(msg.sender, debtPercentage);

        if (synthetixState.debtLedgerLength() > 0) {
            synthetixState.appendDebtLedgerValue(synthetixState.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));
        } else {
            synthetixState.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());
        }
    }
}","[{'function': 'debtLedgerLength', 'complexity': 0}, {'function': 'totalIssuedSynths', 'complexity': 0}, {'function': 'debtBalanceOf', 'complexity': 0}, {'function': '_addToDebtRegister', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerSynth"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_name"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_supply"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_name""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Name must not be empty""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Owner must not be zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_supply""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Supply must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""synths""}, ""index"": {""type"": ""Identifier"", ""name"": ""_name""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Synth""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_name""}, {""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_supply""}], ""names"": [""name"", ""owner"", ""supply""]}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'debtLedgerLength', 'complexity': 0}, {'function': 'totalIssuedSynths', 'complexity': 0}, {'function': 'debtBalanceOf', 'complexity': 0}, {'function': '_addToDebtRegister', 'complexity': 5}]",6.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract SynthRegistry {
    using SafeMath for uint256;

    struct Synth {
        string name;
        address owner;
        uint256 supply;
    }

    mapping(string => Synth) public synths;

    function registerSynth(string memory _name, address _owner, uint256 _supply) public {
        require(_name.length > 0, ""Name must not be empty"");
        require(_owner != address(0), ""Owner must not be zero address"");
        require(_supply > 0, ""Supply must be greater than zero"");

        synths[_name] = Synth({
            name: _name,
            owner: _owner,
            supply: _supply
        });
    }
}",3.775165557861328,registerSynth,"[{'function': 'registerSynth', 'complexity': 3}]",4.0,79.0,0.528693754601901,0.0146341112390888,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract SynthRegistry is Ownable {
    using SafeMath for uint256;

    struct Synth {
        string name;
        address owner;
        uint256 supply;
    }

    mapping(string => Synth) public synths;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        // uint/uint256: Set to 1 (never 0)
        // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function registerSynth(string memory _name, address _owner, uint256 _supply) public {
        require(_name.length > 0, ""Name must not be empty"");
        require(_owner != address(0), ""Owner must not be zero address"");
        require(_supply > 0, ""Supply must be greater than zero"");

        synths[_name] = Synth({
            name: _name,
            owner: _owner,
            supply: _supply
        });
    }
}"
5740,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContractName {
    using SafeMath for uint256;

    uint256 public sellPrice;
    uint256 public sellMultiplier;
    uint256 public buyPrice;
    uint256 public buyMultiplier;

    constructor() {}

    function setPrices(uint256 newSellPrice, uint256 newSellMultiplier, uint256 newBuyPrice, uint256 newBuyMultiplier) onlyOwner public {
        sellPrice = newSellPrice;
        sellMultiplier = newSellMultiplier;
        buyPrice = newBuyPrice;
        buyMultiplier = newBuyMultiplier;
    }
}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""sellTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""ethAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newSellPrice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""ethAmount""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, ""memberName"": ""balance""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient ETH""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract TokenContract {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public newBuyPrice;
    uint256 public newSellPrice;

    function buyTokens(uint256 amount) external payable {
        require(msg.value >= amount.mul(newBuyPrice), ""Insufficient ETH"");
        token.transferFrom(address(this), msg.sender, amount);
    }

    function sellTokens(uint256 amount) external {
        uint256 ethAmount = amount.mul(newSellPrice);
        require(ethAmount <= address(this).balance, ""Insufficient ETH"");
        token.transferFrom(msg.sender, address(this), amount);
    }
}",5.539993762969971,sellTokens,"[{'function': 'buyTokens', 'complexity': 1}, {'function': 'sellTokens', 'complexity': 1}]",2.0,28.0,0.4727894702234597,0.014187468588792,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenContract is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    uint256 public newBuyPrice;
    uint256 public newSellPrice;

    constructor(address _token, uint256 buyPrice, uint256 sellPrice) Ownable() {
        require(_token != address(0), ""Invalid token address"");
        token = IERC20(_token);
        newBuyPrice = buyPrice;
        newSellPrice = sellPrice;
    }

    function buyTokens(uint256 amount) external payable {
        require(msg.value >= amount.mul(newBuyPrice), ""Insufficient ETH"");
        token.transferFrom(address(this), msg.sender, amount);
    }

    function sellTokens(uint256 amount) external {
        uint256 ethAmount = amount.mul(newSellPrice);
        require(ethAmount <= address(this).balance, ""Insufficient ETH"");
        token.transferFrom(msg.sender, address(this), amount);
    }
}"
4219,This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface AIX {
    function totalSupply() external view returns (uint256);
    function generateTokens(address to, uint256 value) external;
}

abstract contract Finalizable is Ownable {
    using SafeMath for uint256;

    AIX public aix;
    address public remainderHolder;
    address public devHolder;
    address public communityHolder;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public finalizedBlock;
    uint256 public finalizedTime;
    uint256 public constant TOKEN_CAP_MULTIPLIER = 100;
    uint256 public constant TOKEN_DISTRIBUTION_RATIO = 51;

    event Finalized(uint256 indexed blockNumber);

    function finalize() public initialized {
        require(finalizedBlock == 0);
        require(finalizedTime == 0);
        require(getBlockTimestamp() >= startTime);
        require(msg.sender == controller || getBlockTimestamp() > endTime || weiToCollect() == 0);

        aix.generateTokens(remainderHolder, weiToCollect().mul(2000));
        uint256 tokenCap = aix.totalSupply().mul(TOKEN_CAP_MULTIPLIER).div(TOKEN_DISTRIBUTION_RATIO);
        aix.generateTokens(devHolder, tokenCap.mul(20).div(100));
        aix.generateTokens(communityHolder, tokenCap.mul(29).div(100));

        finalizedBlock = getBlockNumber();
        finalizedTime = getBlockTimestamp();

        emit Finalized(finalizedBlock);
    }
}","[{'function': 'generateTokens', 'complexity': 0}, {'function': 'finalize', 'complexity': 5}]",7.0,"{""type"": ""FunctionDefinition"", ""name"": ""contribute"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""endTime""}}, {""type"": ""stringLiteral"", ""value"": ""The contribution period has ended""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'generateTokens', 'complexity': 0}, {'function': 'finalize', 'complexity': 5}]",7.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    address public controller;
    uint256 public endTime;

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    constructor(address _controller) public {
        controller = _controller;
    }

    // This method will be called by the controller before the contribution period end or by anybody after the `endTime` .
    function contribute() external onlyController {
        require(block.timestamp < endTime, ""The contribution period has ended"");
        // Additional logic can be added here to handle the contribution
    }
}",3.5259275436401367,contribute,"[{'function': 'contribute', 'complexity': 1}]",2.0,89.0,0.5018050004568402,0.0026807653563496,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    address public controller;
    uint256 public endTime;
    bool public initialized = true;
    bytes32 public initBytes;

    constructor(address _controller) public {
        require(_controller != address(0), ""Controller cannot be zero"");
        controller = _controller;
        endTime = block.timestamp + 1 minutes; // Set a reasonable end time
        initBytes = bytes32('init');
        initialized = true;
    }

    modifier onlyController() {
        require(msg.sender == controller, ""Only the controller can call this function"");
        _;
    }

    function contribute() external onlyController {
        require(block.timestamp < endTime, ""The contribution period has ended"");
        // Additional logic can be added here to handle the contribution
    }
}"
6178,Checks whether the contract operations is paused or not,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Encoder {
    function getKey(string memory key) external pure returns (bytes32);
}

abstract contract Pausable is Ownable {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private pausedMap;
    Encoder public encoder;

    constructor(address _encoderAddress) {
        encoder = Encoder(_encoderAddress);
    }

    function getBool(bytes32 key) internal view returns (bool) {
        return pausedMap[key];
    }

    function isPaused() public view returns (bool) {
        return getBool(encoder.getKey(""paused""));
    }
}","[{'function': 'getKey', 'complexity': 0}, {'function': 'getBool', 'complexity': 0}, {'function': 'isPaused', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""pause"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""paused""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}, {""type"": ""ModifierInvocation"", ""name"": ""whenNotPaused"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getKey', 'complexity': 0}, {'function': 'getBool', 'complexity': 0}, {'function': 'isPaused', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Pausable {
    bool public paused = false;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function pause() external onlyOwner whenNotPaused {
        paused = true;
    }

    function unpause() external onlyOwner whenNotPaused {
        paused = false;
    }
}",2.005981683731079,pause,"[{'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",1.0,10.0,0.49012379924534,0.0182504494255466,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract Pausable {
    bool public paused = false;

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function pause() external onlyOwner whenNotPaused {
        paused = true;
    }

    function unpause() external onlyOwner whenNotPaused {
        paused = false;
    }
}"
1600,Sets a new converter ramp to delegate the pay of the loan,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ConverterRamp {
    // Define the interface of the ConverterRamp contract here if necessary
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    ConverterRamp public converterRamp;

    event SetConverterRamp(ConverterRamp indexed oldConverterRamp, ConverterRamp indexed newConverterRamp);

    function setConverterRamp(ConverterRamp _converterRamp) external onlyOwner returns (bool) {
        require(_isContract(_converterRamp), ""Should be a contract"");
        emit SetConverterRamp(converterRamp, _converterRamp);
        converterRamp = _converterRamp;
        return true;
    }

    function _isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","[{'function': 'setConverterRamp', 'complexity': 1}, {'function': '_isContract', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""setNewConverterRamp"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""newRamp"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""oldRamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Old ramp must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""newRamp""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""New ramp must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""oldRamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""newRamp""}}, {""type"": ""stringLiteral"", ""value"": ""Old and new ramps cannot be the same""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""oldRampBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldRamp""}, {""type"": ""Identifier"", ""name"": ""newRamp""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""oldRampBalance""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""oldRamp""}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""newRamp""}, {""type"": ""Identifier"", ""name"": ""oldRampBalance""}], ""names"": []}}]}, ""FalseBody"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'setConverterRamp', 'complexity': 1}, {'function': '_isContract', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract ConverterRamp {
    using SafeMath for uint256;

    function setNewConverterRamp(uint256 oldRamp, uint256 newRamp) public {
        require(oldRamp > 0, ""Old ramp must be greater than zero"");
        require(newRamp > 0, ""New ramp must be greater than zero"");
        require(oldRamp != newRamp, ""Old and new ramps cannot be the same"");

        uint256 oldRampBalance = SafeMath.sub(oldRamp, newRamp);
        if (oldRampBalance > 0) {
            // Transfer tokens from old ramp to new ramp
            IERC20(oldRamp).transferFrom(msg.sender, newRamp, oldRampBalance);
        }
    }
}",4.680715799331665,setNewConverterRamp,"[{'function': 'setNewConverterRamp', 'complexity': 4}]",5.0,26.0,0.715259875174298,0.0184290028808245,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol"";

contract ConverterRamp is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialization of state variables
        oldRamp = 1;
        newRamp = 2;
    }

    uint256 public oldRamp;
    uint256 public newRamp;

    function setNewConverterRamp(uint256 oldRamp, uint256 newRamp) public {
        require(oldRamp > 0, ""Old ramp must be greater than zero"");
        require(newRamp > 0, ""New ramp must be greater than zero"");
        require(oldRamp != newRamp, ""Old and new ramps cannot be the same"");

        uint256 oldRampBalance = SafeMath.sub(oldRamp, newRamp);
        if (oldRampBalance > 0) {
            // Transfer tokens from old ramp to new ramp
            IERC20(address(oldRamp)).transferFrom(msg.sender, address(newRamp), oldRampBalance);
        }
    }
}"
4079,Get the token spender allowance for a given account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
}

abstract contract TokenAllowanceWrapper is Ownable {
    using SafeMath for uint256;

    struct Data {
        mapping(bytes32 => uint256) Storage;
    }

    function getTokenAllowance(Data storage self, string memory currency, address account, address spender) internal view returns (uint256 allowance) {
        bytes32 id = keccak256(abi.encodePacked('token.allowance', currency, _getForwardedAccount(self, account), _getForwardedAccount(self, spender)));
        return self.Storage[id];
    }

    function _getForwardedAccount(Data storage self, address account) private view returns (address) {
        // Implement any forwarding logic here if necessary
        return account;
    }
}","[{'function': 'allowance', 'complexity': 0}, {'function': 'getTokenAllowance', 'complexity': 0}, {'function': '_getForwardedAccount', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getSpenderAllowance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_account"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""Identifier"", ""name"": ""_account""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'allowance', 'complexity': 0}, {'function': 'getTokenAllowance', 'complexity': 0}, {'function': '_getForwardedAccount', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function getSpenderAllowance(address _account, address _spender) public view returns (uint256) {
        return allowances[_account][_spender];
    }
}",1.6656835079193115,getSpenderAllowance,"[{'function': 'getSpenderAllowance', 'complexity': 0}]",1.0,23.0,0.7388745718992841,0.0296148475412062,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is where Ownable is imported from OpenZeppelin

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender; // Assuming 'owner' is the state variable representing the contract owner
        someUint = 1; // uint/uint256: Set to 1 (never 0)
        someAddress = address(uint160(uint256(keccak256('someAddress')) % 2**160)); // address: Use these fixed values in order
        someBool = true; // bool: Set to true
        someString = 'initialized'; // string: Set to 'initialized'
        someBytes32 = bytes32('init'); // bytes32: Set to bytes32('init')
    }

    function getSpenderAllowance(address _account, address _spender) public view returns (uint256) {
        return allowances[_account][_spender];
    }

    uint256 private someUint;
    address private someAddress;
    bool private someBool;
    string private someString;
    bytes32 private someBytes32;
    mapping(address => mapping(address => uint256)) public allowances;
}"
5836,amount of tokens minted ( NOT equal to totalSupply ( ) in case token is reused ! ),"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    uint public tokenMinted;

    function getTokenMinted() public constant returns (uint) {
        return tokenMinted;
    }
}","[{'function': 'getTokenMinted', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can mint new tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalSupply""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getTokenMinted', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol"";

contract MyToken is IERC20 {
    using SafeMath for uint256;

    // State variables
    string public name = ""My Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    // Mapping of token balances
    mapping(address => uint256) private _balances;

    // Function to mint new tokens
    function mint(uint256 amount) external {
        require(msg.sender == owner(), ""Only the owner can mint new tokens"");
        totalSupply = totalSupply.add(amount);
        _mint(msg.sender, amount);
    }

    // Function to transfer tokens
    function transfer(address recipient, uint256 amount) external {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        totalSupply = totalSupply.sub(amount);
        _transfer(msg.sender, recipient, amount);
    }
}",6.466084718704224,mint,"[{'function': 'mint', 'complexity': 1}, {'function': 'transfer', 'complexity': 1}]",2.0,22.0,0.5561774963047043,0.0133658637678263,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyToken is IERC20, Ownable {
    using SafeMath for uint256;

    // State variables
    string public name = ""My Token"";
    string public symbol = ""MTK"";
    uint8 public decimals = 18;
    uint256 public totalSupply = 1000000000000000000;

    // Mapping of token balances
    mapping(address => uint256) private _balances;

    // Constructor
    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialization of state variables
        name = ""My Token"";
        symbol = ""MTK"";
        decimals = 18;
        totalSupply = 1000000000000000000;
    }

    // Function to mint new tokens
    function mint(uint256 amount) external {
        require(msg.sender == owner(), ""Only the owner can mint new tokens"");
        totalSupply = totalSupply.add(amount);
        _mint(msg.sender, amount);
    }

    // Function to transfer tokens
    function transfer(address recipient, uint256 amount) external {
        require(_balances[msg.sender] >= amount, ""Insufficient balance"");
        totalSupply = totalSupply.sub(amount);
        _transfer(msg.sender, recipient, amount);
    }
}"
6399,Sets an external ` manager ` that will be able to call ` setInterfaceImplementer ( ) ` on behalf of the address .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ManagerChange {
    using SafeMath for uint256;

    mapping(address => address) public managers;

    event ManagerChanged(address indexed addr, address indexed newManager);

    modifier canManage(address addr) {
        require(managers[addr] == msg.sender, ""Only the current manager can change the manager."");
        _;
    }

    function changeManager(address addr, address newManager) public canManage(addr) {
        managers[addr] = newManager;
        emit ManagerChanged(addr, newManager);
    }
}","[{'function': 'changeManager', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""setManager"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_manager"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_manager""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid manager""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""manager""}, ""right"": {""type"": ""Identifier"", ""name"": ""_manager""}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'changeManager', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract MyContract {
    address public manager;

    function setManager(address _manager) external {
        require(_manager != address(0), ""Invalid manager"");
        manager = _manager;
    }
}",1.1709871292114258,setManager,"[{'function': 'setManager', 'complexity': 1}]",2.0,14.0,0.6919213747462243,0.0286068808744101,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    address public manager;

    constructor() Ownable(msg.sender) {
        manager = msg.sender; // Initialize to the deployer's address
    }

    function setManager(address _manager) external {
        require(_manager != address(0), ""Invalid manager"");
        manager = _manager;
    }
}"
5804,Returns current sell offer for the canvas .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract CanvasMarketplace is Ownable {
    using SafeMath for uint256;

    struct SellOffer {
        bool isForSale;
        address seller;
        uint minPrice;
        address onlySellTo;
    }

    mapping(uint32 => SellOffer) public canvasForSale;

    function getCurrentSellOffer(uint32 _canvasId) external view returns (bool isForSale, address seller, uint minPrice, address onlySellTo) {
        SellOffer storage offer = canvasForSale[_canvasId];
        return (offer.isForSale, offer.seller, offer.minPrice, offer.onlySellTo);
    }
}","[{'function': 'getCurrentSellOffer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getCurrentSellOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_canvasAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellOffers""}, ""index"": {""type"": ""Identifier"", ""name"": ""_canvasAddress""}}, ""memberName"": ""price""}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getCurrentSellOffer', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract CanvasSeller {
    using SafeMath for uint256;

    struct SellOffer {
        address seller;
        uint256 price;
    }

    mapping(address => SellOffer) public sellOffers;

    function getCurrentSellOffer(address _canvasAddress) external view returns (uint256) {
        return sellOffers[_canvasAddress].price;
    }
}",2.206307172775269,getCurrentSellOffer,"[{'function': 'getCurrentSellOffer', 'complexity': 0}]",1.0,18.0,0.8828079252192234,0.0801715840443123,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract CanvasSeller is Ownable {
    using SafeMath for uint256;

    struct SellOffer {
        address seller;
        uint256 price;
    }

    mapping(address => SellOffer) public sellOffers;

    function getCurrentSellOffer(address _canvasAddress) external view returns (uint256) {
        return sellOffers[_canvasAddress].price;
    }

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            sellOffers[addr] = SellOffer({seller: addr, price: uint256(i)});
        }
    }
}"
1832,Generates ` amount ` tokens that are assigned to ` owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    function mGenerateTokens(address owner, uint256 amount) internal {
        // logic goes here
    }
}","[{'function': 'mGenerateTokens', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""generateTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can generate tokens""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'mGenerateTokens', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";

contract MyContract {
    IERC20 public token;

    constructor(address _owner) public {
        token = new ERC20(""MyToken"", ""MTK"");
        token.mint(_owner, 1000);
    }

    function generateTokens(uint256 amount) external {
        require(msg.sender == owner(), ""Only the owner can generate tokens"");
        token.mint(amount);
    }
}",3.2062876224517822,generateTokens,"[{'function': 'generateTokens', 'complexity': 1}]",2.0,19.0,0.8345496453507564,0.0406731552331291,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    IERC20 public token;

    constructor(address _owner) Ownable(_owner) {
        token = new ERC20(""MyToken"", ""MTK"");
        token.mint(_owner, 1000);
    }

    function generateTokens(uint256 amount) external onlyOwner {
        require(msg.sender == owner(), ""Only the owner can generate tokens"");
        token.mint(amount);
    }
}"
107,Allows the owner to register and the details for a token .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenRegistry is Ownable {
    using SafeMath for uint256;

    struct TokenInfo {
        address tokenAddress;
        uint8 tokenDecimals;
    }

    mapping(uint32 => TokenInfo) public tokenInfos;

    event RegisteredToken(uint32 indexed tokenCode, address indexed tokenAddress, uint8 tokenDecimals);

    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {
        require(msg.sender == owner(), ""Only the contract owner can call this function"");
        require(_tokenCode > 0, ""Invalid token code"");
        require(_tokenAddress != address(0), ""Invalid token address"");
        require(_tokenDecimals > 0, ""Invalid token decimals"");

        uint32 tokenCode = _tokenCode;
        address tokenAddress = _tokenAddress;
        uint8 tokenDecimals = _tokenDecimals;

        TokenInfo storage tokenInfo = tokenInfos[tokenCode];
        require(tokenInfo.tokenAddress == address(0), ""Token already registered"");

        tokenInfo.tokenAddress = tokenAddress;
        tokenInfo.tokenDecimals = tokenDecimals;

        emit RegisteredToken(_tokenCode, tokenAddress, tokenDecimals);
    }
}","[{'function': 'registerToken', 'complexity': 5}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""registerToken"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""name"", ""storageLocation"": ""calldata"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""supply"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""owner""}, ""arguments"": [], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Only the contract owner can register a token""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""tokens""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenDetails""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""name""}, {""type"": ""Identifier"", ""name"": ""supply""}], ""names"": [""owner"", ""name"", ""supply""]}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'registerToken', 'complexity': 5}]",6.0,"pragma solidity ^0.8.0;

contract TokenRegistry {
    struct TokenDetails {
        address owner;
        string name;
        uint256 supply;
    }

    mapping(address => TokenDetails) public tokens;

    function registerToken(string calldata name, uint256 supply) external {
        require(msg.sender == owner(), ""Only the contract owner can register a token"");
        tokens[msg.sender] = TokenDetails({owner: msg.sender, name: name, supply: supply});
    }
}",2.42668890953064,registerToken,"[{'function': 'registerToken', 'complexity': 1}]",2.0,65.0,0.7035494603112311,0.0901377916242479,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenRegistry is Ownable {
    struct TokenDetails {
        address owner;
        string name;
        uint256 supply;
    }

    mapping(address => TokenDetails) public tokens;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            tokens[addr] = TokenDetails({owner: addr, name: 'initialized', supply: 1});
        }
    }

    function registerToken(string calldata name, uint256 supply) external {
        require(msg.sender == owner(), ""Only the contract owner can register a token"");
        tokens[msg.sender] = TokenDetails({owner: msg.sender, name: name, supply: supply});
    }
}"
2044,Mint ` _amount ` tokens that are assigned to ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function updateValueAtNow(mapping(address => uint256) storage data, uint value) external;
}

abstract contract Token is Ownable, IToken {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint256 => uint256) public totalSupplyHistory;
    bool public finalized;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyController() {
        require(isController[msg.sender], ""Only controller can call this function"");
        _;
    }

    modifier notFinalized() {
        require(!finalized, ""Contract is finalized and cannot be modified"");
        _;
    }

    function mintTokens(address _owner, uint256 _amount) public onlyController notFinalized returns (bool) {
        uint256 curTotalSupply = totalSupply();
        require(curTotalSupply.add(_amount) >= curTotalSupply, ""SafeMath: addition overflow"");
        uint256 previousBalanceTo = balanceOf(_owner);
        require(previousBalanceTo.add(_amount) >= previousBalanceTo, ""SafeMath: addition overflow"");
        updateValueAtNow(balances[_owner], previousBalanceTo.add(_amount));
        updateValueAtNow(totalSupplyHistory, curTotalSupply.add(_amount));
        emit Transfer(address(0), _owner, _amount);
        return true;
    }

    function totalSupply() public view override returns (uint256) {
        return totalSupplyHistory[block.number];
    }

    function balanceOf(address account) public view override returns (uint256) {
        return balances[account];
    }

    function updateValueAtNow(mapping(address => uint256) storage data, uint value) internal {
        data[block.number] = value;
    }
}","[{'function': 'updateValueAtNow', 'complexity': 0}, {'function': 'mintTokens', 'complexity': 2}, {'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'updateValueAtNow', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid owner""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updateValueAtNow', 'complexity': 0}, {'function': 'mintTokens', 'complexity': 2}, {'function': 'totalSupply', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'updateValueAtNow', 'complexity': 0}]",3.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function mint(address _owner, uint256 _amount) public {
        require(_owner != address(0), ""Invalid owner"");
        require(_amount > 0, ""Invalid amount"");

        // Additional logic can be added here

        // Mint the tokens and assign them to the owner
        _mint(_owner, _amount);
    }
}",2.317783832550049,mint,"[{'function': 'mint', 'complexity': 2}]",3.0,47.0,0.8049887798578289,0.1603630946825343,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        owner = msg.sender; // address: Use these fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        totalSupply_ = 1; // uint/uint256: Set to 1 (never 0)
        name_ = ""initialized""; // string: Set to 'initialized'
        symbol_ = bytes32('init'); // bytes32: Set to bytes32('init')
    }

    function mint(address _owner, uint256 _amount) public {
        require(_owner != address(0), ""Invalid owner"");
        require(_amount > 0, ""Invalid amount"");

        // Mint the tokens and assign them to the owner
        _mint(_owner, _amount);
    }

    uint256 private totalSupply_;
    string private name_;
    bytes32 private symbol_;
}"
2892,Makes an offer which can be filled by other users .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface Coordinator {
    function onlyCoordinator() external view;
    function onlyActiveState() external view;
}

abstract contract OfferManager is Ownable, SafeMath {
    struct Offer {
        address maker;
        address offerAsset;
        address wantAsset;
        uint256 offerAmount;
        uint256 wantAmount;
        uint256 availableAmount;
        uint64 nonce;
    }

    mapping(bytes32 => Offer) public offers;
    address public coordinator;

    event Make(address indexed maker, bytes32 indexed offerHash);

    function makeOffer(
        address _maker,
        address _offerAsset,
        address _wantAsset,
        uint256 _offerAmount,
        uint256 _wantAmount,
        address _feeAsset,
        uint256 _feeAmount,
        uint64 _nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external onlyOwner {
        require(_offerAmount > 0 && _wantAmount > 0, ""Invalid amounts"");
        require(_offerAsset != _wantAsset, ""Invalid assets"");

        bytes32 offerHash = keccak256(abi.encodePacked(""makeOffer"", _maker, _offerAsset, _wantAsset, _offerAmount, _wantAmount, _feeAsset, _feeAmount, _nonce));

        require(_recoverAddress(offerHash, v, r, s) == _maker, ""Invalid signature"");

        _validateAndAddHash(offerHash);

        _decreaseBalanceAndPayFees(_maker, _offerAsset, _offerAmount, _feeAsset, _feeAmount, ReasonMakerGive, ReasonMakerFeeGive, ReasonMakerFeeReceive);

        Offer storage offer = offers[offerHash];
        offer.maker = _maker;
        offer.offerAsset = _offerAsset;
        offer.wantAsset = _wantAsset;
        offer.offerAmount = _offerAmount;
        offer.wantAmount = _wantAmount;
        offer.availableAmount = _offerAmount;
        offer.nonce = _nonce;

        emit Make(_maker, offerHash);
    }

    function setCoordinator(address _coordinator) external onlyOwner {
        coordinator = _coordinator;
    }

    modifier onlyCoordinator() {
        require(msg.sender == coordinator, ""Only coordinator can call this function"");
        _;
    }

    modifier onlyActiveState() {
        // Assuming there's a way to check if the state is active
        require(isStateActive(), ""Contract state is not active"");
        _;
    }

    function isStateActive() internal view returns (bool) {
        // Implement logic to check if the state is active
        return true; // Placeholder
    }

    function _validateAndAddHash(bytes32 hash) internal {
        // Implement validation and adding of hash logic
    }

    function _decreaseBalanceAndPayFees(
        address account,
        address token,
        uint256 amount,
        address feeToken,
        uint256 feeAmount,
        Reason reasonMakerGive,
        Reason reasonMakerFeeGive,
        Reason reasonMakerFeeReceive
    ) internal {
        // Implement logic to decrease balance and pay fees
    }

    function _recoverAddress(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        return ecrecover(hash, v, r, s);
    }
}","[{'function': 'onlyActiveState', 'complexity': 0}, {'function': 'makeOffer', 'complexity': 0}, {'function': 'setCoordinator', 'complexity': 0}, {'function': 'isStateActive', 'complexity': 0}, {'function': '_validateAndAddHash', 'complexity': 0}, {'function': '_decreaseBalanceAndPayFees', 'complexity': 0}, {'function': '_recoverAddress', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""fillOffer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""maker"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""maker""}}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""memberName"": ""isFilled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": False}}, {""type"": ""stringLiteral"", ""value"": ""Offer already filled""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Offer""}, ""name"": ""offer"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""maker""}}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""offer""}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid offer amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""offers""}, ""index"": {""type"": ""Identifier"", ""name"": ""maker""}}, ""index"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""memberName"": ""isFilled""}, ""right"": {""type"": ""BooleanLiteral"", ""value"": True}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onlyActiveState', 'complexity': 0}, {'function': 'makeOffer', 'complexity': 0}, {'function': 'setCoordinator', 'complexity': 0}, {'function': 'isStateActive', 'complexity': 0}, {'function': '_validateAndAddHash', 'complexity': 0}, {'function': '_decreaseBalanceAndPayFees', 'complexity': 0}, {'function': '_recoverAddress', 'complexity': 0}]",5.0,"
pragma solidity ^0.8.0;

contract Offer {
    struct Offer {
        address maker;
        uint256 amount;
        bool isFilled;
    }

    mapping(address => Offer[]) public offers;

    function makeOffer(uint256 amount) external {
        require(amount > 0, ""Invalid offer"");
        Offer memory newOffer = Offer({maker: msg.sender, amount: amount, isFilled: false});
        offers[msg.sender].push(newOffer);
    }

    function fillOffer(address maker) external {
        require(offers[maker][0].isFilled == false, ""Offer already filled"");
        Offer memory offer = offers[maker][0];
        require(offer.amount > 0, ""Invalid offer amount"");
        offers[maker][0].isFilled = true;
    }
}",4.03620457649231,fillOffer,"[{'function': 'makeOffer', 'complexity': 1}, {'function': 'fillOffer', 'complexity': 2}]",3.0,116.0,0.7497885703658647,0.0057470461857738,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Offer is Ownable {
    struct Offer {
        address maker;
        uint256 amount;
        bool isFilled;
    }

    mapping(address => Offer[]) public offers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            offers[addr].push(Offer({maker: addr, amount: 1, isFilled: false}));
        }
    }

    function makeOffer(uint256 amount) external {
        require(amount > 0, ""Invalid offer"");
        Offer memory newOffer = Offer({maker: msg.sender, amount: amount, isFilled: false});
        offers[msg.sender].push(newOffer);
    }

    function fillOffer(address maker) external {
        require(offers[maker][0].isFilled == false, ""Offer already filled"");
        Offer memory offer = offers[maker][0];
        require(offer.amount > 0, ""Invalid offer amount"");
        offers[maker][0].isFilled = true;
    }
}"
5927,A getter to find the level of authority a specific Project has using a self-referential loop,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PledgeAdminWrapper {
    using SafeMath for uint256;

    struct PledgeAdmin {
        uint adminType;
        uint parentProject;
        // Add other necessary state variables here
    }

    enum PledgeAdminType { Project, Other }

    function getProjectLevel(PledgeAdmin storage m) internal returns (uint) {
        require(m.adminType == uint(PledgeAdminType.Project), ""Invalid admin type"");
        if (m.parentProject == 0) return 1;
        PledgeAdmin storage parentNM = findAdmin(m.parentProject);
        return getProjectLevel(parentNM).add(1);
    }

    function findAdmin(uint projectId) internal view returns (PledgeAdmin storage) {
        // Implement the logic to retrieve the PledgeAdmin struct by projectId
        // This is a placeholder for where you would have your actual implementation
        revert(""Not implemented"");
    }
}","[{'function': 'getProjectLevel', 'complexity': 1}, {'function': 'findAdmin', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAuthorityLevel"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_project"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_project""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid project""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""level"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_project""}, ""memberName"": ""owner""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""level""}, ""isPrefix"": False}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""j"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""j""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_project""}, ""memberName"": ""subProjects""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""j""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""subProject"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_project""}, ""memberName"": ""subProjects""}, ""index"": {""type"": ""Identifier"", ""name"": ""j""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getAuthorityLevel""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""subProject""}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""level""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""level""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""getAuthorityLevel""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""subProject""}], ""names"": []}}}]}, ""FalseBody"": None}]}}]}, ""FalseBody"": None}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""_project""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_project""}, ""memberName"": ""owner""}}}]}}, {""type"": ""Identifier"", ""name"": ""level""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'getProjectLevel', 'complexity': 1}, {'function': 'findAdmin', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

contract AuthorityLevel {
    struct Project {
        address owner;
        uint256 level;
    }

    function getAuthorityLevel(address _project) public view returns (uint256) {
        require(_project != address(0), ""Invalid project"");

        // Initialize the authority level to 0
        uint256 level = 0;

        // Iterate through the self-referential loop
        for (uint256 i = 1; i <= 10; i++) {
            if (_project.owner == msg.sender) {
                // If the project owner is the current user, increment the authority level
                level++;

                // Check if there are any sub-projects and iterate through them
                for (uint256 j = 0; j < _project.subProjects.length; j++) {
                    address subProject = _project.subProjects[j];

                    // If the sub-project has a higher authority level, update it
                    if (getAuthorityLevel(subProject) > level) {
                        level = getAuthorityLevel(subProject);
                    }
                }
            }

            _project = _project.owner;
        }

        return level;
    }
}",5.886616468429565,getAuthorityLevel,"[{'function': 'getAuthorityLevel', 'complexity': 11}]",6.0,28.0,0.6435777221261996,0.0429497569011352,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract AuthorityLevel is Ownable {
    struct Project {
        address owner;
        uint256 level;
    }

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function getAuthorityLevel(address _project) public view returns (uint256) {
        require(_project != address(0), ""Invalid project"");

        // Initialize the authority level to 0
        uint256 level = 0;

        // Iterate through the self-referential loop
        for (uint256 i = 1; i <= 10; i++) {
            if (_project.owner == msg.sender) {
                // If the project owner is the current user, increment the authority level
                level++;

                // Check if there are any sub-projects and iterate through them
                for (uint256 j = 0; j < _project.subProjects.length; j++) {
                    address subProject = _project.subProjects[j];

                    // If the sub-project has a higher authority level, update it
                    if (getAuthorityLevel(subProject) > level) {
                        level = getAuthorityLevel(subProject);
                    }
                }
            }

            _project = _project.owner;
        }

        return level;
    }
}"
3990,Notifies the controller about a token transfer allowing the controller to react if desired,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    function onTransfer(address _from, address _to, uint256 _amount) public returns (bool) {
        return false;
    }
}","[{'function': 'onTransfer', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""notifyTokenTransfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""controller""}}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner or controller can call this function""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""TokenTransfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}, {""type"": ""Identifier"", ""name"": ""from""}, {""type"": ""Identifier"", ""name"": ""to""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onTransfer', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract TokenTransferNotifier {
    address public owner;
    address public controller;

    constructor(address _owner, address _controller) public {
        owner = _owner;
        controller = _controller;
    }

    function notifyTokenTransfer(uint256 amount, address from, address to) external {
        require(msg.sender == owner || msg.sender == controller, ""Only the owner or controller can call this function"");
        emit TokenTransfer(amount, from, to);
    }
}",2.480509996414185,notifyTokenTransfer,"[{'function': 'notifyTokenTransfer', 'complexity': 2}]",4.0,20.0,0.6297426963821522,0.0132303837792556,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenTransferNotifier is Ownable {
    address public controller;

    constructor(address _owner, address _controller) Ownable(_owner) {
        controller = _controller;
    }

    function notifyTokenTransfer(uint256 amount, address from, address to) external {
        require(msg.sender == owner || msg.sender == controller, ""Only the owner or controller can call this function"");
        emit TokenTransfer(amount, from, to);
    }
}"
5074,` onlyOwner ` Cancel a payment all together,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PaymentManager is Ownable {
    using SafeMath for uint256;

    struct Payment {
        bool paid;
        bool canceled;
    }

    Payment[] public authorizedPayments;

    event PaymentCanceled(uint indexed idPayment);

    function cancelPayment(uint _idPayment) public onlyOwner {
        if (_idPayment >= authorizedPayments.length) revert();
        Payment storage p = authorizedPayments[_idPayment];
        if (p.canceled) revert();
        if (p.paid) revert();
        p.canceled = true;
        emit PaymentCanceled(_idPayment);
    }
}","[{'function': 'cancelPayment', 'complexity': 0}]",4.0,{},"[{'function': 'cancelPayment', 'complexity': 0}]",4.0,"
pragma solidity ^0.8.0;

contract PaymentCanceler {
    using SafeMath for uint256;

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function cancelPayment(uint256 paymentId) public onlyOwner {
        // Cancel the payment here
    }
}",1.6280395984649658,cancelPayment,"[{'function': 'cancelPayment', 'complexity': 0}]",1.0,32.0,0.8502102282948879,0.0238564351095007,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract PaymentCanceler is Ownable {
    using SafeMath for uint256;

    address public owner = msg.sender;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function cancelPayment(uint256 paymentId) public onlyOwner {
        // Cancel the payment here
    }
}"
1247,Helper function that checks for IEIP777TokensOperator on the recipient and calls it .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC777TokensOperator {
    function madeOperatorForTokens(address _operator, address _from, address _to, uint256 _value, bytes calldata _userData, bytes calldata _operatorData) external;
}

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function callOperator(address _operator, address _from, address _to, uint256 _value, bytes memory _userData, bytes memory _operatorData, bool _preventLocking) public onlyOwner {
        address recipientImplementation = interfaceAddr(_to, ""ERC777TokensOperator"");
        if (recipientImplementation != 0) {
            ERC777TokensOperator(recipientImplementation).madeOperatorForTokens(_operator, _from, _to, _value, _userData, _operatorData);
        } else if (_preventLocking) {
            require(isRegularAddress(_to), ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"");
        }
    }
}","[{'function': 'madeOperatorForTokens', 'complexity': 0}, {'function': 'callOperator', 'complexity': 3}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""supportsInterface""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""IEIP777TokensOperator""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Recipient does not support IEIP777TokensOperator""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""call""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""transfer""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'madeOperatorForTokens', 'complexity': 0}, {'function': 'callOperator', 'complexity': 3}]",6.0,"
pragma solidity ^0.8.0;

import ""SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transfer(address recipient, uint256 amount) public {
        require(recipient.supportsInterface(IEIP777TokensOperator), ""Recipient does not support IEIP777TokensOperator"");
        recipient.call(""transfer"", msg.sender, amount);
    }
}",2.1569790840148926,transfer,"[{'function': 'transfer', 'complexity': 1}]",3.0,,0.5432176788020675,0.0127675168364811,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct and the contract exists

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        uint256 fixedUint = 1;
        address fixedAddress = address(uint160(uint256(keccak256('a'))));
        bool fixedBool = true;
        string memory fixedString = 'initialized';
        bytes32 fixedBytes32 = bytes32('init');
    }

    function transfer(address recipient, uint256 amount) public {
        require(recipient.supportsInterface(IEIP777TokensOperator), ""Recipient does not support IEIP777TokensOperator"");
        recipient.call(""transfer"", msg.sender, amount);
    }
}"
5500,Approves another address to claim for the ownership of any tokens owned by this account,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ApproveAllWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function approveAll(address _to) public onlyOwner {
        require(_to != msg.sender, ""cant approve yourself"");
        require(_to != address(0), ""invalid owner"");
        operatorApprovals[msg.sender][_to] = true;
        emit ApprovalForAll(msg.sender, _to, true);
    }
}","[{'function': 'approveAll', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveClaim"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_claimant"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_claimant""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid claimant address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""claimedAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""100"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ClaimApproved""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_claimant""}, {""type"": ""Identifier"", ""name"": ""claimedAmount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approveAll', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

contract TokenOwnershipTransfer {
    using SafeMath for uint256;

    function approveClaim(address _claimant, uint256 _amount) public {
        require(_claimant != address(0), ""Invalid claimant address"");
        require(_amount > 0, ""Invalid amount"");

        // Additional logic can be added here to check if the claimant is authorized to make this approval

        uint256 claimedAmount = _amount.mul(100).div(100);
        emit ClaimApproved(_claimant, claimedAmount);
    }
}",2.9157397747039795,approveClaim,"[{'function': 'approveClaim', 'complexity': 2}]",3.0,20.0,0.6159723680916349,0.1498385123532989,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract TokenOwnershipTransfer is Ownable {
    using SafeMath for uint256;

    // Fixed, safe values for instance variables
    address public constant DEFAULT_ADDRESS = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_BOOL = true;
    string public constant DEFAULT_STRING = 'initialized';
    bytes32 public constant DEFAULT_BYTES32 = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        _address = DEFAULT_ADDRESS;
        _bool = DEFAULT_BOOL;
        _string = DEFAULT_STRING;
        _bytes32 = DEFAULT_BYTES32;
    }

    address public _address;
    bool public _bool;
    string public _string;
    bytes32 public _bytes32;

    function approveClaim(address _claimant, uint256 _amount) public {
        require(_claimant != address(0), ""Invalid claimant address"");
        require(_amount > 1, ""Invalid amount""); // Set to at least 1

        // Additional logic can be added here to check if the claimant is authorized to make this approval

        uint256 claimedAmount = _amount.mul(100).div(100);
        emit ClaimApproved(_claimant, claimedAmount);
    }
}"
4001,Function calls other functions to calculate tokenamount to send to beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract Crowdsale is Ownable {
    using SafeMath for uint256;

    Token public token;
    address payable public wallet;
    uint256 public rate;
    uint256 public weiRaised;
    uint256 public tokensSold;

    constructor(uint256 _rate, address payable _wallet, Token _token) {
        require(_rate > 0, ""Crowdsale: rate is 0"");
        require(_wallet != address(0), ""Crowdsale: wallet is the zero address"");
        require(address(_token) != address(0), ""Crowdsale: token is the zero address"");

        rate = _rate;
        wallet = _wallet;
        token = _token;
    }

    function buyTokens(address _beneficiary) public payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(_beneficiary, weiAmount);
        uint256 tokens = _getTokenAmount(weiAmount);
        require(token.balanceOf(address(this)) >= tokens, ""Crowdsale: token contract has insufficient balance"");

        weiRaised = weiRaised.add(weiAmount);
        tokensSold = tokensSold.add(tokens);
        _deliverTokens(_beneficiary, tokens);
        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
        _processBonus(msg.sender, tokens);
        _forwardFunds();
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal pure {
        require(_beneficiary != address(0), ""Crowdsale: beneficiary is the zero address"");
        require(_weiAmount > 0, ""Crowdsale: wei amount is 0"");
    }

    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
        return _weiAmount.mul(rate);
    }

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(token.transfer(_beneficiary, _tokenAmount), ""Crowdsale: token transfer failed"");
    }

    function _forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    function _processBonus(address _investor, uint256 _tokens) internal virtual {
        // Implement bonus logic here
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 1}, {'function': '_preValidatePurchase', 'complexity': 2}, {'function': '_getTokenAmount', 'complexity': 0}, {'function': '_deliverTokens', 'complexity': 1}, {'function': '_forwardFunds', 'complexity': 0}, {'function': '_processBonus', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""calculateTokenAmount"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_beneficiary"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'transfer', 'complexity': 0}, {'function': 'buyTokens', 'complexity': 1}, {'function': '_preValidatePurchase', 'complexity': 2}, {'function': '_getTokenAmount', 'complexity': 0}, {'function': '_deliverTokens', 'complexity': 1}, {'function': '_forwardFunds', 'complexity': 0}, {'function': '_processBonus', 'complexity': 0}]",3.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function calculateTokenAmount(address _beneficiary) public view returns (uint256) {
        // Calculate the token amount to send to the beneficiary
        return 0;
    }
}",1.7362422943115234,calculateTokenAmount,"[{'function': 'calculateTokenAmount', 'complexity': 0}]",1.0,64.0,0.6652135454784688,0.012310846232561,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is for Ownable contract

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        someUint = 1; // uint/uint256: Set to 1 (never 0)
        someAddress = address(uint160(uint256(keccak256('a')))); // address: Use these fixed values in order
        someBool = true; // bool: Set to true
        someString = 'initialized'; // string: Set to 'initialized'
        someBytes32 = bytes32('init'); // bytes32: Set to bytes32('init')
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function calculateTokenAmount(address _beneficiary) public pure returns (uint256) {
        // Calculate the token amount to send to the beneficiary
        return 0;
    }
}"
267,Redeem required amount of tokens for the real asset,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract ExampleContract is Ownable {
    using SafeMath for uint256;

    function redeem(uint256 _tokens) public onlyOwner {
        __redeem_impl(msg.sender, _tokens);
    }

    function __redeem_impl(address account, uint256 tokens) internal {
        // Implementation of the redeem logic
    }
}","[{'function': 'redeem', 'complexity': 0}, {'function': '__redeem_impl', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""redeem"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can call this function""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""The amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""redeemer""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient balance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""Identifier"", ""name"": ""redeemer""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'redeem', 'complexity': 0}, {'function': '__redeem_impl', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract RedeemContract {
    using SafeMath for uint256;

    // State variables
    address public owner;
    address public redeemer;
    uint256 public amount;

    constructor(address _owner, address _redeemer, uint256 _amount) public {
        owner = _owner;
        redeemer = _redeemer;
        amount = _amount;
    }

    // Function to redeem the required amount of tokens for the real asset
    function redeem() external {
        require(msg.sender == owner, ""Only the owner can call this function"");
        require(amount > 0, ""The amount must be greater than zero"");

        uint256 balance = IERC20(address(this)).balanceOf(redeemer);
        require(balance >= amount, ""Insufficient balance"");

        IERC20(address(this)).transferFrom(owner, redeemer, amount);
    }
}",4.599583864212036,redeem,"[{'function': 'redeem', 'complexity': 3}]",4.0,41.0,0.692143613832788,0.0243321377044043,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract RedeemContract is Ownable {
    using SafeMath for uint256;

    // State variables
    address public redeemer;
    uint256 public amount;

    mapping(address => uint256) public balanceOf;

 constructor(address _redeemer, uint256 _amount) Ownable(msg.sender) {
        redeemer = _redeemer;
        amount = _amount;
    }

    // Function to redeem the required amount of tokens for the real asset
    function redeem() external {
        require(msg.sender == owner(), ""Only the owner can call this function"");
        require(amount > 0, ""The amount must be greater than zero"");

        uint256 balance = IERC20(address(this)).balanceOf(redeemer);
        require(balance >= amount, ""Insufficient balance"");

        IERC20(address(this)).transferFrom(owner(), redeemer, amount);
    }
}"
1315,Burns ` _amount ` tokens from ` _owner `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenInterface {
    function balanceOf(address owner) external view returns (uint256);
    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) external;
    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) external view returns (uint256);
}

abstract contract TokenWrapper is Ownable, TokenInterface {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    mapping(uint => uint256) public totalSupplyHistory;

    event Transfer(address indexed from, address indexed to, uint256 value);

    modifier onlyController() {
        require(msg.sender == owner(), ""Only the controller can call this function"");
        _;
    }

    function balanceOf(address _owner) public override view returns (uint256 balance) {
        return balances[_owner];
    }

    function getValueAt(mapping(uint => uint256) storage data, uint blockNumber) public override view returns (uint256) {
        require(blockNumber <= getBlockNumber(), ""Block number must be in the past"");
        return data[blockNumber];
    }

    function updateValueAtNow(mapping(uint => uint256) storage data, uint value) public override {
        data[getBlockNumber()] = value;
    }

    function getBlockNumber() internal view virtual returns (uint256) {
        return block.number;
    }

    function destroyTokens(address _owner, uint256 _amount) public onlyController returns (bool) {
        uint256 curTotalSupply = getValueAt(totalSupplyHistory, getBlockNumber());
        require(curTotalSupply >= _amount, ""Insufficient balance"");
        updateValueAtNow(totalSupplyHistory, curTotalSupply.sub(_amount));
        uint256 previousBalanceFrom = balanceOf(_owner);
        require(previousBalanceFrom >= _amount, ""Insufficient balance"");
        updateValueAtNow(balances[_owner], previousBalanceFrom.sub(_amount));
        emit Transfer(_owner, address(0), _amount);
        return true;
    }
}","[{'function': 'getValueAt', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'getValueAt', 'complexity': 1}, {'function': 'updateValueAtNow', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'destroyTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""burn"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: burn from the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""ERC20: burn amount must be positive""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'getValueAt', 'complexity': 0}, {'function': 'balanceOf', 'complexity': 0}, {'function': 'getValueAt', 'complexity': 1}, {'function': 'updateValueAtNow', 'complexity': 0}, {'function': 'getBlockNumber', 'complexity': 0}, {'function': 'destroyTokens', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function burn(address _owner, uint256 _amount) public {
        require(_owner != address(0), ""ERC20: burn from the zero address"");
        require(_amount > 0, ""ERC20: burn amount must be positive"");

        // Additional logic can be added here
    }
}",2.280744791030884,burn,"[{'function': 'burn', 'complexity': 2}]",3.0,49.0,0.6235911914426888,0.131984264300407,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is how you import OpenZeppelin contracts

contract MyContract is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        address owner = msg.sender;
        bytes32 initBytes = bytes32('init');
        bool initialized = true;
        string memory tokenName = 'MyToken';
        uint256 positiveValue = 1; // Set to 1 (never 0) for uint/uint256
    }

    function burn(address _owner, uint256 _amount) public {
        require(_owner != address(0), ""ERC20: burn from the zero address"");
        require(_amount > 0, ""ERC20: burn amount must be positive"");

        // Additional logic can be added here
    }
}"
4051,Query if an address is an authorized operator for another address,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedContract is Ownable {
    using SafeMath for uint256;

    mapping(address => mapping(address => bool)) public operatorApprovals;

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return operatorApprovals[_owner][_operator];
    }
}","[{'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""addOperator"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_operator"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""_isAuthorized"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""operators""}, ""index"": {""type"": ""Identifier"", ""name"": ""_operator""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_isAuthorized""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isApprovedForAll', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

contract Operator {
    mapping(address => bool) public operators;

    constructor() {}

    function addOperator(address _operator, bool _isAuthorized) public {
        operators[_operator] = _isAuthorized;
    }

    function isAuthorizedOperator(address _owner, address _operator) public view returns (bool) {
        return operators[_operator];
    }
}",1.9168260097503664,addOperator,"[{'function': 'addOperator', 'complexity': 0}, {'function': 'isAuthorizedOperator', 'complexity': 0}]",1.0,5.0,0.6437878124447343,0.0370826097860597,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Operator is Ownable {
    mapping(address => bool) public operators;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function addOperator(address _operator, bool _isAuthorized) public {
        operators[_operator] = _isAuthorized;
    }

    function isAuthorizedOperator(address _owner, address _operator) public view returns (bool) {
        return operators[_operator];
    }
}"
5314,Modifies the list of overrides for non-accredited limits in USD,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public nonAccreditedLimitUSDOverride;

    event SetNonAccreditedLimit(address indexed investor, uint256 limit);

    function changeNonAccreditedLimit(address[] memory _investors, uint256[] memory _nonAccreditedLimit) public onlyOwner {
        require(_investors.length == _nonAccreditedLimit.length, ""Array length mismatch"");

        for (uint256 i = 0; i < _investors.length; i++) {
            require(_nonAccreditedLimit[i] > 0, ""Limit can not be 0"");

            nonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];
            emit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);
        }
    }
}","[{'function': 'changeNonAccreditedLimit', 'complexity': 3}]",4.0,{},"[{'function': 'changeNonAccreditedLimit', 'complexity': 3}]",4.0,"
pragma solidity ^0.8.0;

contract OverrideLimits {
    using SafeMath for uint256;

    function updateNonAccreditedLimits(uint256[] memory _overrides) public {
        // Additional logic can be added here
    }
}",1.3403983116149902,updateNonAccreditedLimits,"[{'function': 'updateNonAccreditedLimits', 'complexity': 0}]",1.0,60.0,0.6637931858624482,0.0028900853908046,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract OverrideLimits {
    using SafeMath for uint256;

    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');
    string public constant INIT_STRING = 'initialized';
    uint256 public constant DEFAULT_LIMIT = 1;

    constructor() Ownable(OWNER) {
        initialized = INIT_STRING;
    }

    function updateNonAccreditedLimits(uint256[] memory _overrides) public {
        // Additional logic can be added here
    }
}
```

Note that I've replaced the `OWNER` address with a placeholder value. You should replace it with the actual owner's address.

Also, I've removed the abstract keyword from the contract as per your request. If you want to keep it as an contract, you can add the `abstract` keyword back in:

```solidity
pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract OverrideLimits is Ownable {
    using SafeMath for uint256;

    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with actual owner's address
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');
    string public constant INIT_STRING = 'initialized';
    uint256 public constant DEFAULT_LIMIT = 1;

    constructor() abstract Ownable(OWNER) {
        initialized = INIT_STRING;
    }

    function updateNonAccreditedLimits(uint256[] memory _overrides) public {
        // Additional logic can be added here
    }
}"
2308,Return the boolean ( true/false ) registration status for an issuer firm,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Data {
    using SafeMath for uint256;
    mapping(bytes32 => bool) private storageMap;

    function getBool(bytes32 key) public view returns (bool) {
        return storageMap[key];
    }
}

abstract contract RegisteredFirm is Ownable {
    Data private dataStorage;

    constructor() {
        dataStorage = new Data();
    }

    function isRegisteredFirm(string memory issuerFirm) public view returns (bool registered) {
        bytes32 id = keccak256(abi.encodePacked('registered.firm', issuerFirm));
        return dataStorage.getBool(id);
    }
}","[{'function': 'getBool', 'complexity': 0}, {'function': 'isRegisteredFirm', 'complexity': 0}]",1.0,{},"[{'function': 'getBool', 'complexity': 0}, {'function': 'isRegisteredFirm', 'complexity': 0}]",1.0,"
contract IssuerRegistration {
    using SafeMath for uint256;

    struct IssuerFirm {
        address owner;
        bool registered;
    }

    mapping(address => IssuerFirm) public issuers;

    function isRegistered(address _issuerAddress) public view returns (bool) {
        return issuers[_issuerAddress].registered;
    }
}",1.7745239734649658,isRegistered,"[{'function': 'isRegistered', 'complexity': 0}]",1.0,22.0,0.7053137803525318,0.1143755198335855,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract IssuerRegistration is Ownable {
    using SafeMath for uint256;

    struct IssuerFirm {
        address owner;
        bool registered;
    }

    mapping(address => IssuerFirm) public issuers;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            issuers[addr] = IssuerFirm({owner: addr, registered: true});
        }
    }

    function isRegistered(address _issuerAddress) public view returns (bool) {
        return issuers[_issuerAddress].registered;
    }
}"
1642,` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface TokenController {
    function onApprove(address _owner, address _spender, uint256 _amount) external returns (bool);
}

abstract contract ERC20Token is Ownable {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    bool public transfersEnabled;
    address public controller;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply.mul(10 ** uint256(decimals));
        balances[msg.sender] = totalSupply;
        transfersEnabled = true;
    }

    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(transfersEnabled, ""Transfers are not enabled"");
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0), ""Allowance already granted"");
        if (isContract(_spender)) {
            bool onApprove = TokenController(controller).onApprove(msg.sender, _spender, _amount);
            require(onApprove, ""Approval rejected by controller"");
        }
        allowed[msg.sender][_spender] = _amount;
        emit Approval(msg.sender, _spender, _amount);
        return true;
    }

    function isContract(address addr) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}","[{'function': 'onApprove', 'complexity': 0}, {'function': 'approve', 'complexity': 5}, {'function': 'isContract', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Approval""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""_amount""}], ""names"": []}}, {""type"": ""BooleanLiteral"", ""value"": True}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'onApprove', 'complexity': 0}, {'function': 'approve', 'complexity': 5}, {'function': 'isContract', 'complexity': 0}]",6.0,"pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint256;

    function approve(address _spender, uint256 _amount) public returns (bool) {
        require(_spender != address(0), ""Invalid spender"");
        require(_amount > 0, ""Invalid amount"");

        allowances[msg.sender][_spender] = allowances[msg.sender][_spender].add(_amount);

        emit Approval(msg.sender, _spender, _amount);

        return true;
    }
}",2.7185251712799072,approve,"[{'function': 'approve', 'complexity': 2}]",3.0,24.0,0.921384009180496,0.2988776732681575,"pragma solidity ^0.8.0;
import ""openzeppelin/SafeMath.sol"";
contract MyContract {
    using SafeMath for uint256;
    address public constant DEFAULT_SPENDER = 0x1111111111111111111111111111111111111111; // Replace with actual address
    bool public constant DEFAULT_APPROVED = true;
    bytes32 public constant DEFAULT_INIT = bytes32('init');

    constructor() Ownable(msg.sender) {
        // Initialize instance variables to fixed, safe values
        uint256 public constant DEFAULT_AMOUNT = 1;
        allowances[msg.sender][DEFAULT_SPENDER] = DEFAULT_AMOUNT;

        // Set default state for ERC20-like contracts (if applicable)
        // For example:
        // ERC20(""MyToken"", ""TKN"");
    }

    function approve(address _spender, uint256 _amount) public returns (bool) {
        require(_spender != address(0), ""Invalid spender"");
        require(_amount > 0, ""Invalid amount"");

        allowances[msg.sender][_spender] = allowances[msg.sender][_spender].add(_amount);

        emit Approval(msg.sender, _spender, _amount);

        return true;
    }
}"
3698,This method can be used by the controller to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    address public snt = 0x0;

    event ClaimedTokens(address indexed token, address indexed owner, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        require(_token != snt, ""Cannot withdraw SNT tokens"");
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""recoverTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_recoverTo"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_recoverTo""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyController"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 3}]",4.0,"
pragma solidity ^0.8.0;

contract TokenRecovery {
    using SafeMath for uint256;

    function recoverTokens(address _tokenAddress, address _recoverTo) public onlyController {
        IERC20 token = IERC20(_tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(_recoverTo, balance), ""Transfer failed"");
    }
}",2.117689847946167,recoverTokens,"[{'function': 'recoverTokens', 'complexity': 1}]",2.0,23.0,0.6413889857057788,0.192437756050437,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract TokenRecovery is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function recoverTokens(address _tokenAddress, address _recoverTo) public onlyOwner {
        IERC20 token = IERC20(_tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(_recoverTo, balance), ""Transfer failed"");
    }
}"
6060,Set current ICO prices in wei for one metadollar,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceUpdater is Ownable {
    using SafeMath for uint256;

    uint256 public currentTokenPrice;
    bool public preIcoIsRunning;
    uint256 public preICOprice;
    uint256 public ICOprice;

    event priceUpdated(uint256 oldPrice, uint256 newPrice, string message);

    function updatePrices() external onlyOwner {
        uint256 oldPrice = currentTokenPrice;
        if (preIcoIsRunning) {
            checkPreIcoStatus();
        }
        if (preIcoIsRunning) {
            currentTokenPrice = preICOprice;
        } else {
            currentTokenPrice = ICOprice;
        }
        if (oldPrice != currentTokenPrice) {
            emit priceUpdated(oldPrice, currentTokenPrice, ""Metadollar price updated!"");
        }
    }

    function checkPreIcoStatus() internal view {
        // Implement the logic to check pre-ICO status
    }
}","[{'function': 'updatePrices', 'complexity': 3}, {'function': 'checkPreIcoStatus', 'complexity': 0}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""setCurrentICOPrices"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_priceInWei"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_priceInWei""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Price must be greater than zero""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""currentICOPrices""}, ""right"": {""type"": ""Identifier"", ""name"": ""_priceInWei""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'updatePrices', 'complexity': 3}, {'function': 'checkPreIcoStatus', 'complexity': 0}]",5.0,"function setCurrentICOPrices(uint256 _priceInWei) public {
    require(_priceInWei > 0, ""Price must be greater than zero"");

    // Set the current ICO prices in wei for one metadollar
    currentICOPrices = _priceInWei;
}",1.4179866313934326,setCurrentICOPrices,"[{'function': 'setCurrentICOPrices', 'complexity': 1}]",2.0,16.0,0.6588366218129408,0.0094532599553972,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract ICOContract is Ownable {
    uint256 public currentICOPrices;

    constructor() Ownable(msg.sender) {
        // Initialize state variables to safe, non-corner-case values
        currentICOPrices = 1;
    }

    function setCurrentICOPrices(uint256 _priceInWei) public {
        require(_priceInWei > 0, ""Price must be greater than zero"");
        currentICOPrices = _priceInWei;
    }
}"
6552,upper bound of series of snapshotIds for which there 's a value in series,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract SnapshotHolder is Ownable {
    using SafeMath for uint256;

    uint256 private _currentSnapshotId;

    function currentSnapshotId() public view onlyOwner returns (uint256) {
        return _currentSnapshotId;
    }
}","[{'function': 'currentSnapshotId', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getUpperBoundOfSnapshotIds"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""upperBound"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""snapshots""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""snapshots""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""memberName"": ""value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""upperBound""}, ""right"": {""type"": ""Identifier"", ""name"": ""i""}}}]}, ""FalseBody"": None}]}}, {""type"": ""Identifier"", ""name"": ""upperBound""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'currentSnapshotId', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

contract MyContract {
    using SafeMath for uint256;

    struct Snapshot {
        uint256 value;
        uint256 timestamp;
    }

    mapping(uint256 => Snapshot) public snapshots;

    function getUpperBoundOfSnapshotIds() public view returns (uint256) {
        uint256 upperBound = 0;

        for (uint256 i = 0; i < snapshots.length; i++) {
            if (snapshots[i].value > 0) {
                upperBound = i;
            }
        }

        return upperBound;
    }
}",5.6339311599731445,getUpperBoundOfSnapshotIds,"[{'function': 'getUpperBoundOfSnapshotIds', 'complexity': 3}]",3.0,24.0,0.6445388812762185,0.1471645476710016,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Snapshot {
        uint256 value;
        uint256 timestamp;
    }

    mapping(uint256 => Snapshot) public snapshots;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            snapshots[i] = Snapshot({value: 1, timestamp: block.timestamp});
        }
    }

    function getUpperBoundOfSnapshotIds() public view returns (uint256) {
        uint256 upperBound = 0;

        for (uint256 i = 0; i < snapshots.length; i++) {
            if (snapshots[i].value > 0) {
                upperBound = i;
            }
        }

        return upperBound;
    }
}"
2199,Create ` mintedAmount ` tokens and send it to ` target `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenWrapper {
    using SafeMath for uint256;

    function mintToken(address target, uint256 mintedAmount) public onlyOwner {
        token.mint(target, mintedAmount);
    }
}","[{'function': 'mintToken', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""mint"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""target"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""mint""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""target""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'mintToken', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.2.0/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.2.0/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function mint(address target, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        IERC20 token = IERC20(msg.sender);
        token.mint(target, amount);
    }
}",3.628340005874634,mint,"[{'function': 'mint', 'complexity': 1}]",2.0,15.0,0.8363060379123554,0.2064597158958983,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.2.0/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.2.0/contracts/utils/math/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function mint(address target, uint256 amount) public {
        require(amount > 0, ""Invalid amount"");
        IERC20 token = IERC20(""MyToken""); // Use placeholder value
        token.mint(target, amount);
    }
}"
1644,Trim the realitio question content to the part before the initial delimiter .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;
    string constant REALITIO_DELIMITER = ""|"";

    function _trimQuestion(string memory q) public pure returns (string memory) {
        return abi.decode(bytes(q).length > 0 ? bytes.concat(bytes(q), bytes(REALITIO_DELIMITER)) : bytes(""""), (string));
    }
}","[{'function': '_trimQuestion', 'complexity': 1}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""trimContent"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""_content"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": None, ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""trimmedContent"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""stringLiteral"", ""value"": """"}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""name"": ""contentBytes"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_content""}], ""names"": []}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""contentBytes""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contentBytes""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}, ""right"": {""type"": ""stringLiteral"", ""value"": "".""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": ["";""]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""trimmedContent""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""trimmedContent""}, {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contentBytes""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}], ""names"": []}], ""names"": []}}}]}}]}}, {""type"": ""Identifier"", ""name"": ""trimmedContent""}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""pure""}","[{'function': '_trimQuestion', 'complexity': 1}]",1.0,"pragma solidity ^0.8.0;

contract RealitioQuestion {
    using SafeMath for uint256;

    function trimContent(string memory _content) public pure returns (string memory) {
        string memory trimmedContent = """";
        bytes memory contentBytes = bytes(_content);
        for (uint256 i = 0; i < contentBytes.length; i++) {
            if (contentBytes[i] == '.') {
                break;
            } else {
                trimmedContent = string(abi.encodePacked(trimmedContent, contentBytes[i]));
            }
        }
        return trimmedContent;
    }
}",2.8818299770355225,trimContent,"[{'function': 'trimContent', 'complexity': 4}]",3.0,40.0,0.6337104416772075,0.1940182786588982,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RealitioQuestion is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with fixed, safe, non-corner-case values
        owner = msg.sender;
        someUint = 1;
        someAddress = address(0x111);
        someBool = true;
        someString = 'initialized';
        someBytes32 = bytes32('init');
    }

    uint256 public someUint;
    address public someAddress;
    bool public someBool;
    string public someString;
    bytes32 public someBytes32;

    function trimContent(string memory _content) public pure returns (string memory) {
        string memory trimmedContent = """";
        bytes memory contentBytes = bytes(_content);
        for (uint256 i = 0; i < contentBytes.length; i++) {
            if (contentBytes[i] == '.') {
                break;
            } else {
                trimmedContent = string(abi.encodePacked(trimmedContent, contentBytes[i]));
            }
        }
        return trimmedContent;
    }
}"
2321,Function to send tokens or refund after the closing time of the funding proposals,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    mapping(uint => uint) public pendingAmounts;

    event SentPendingAmount(address indexed buyer, uint indexed id, uint amount);

    function sendPendingAmounts(uint _from, uint _to, address _buyer) public onlyOwner returns (bool) {
        require(_from <= _to);
        for (uint i = _from; i <= _to; i++) {
            if (pendingAmounts[i] > 0) {
                pendingAmounts[i].transfer(address(this));
                emit SentPendingAmount(_buyer, i, pendingAmounts[i]);
                pendingAmounts[i] = 0;
            }
        }
    }
}","[{'function': 'sendPendingAmounts', 'complexity': 4}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""sendTokensOrRefund"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""block""}, ""memberName"": ""timestamp""}, ""right"": {""type"": ""Identifier"", ""name"": ""closingTime""}}, {""type"": ""stringLiteral"", ""value"": ""Funding proposal is still open""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalContributions"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""contributions""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""totalContributions""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [None]}, ""FalseBody"": None}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""tokenAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalContributions""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""1e18"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""owner""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""tokenAmount""}], ""names"": []}, {""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'sendPendingAmounts', 'complexity': 4}]",4.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract FundingProposal {
    using SafeMath for uint256;

    IERC20 public token;
    address public owner;
    mapping(address => uint256) public contributions;
    uint256 public closingTime;

    constructor(IERC20 _token, address _owner, uint256 _closingTime) {
        token = _token;
        owner = _owner;
        closingTime = _closingTime;
    }

    function sendTokensOrRefund() public {
        require(block.timestamp > closingTime, ""Funding proposal is still open"");
        uint256 totalContributions = contributions[msg.sender];
        if (totalContributions == 0) {
            return;
        }
        uint256 tokenAmount = totalContributions.div(1e18);
        require(token.transferFrom(owner, msg.sender, tokenAmount), ""Transfer failed"");
    }
}",6.22049880027771,sendTokensOrRefund,"[{'function': 'sendTokensOrRefund', 'complexity': 3}]",4.0,34.0,0.5116780362317166,0.0397681237332628,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract FundingProposal is Ownable {
    using SafeMath for uint256;

    IERC20 public token;
    mapping(address => uint256) public contributions;
    uint256 public closingTime;

    constructor(IERC20 _token, address _owner, uint256 _closingTime) Ownable(_owner) {
        token = _token;
        closingTime = _closingTime;
    }

    function sendTokensOrRefund() public {
        require(block.timestamp > closingTime, ""Funding proposal is still open"");
        uint256 totalContributions = contributions[msg.sender];
        if (totalContributions == 0) {
            return;
        }
        uint256 tokenAmount = totalContributions.div(1e18);
        require(token.transferFrom(owner, msg.sender, tokenAmount), ""Transfer failed"");
    }
}"
5497,Returns asset balance for a particular holder id .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface IAsset {
    function balanceOf(uint _holderId, bytes32 _symbol) external view returns (uint);
}

abstract contract AssetWrapper is Ownable {
    using SafeMath for uint;

    mapping(bytes32 => Asset) public assets;

    struct Asset {
        mapping(uint => Wallet) wallets;
    }

    struct Wallet {
        uint balance;
    }

    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {
        return assets[_symbol].wallets[_holderId].balance;
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': '_balanceOf', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""getAssetBalance"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""holderId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""holderId""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'balanceOf', 'complexity': 0}, {'function': '_balanceOf', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract AssetBalance {
    using SafeMath for uint256;

    function getAssetBalance(uint256 holderId) public view returns (uint256) {
        return holderId.mul(10**18);
    }
}",1.6646182537078855,getAssetBalance,"[{'function': 'getAssetBalance', 'complexity': 0}]",1.0,9.0,0.7350184851128774,0.2595865729034343,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AssetBalance is Ownable {
    using SafeMath for uint256;

    constructor() Ownable(msg.sender) {
        // No need to initialize state variables as they are not defined in this contract
    }

    function getAssetBalance(uint256 holderId) public view returns (uint256) {
        return holderId.mul(10**18);
    }
}"
124,Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrapperContract is Ownable {
    using SafeMath for uint256;

    mapping(uint256 => address) public allStarIndexToApproved;

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    function approve(address _to, uint256 _tokenId) public {
        require(_owns(msg.sender, _tokenId));
        allStarIndexToApproved[_tokenId] = _to;
        emit Approval(msg.sender, _to, _tokenId);
    }

    function _owns(address owner, uint256 tokenId) internal view returns (bool) {
        return owner == msg.sender; // Simplified ownership check for demonstration purposes
    }
}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""grantOwnership"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_owner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_owner""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Owner cannot be 0x0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Spender cannot be 0x0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeERC20""}, ""memberName"": ""safeTransferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_owner""}, {""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""NumberLiteral"", ""number"": ""1"", ""subdenomination"": None}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 1}, {'function': '_owns', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";

contract MyContract {
    using SafeERC20 for IERC20;

    function grantOwnership(address _owner, address _spender) public {
        require(_owner != address(0), ""Owner cannot be 0x0"");
        require(_spender != address(0), ""Spender cannot be 0x0"");

        IERC20 token = SafeERC20.safeTransferFrom(_owner, _spender, 1);
    }
}",3.232884168624878,grantOwnership,"[{'function': 'grantOwnership', 'complexity': 2}]",3.0,18.0,0.5052871626899537,0.1153556922912443,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    using SafeERC20 for IERC20;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function grantOwnership(address _owner, address _spender) public {
        require(_owner != address(0), ""Owner cannot be 0x0"");
        require(_spender != address(0), ""Spender cannot be 0x0"");

        IERC20 token = SafeERC20.safeTransferFrom(_owner, _spender, 1);
    }
}"
467,Allows the owner to destroy a beneficiary .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    struct Beneficiary {
        bool isBeneficiary;
        uint256 vested;
        uint256 released;
    }

    mapping(address => Beneficiary) public beneficiaries;
    IERC20 public token;
    uint256 public totalReleased;

    event BeneficiaryDestroyed(address indexed beneficiary);

    constructor(address _tokenAddress) {
        token = IERC20(_tokenAddress);
    }

    function destroyBeneficiary(address _beneficiary) public onlyOwner {
        Beneficiary storage beneficiary = beneficiaries[_beneficiary];
        uint256 balance = beneficiary.vested.sub(beneficiary.released);
        require(token.transfer(owner, balance), ""Token transfer failed"");
        totalReleased = totalReleased.add(balance);
        beneficiary.isBeneficiary = false;
        beneficiary.released = beneficiary.released.add(balance);
        emit BeneficiaryDestroyed(_beneficiary);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'destroyBeneficiary', 'complexity': 1}]",2.0,{},"[{'function': 'transfer', 'complexity': 0}, {'function': 'destroyBeneficiary', 'complexity': 1}]",2.0,"contract DestroyBeneficiary {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function destroyBeneficiary(address payable beneficiary) public {
        require(msg.sender == owner, ""Only the owner can destroy a beneficiary"");
        selfdestruct(beneficiary);
    }
}",1.6640489101409912,destroyBeneficiary,"[{'function': 'destroyBeneficiary', 'complexity': 1}]",2.0,55.0,0.8580885585029289,0.060653284444736,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DestroyBeneficiary is Ownable {
    address public owner;

    constructor(address _owner) Ownable(_owner) {
        owner = _owner;
    }

    function destroyBeneficiary(address payable beneficiary) public {
        require(msg.sender == owner, ""Only the owner can destroy a beneficiary"");
        selfdestruct(beneficiary);
    }
}"
3604,Adds a co-owner for an asset with provided symbol .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract AssetWrapper {
    using SafeMath for uint256;

    struct Asset {
        mapping(uint => bool) partowners;
    }

    bytes32[] public symbols;
    mapping(bytes32 => Asset) public assets;
    address public eventsHistory;
    uint constant OK = 1;

    modifier onlyOneOfOwners(bytes32 _symbol) {
        require(_isPartowner(_symbol, msg.sender), ""Not a part owner"");
        _;
    }

    function addAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {
        uint holderId = _createHolderId(_partowner);
        assets[_symbol].partowners[holderId] = true;
        Emitter(eventsHistory).emitOwnershipChange(0x0, _partowner, _symbol);
        return OK;
    }

    function _isPartowner(bytes32 _symbol, address _partowner) internal view returns (bool) {
        for (uint i = 0; ; ++i) {
            if (!assets[_symbol].partowners[i]) {
                return false;
            }
            if (_partowner == address(0)) {
                break;
            }
        }
        return true;
    }

    function _createHolderId(address _partowner) internal pure returns (uint holderId) {
        holderId = uint256(_partowner);
    }
}","[{'function': 'addAssetPartOwner', 'complexity': 0}, {'function': '_isPartowner', 'complexity': 7}, {'function': '_createHolderId', 'complexity': 0}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""addCoOwner"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""string""}, ""name"": ""symbol"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""newOwner"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""coOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""symbol""}}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""5"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Maximum number of co-owners reached""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""CoOwner""}, ""name"": ""coOwner"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""CoOwner""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newOwner""}, {""type"": ""BooleanLiteral"", ""value"": False}], ""names"": [""owner"", ""approved""]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""coOwners""}, ""index"": {""type"": ""Identifier"", ""name"": ""symbol""}}, ""memberName"": ""push""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""coOwner""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'addAssetPartOwner', 'complexity': 0}, {'function': '_isPartowner', 'complexity': 7}, {'function': '_createHolderId', 'complexity': 0}]",4.0,"
pragma solidity ^0.8.0;

contract Asset {
    struct CoOwner {
        address owner;
        bool approved;
    }

    mapping(string => CoOwner[]) public coOwners;

    function addCoOwner(string memory symbol, address newOwner) public {
        require(coOwners[symbol].length < 5, ""Maximum number of co-owners reached"");

        CoOwner memory coOwner = CoOwner({owner: newOwner, approved: false});
        coOwners[symbol].push(coOwner);
    }
}",2.568397521972656,addCoOwner,"[{'function': 'addCoOwner', 'complexity': 1}]",2.0,26.0,0.5029468066414408,0.0132491881268964,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Asset is Ownable {
    struct CoOwner {
        address owner;
        bool approved;
    }

    mapping(string => CoOwner[]) public coOwners;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 0; i < 3; i++) {
            address addr = address(uint160(i + 1));
            bytes32 initBytes = bytes32('init');
            if (i == 0) coOwners[""symbol""].push(CoOwner({owner: addr, approved: true}));
            else if (i == 1) coOwners[""symbol""].push(CoOwner({owner: addr, approved: false}));
            else coOwners[""symbol""].push(CoOwner({owner: addr, approved: true}));
        }
    }

    function addCoOwner(string memory symbol, address newOwner) public {
        require(coOwners[symbol].length < 5, ""Maximum number of co-owners reached"");

        CoOwner memory coOwner = CoOwner({owner: newOwner, approved: false});
        coOwners[symbol].push(coOwner);
    }
}"
5691,allows participants in the Atonomi network to claim their rewards,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWithdrawal is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public rewards;
    IERC20 public token;
    bool public paused = false;

    event TokensWithdrawn(address indexed user, uint256 amount);

    modifier whenNotPaused() {
        require(!paused, ""Contract is paused"");
        _;
    }

    function withdrawTokens() public whenNotPaused returns (bool) {
        uint256 amount = rewards[msg.sender];
        require(amount > 0, ""amount is zero"");
        rewards[msg.sender] = rewards[msg.sender].sub(amount);
        emit TokensWithdrawn(msg.sender, amount);
        require(token.transfer(msg.sender, amount), ""token transfer failed"");
        return true;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawTokens', 'complexity': 2}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""claimRewards"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""participants""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""No rewards to claim""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""reward"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""participants""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""amount""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""participants""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""reward""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawTokens', 'complexity': 2}, {'function': 'pause', 'complexity': 0}, {'function': 'unpause', 'complexity': 0}]",3.0,"
pragma solidity ^0.8.0;

contract RewardClaim {
    using SafeMath for uint256;

    struct Participant {
        address wallet;
        uint256 amount;
    }

    mapping(address => Participant) public participants;

    function claimRewards() public {
        require(participants[msg.sender].amount > 0, ""No rewards to claim"");
        uint256 reward = participants[msg.sender].amount;
        participants[msg.sender].amount = 0;
        payable(msg.sender).transfer(reward);
    }
}",2.8440816402435303,claimRewards,"[{'function': 'claimRewards', 'complexity': 1}]",2.0,34.0,0.5376842947632465,0.0377085149576689,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract RewardClaim is Ownable {
    using SafeMath for uint256;

    struct Participant {
        address wallet;
        uint256 amount;
    }

    mapping(address => Participant) public participants;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            participants[addr] = Participant({wallet: addr, amount: uint256(i)});
        }
    }

    function claimRewards() public {
        require(participants[msg.sender].amount > 0, ""No rewards to claim"");
        uint256 reward = participants[msg.sender].amount;
        participants[msg.sender].amount = 0;
        payable(msg.sender).transfer(reward);
    }
}"
2271,Deposit Ether where the contribution is credited to the address specified in the parameter .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    bool public isOpen = true;
    address[] public swimmersList;
    mapping(address => bool) public invested;
    mapping(address => uint256) public swimmers;
    uint256 public weiRaised;

    event Deposit(address indexed user, uint256 amount);

    modifier depositIsConfigCompliant() {
        require(isOpen, ""Deposit is not open"");
        _;
    }

    modifier canDeposit(address _user) {
        // Assuming some logic for checking if the user can deposit
        require(/* some condition */, ""User cannot deposit at this time"");
        _;
    }

    function deposit(address _user) public payable isOpen depositIsConfigCompliant canDeposit(_user) {
        if (!invested[_user]) {
            swimmersList.push(_user);
            invested[_user] = true;
        }
        weiRaised = weiRaised.add(msg.value);
        swimmers[_user] = swimmers[_user].add(msg.value);
        emit Deposit(msg.sender, msg.value);
    }
}","[{'function': 'deposit', 'complexity': 2}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""deposit"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address"", ""stateMutability"": ""payable""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Incorrect amount sent""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'deposit', 'complexity': 2}]",2.0,"
pragma solidity ^0.8.0;

contract DepositEther {
    using SafeMath for uint256;

    function deposit(address payable recipient, uint256 amount) public payable {
        require(msg.value == amount, ""Incorrect amount sent"");
        recipient.transfer(amount);
    }
}",1.5949454307556152,deposit,"[{'function': 'deposit', 'complexity': 1}]",2.0,29.0,0.6227789744553823,0.0838870599135288,"pragma solidity ^0.8.0;
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract DepositEther is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function deposit(address payable recipient, uint256 amount) public payable {
        require(msg.value == amount, ""Incorrect amount sent"");
        recipient.transfer(amount);
    }
}"
2948,The auction contract variable ( saleAuction ) is defined in MasterpieceBase to allow us to refer to them in MasterpieceOwnership to prevent accidental transfers .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    SaleClockAuction public saleAuction;

    function setSaleAuctionAddress(address _address) external onlyCEO {
        SaleClockAuction candidateContract = SaleClockAuction(_address);
        require(candidateContract.isSaleClockAuction());
        saleAuction = candidateContract;
    }
}","[{'function': 'setSaleAuctionAddress', 'complexity': 1}]",2.0,{},"[{'function': 'setSaleAuctionAddress', 'complexity': 1}]",2.0,"
contract Auction {
    address payable public seller;
    uint256 public startPrice;
    uint256 public endBlock;
    uint256 public currentHighestBid;
    mapping(address => uint256) public bids;

    constructor(uint256 _startPrice, uint256 _endBlock) {
        seller = msg.sender;
        startPrice = _startPrice;
        endBlock = _endBlock;
    }

    function bid() external payable {
        require(msg.value > currentHighestBid);
        bids[msg.sender] += msg.value;
        currentHighestBid = msg.value;
    }
}",3.1169779300689697,bid,"[{'function': 'bid', 'complexity': 1}]",2.0,22.0,0.4692539893100084,0.0299764012031161,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract Auction is Ownable {
    address payable public seller;
    uint256 public startPrice;
    uint256 public endBlock;
    uint256 public currentHighestBid;
    mapping(address => uint256) public bids;

    constructor(uint256 _startPrice, uint256 _endBlock) Ownable(msg.sender) {
        seller = payable(msg.sender);
        startPrice = _startPrice;
        endBlock = _endBlock;
        currentHighestBid = 0; // Set to 0 instead of leaving it uninitialized
    }

    function bid() external payable {
        require(msg.value > currentHighestBid, ""Bid amount must be higher than the current highest bid"");
        bids[msg.sender] += msg.value;
        currentHighestBid = msg.value;
    }
}"
4839,"Returns the loan metadata , hashed with keccak256 .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract TokenMetadataHashWrapper is Ownable {
    using SafeMath for uint256;

    struct Loan {
        bytes32 metadata;
    }

    mapping(uint256 => Loan) public loans;

    function tokenMetadataHash(uint2atural index) public view returns (bytes32) {
        require(index < totalLoans(), ""Index out of bounds"");
        return keccak256(abi.encodePacked(loans[index].metadata));
    }

    function setLoanMetadata(uint256 index, bytes32 metadata) public onlyOwner {
        require(index < totalLoans(), ""Index out of bounds"");
        loans[index].metadata = metadata;
    }

    function totalLoans() internal view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(loans)));
    }
}","[{'function': 'tokenMetadataHash', 'complexity': 1}, {'function': 'setLoanMetadata', 'complexity': 1}, {'function': 'totalLoans', 'complexity': 0}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""getLoanMetadataHash"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""loanId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""loanId""}, {""type"": ""stringLiteral"", ""value"": ""metadata""}], ""names"": []}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'tokenMetadataHash', 'complexity': 1}, {'function': 'setLoanMetadata', 'complexity': 1}, {'function': 'totalLoans', 'complexity': 0}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Loan {
    using SafeMath for uint256;

    function getLoanMetadataHash(uint256 loanId) public view returns (bytes32) {
        return keccak256(abi.encodePacked(loanId, ""metadata""));
    }
}",1.7948346138000488,getLoanMetadataHash,"[{'function': 'getLoanMetadataHash', 'complexity': 0}]",1.0,12.0,0.7902483327541482,0.3302732368328343,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this import is correct for the context of your contract

contract Loan is Ownable {
    using SafeMath for uint256;

    function getLoanMetadataHash(uint256 loanId) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(loanId, ""metadata""));
    }
}"
1398,Performs transfer call on the platform by the name of specified sender .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transferWithReference(address _to, uint _value, string memory _reference, address _sender) public onlyProxy returns (bool) {
        require(_checkTransferAllowance(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        require(_isValidCountryLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender));
        if (!super.transferWithReference(_to, _value, _reference, _sender)) {
            return false;
        }
        _updateTransferLimits(_to, _getParticipantRoles(_sender, _to)[1], _value, _sender);
        _contractFallbackERC223(_sender, _to, _value);
        return true;
    }

    function _checkTransferAllowance(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for checking transfer allowance
        require(false, ""Not implemented"");
        return false;
    }

    function _isValidCountryLimits(address _to, uint8 _role, uint _value, address _sender) internal view returns (bool) {
        // Implement the logic for validating country limits
        require(false, ""Not implemented"");
        return false;
    }

    function _updateTransferLimits(address _to, uint8 _role, uint _value, address _sender) internal {
        // Implement the logic to update transfer limits
        require(false, ""Not implemented"");
    }

    function _contractFallbackERC223(address _from, address _to, uint _value) internal {
        // Implement the fallback logic for ERC223 contract
        require(false, ""Not implemented"");
    }

    function _getParticipantRoles(address _sender, address _to) internal pure returns (uint8[2] memory roles) {
        // Implement the logic to get participant roles
        require(false, ""Not implemented"");
        return [uint8(0), uint8(0)];
    }
}","[{'function': 'transferWithReference', 'complexity': 4}, {'function': '_checkTransferAllowance', 'complexity': 1}, {'function': '_isValidCountryLimits', 'complexity': 1}, {'function': '_updateTransferLimits', 'complexity': 1}, {'function': '_contractFallbackERC223', 'complexity': 1}, {'function': '_getParticipantRoles', 'complexity': 1}]",5.0,"{""type"": ""FunctionDefinition"", ""name"": ""transfer"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""recipient"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""sender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Sender cannot be the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""recipient""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Recipient cannot be the zero address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""senderBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""senderBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Sender does not have enough balance""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""recipientBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""recipient""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""recipientBalance""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""sender""}, {""type"": ""Identifier"", ""name"": ""recipient""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferWithReference', 'complexity': 4}, {'function': '_checkTransferAllowance', 'complexity': 1}, {'function': '_isValidCountryLimits', 'complexity': 1}, {'function': '_updateTransferLimits', 'complexity': 1}, {'function': '_contractFallbackERC223', 'complexity': 1}, {'function': '_getParticipantRoles', 'complexity': 1}]",5.0,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract Transfer {
    using SafeMath for uint256;

    function transfer(address sender, address recipient, uint256 amount) public {
        require(sender != address(0), ""Sender cannot be the zero address"");
        require(recipient != address(0), ""Recipient cannot be the zero address"");
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 senderBalance = balanceOf(sender);
        require(senderBalance >= amount, ""Sender does not have enough balance"");

        uint256 recipientBalance = balanceOf(recipient);
        recipientBalance.add(amount);

        emit Transfer(sender, recipient, amount);
    }
}",4.158486843109131,transfer,"[{'function': 'transfer', 'complexity': 4}]",6.0,54.0,0.6348310618037122,0.0567667313350561,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Transfer is SafeERC20 {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transfer(address sender, address recipient, uint256 amount) public {
        require(sender != address(0), ""Sender cannot be the zero address"");
        require(recipient != address(0), ""Recipient cannot be the zero address"");
        require(amount > 0, ""Amount must be greater than zero"");

        uint256 senderBalance = balanceOf(sender);
        require(senderBalance >= amount, ""Sender does not have enough balance"");

        uint256 recipientBalance = balanceOf(recipient);
        recipientBalance.add(amount);

        emit Transfer(sender, recipient, amount);
    }
}"
883,Buy from multiple sellers at once to fill a single large order .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ITrade {
    function execute(address seller, uint256 quantity, uint256 price) external returns (uint256);
    function isAllowedTrade(address user) external view returns (bool);
}

abstract contract TradeWrapper is Ownable {
    using SafeMath for uint256;

    bool public enforceKyc = false;
    mapping(address => TradeOrder) public orderBook;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
    }

    function setEnforceKyc(bool _enforceKyc) external onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setTradeOrder(address seller, uint256 quantity, uint256 price) external onlyOwner {
        orderBook[seller] = TradeOrder({quantity: quantity, price: price});
    }

    function multiExecute(address[] memory sellers, uint256 lastQuantity) public payable returns (uint256 totalVouchers) {
        require(!enforceKyc || ITrade(this).isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        totalVouchers = 0;
        for (uint i = 0; i < sellers.length; i++) {
            TradeOrder memory to = orderBook[sellers[i]];
            if (i == sellers.length - 1) {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), lastQuantity, to.price);
                totalVouchers += voucherCount;
            } else {
                uint256 voucherCount = ITrade(sellers[i]).execute(address(this), to.quantity, to.price);
                totalVouchers += voucherCount;
            }
        }
        return totalVouchers;
    }
}","[{'function': 'isAllowedTrade', 'complexity': 0}, {'function': 'setEnforceKyc', 'complexity': 0}, {'function': 'setTradeOrder', 'complexity': 0}, {'function': 'multiExecute', 'complexity': 6}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyFromMultipleSellers"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ArrayTypeName"", ""baseTypeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""length"": None}, ""name"": ""sellerIds"", ""storageLocation"": ""memory"", ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""totalAmount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""ForStatement"", ""initExpression"": {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""i"", ""storageLocation"": None}], ""initialValue"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""conditionExpression"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""i""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""sellerIds""}, ""memberName"": ""length""}}, ""loopExpression"": {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""++"", ""subExpression"": {""type"": ""Identifier"", ""name"": ""i""}, ""isPrefix"": False}}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""sellerAddress"", ""storageLocation"": None}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""sellerIds""}, ""index"": {""type"": ""Identifier"", ""name"": ""i""}}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""sellerBalance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sellerAddress""}}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""sellerBalance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""Identifier"", ""name"": ""sellerAddress""}}, ""right"": {""type"": ""Identifier"", ""name"": ""sellerBalance""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""totalAmount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""totalAmount""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": ["";""]}}]}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""Identifier"", ""name"": ""totalAmount""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Not enough balance""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'isAllowedTrade', 'complexity': 0}, {'function': 'setEnforceKyc', 'complexity': 0}, {'function': 'setTradeOrder', 'complexity': 0}, {'function': 'multiExecute', 'complexity': 6}]",6.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract OrderFilled {
    using SafeMath for uint256;

    function buyFromMultipleSellers(uint256[] memory sellerIds, uint256 amount) public {
        uint256 totalAmount = 0;

        for (uint256 i = 0; i < sellerIds.length; i++) {
            address sellerAddress = sellerIds[i];
            uint256 sellerBalance = SafeMath.sub(balances[sellerAddress], amount);

            if (sellerBalance >= amount) {
                balances[sellerAddress] = sellerBalance;
                totalAmount = totalAmount.add(amount);
            } else {
                break;
            }
        }

        require(totalAmount == amount, ""Not enough balance"");
    }
}",4.105882406234741,buyFromMultipleSellers,"[{'function': 'buyFromMultipleSellers', 'complexity': 5}]",4.0,49.0,0.649035423417856,0.0910322351741197,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract OrderFilled is Ownable {
    using SafeMath for uint256;
    address public constant SELLER_ADDRESS_1 = 0x1111111111111111111111111111111111111111; // Replace with actual address
    address public constant SELLER_ADDRESS_2 = 0x2222222222222222222222222222222222222222; // Replace with actual address
    address public constant SELLER_ADDRESS_3 = 0x3333333333333333333333333333333333333333; // Replace with actual address

    uint256 public constant INITIAL_AMOUNT = 1;
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    mapping(address => uint256) public balances;

    constructor() Ownable(msg.sender) {
        balances[msg.sender] = INITIAL_AMOUNT;
    }

    function buyFromMultipleSellers(uint256[] memory sellerIds, uint256 amount) public {
        uint256 totalAmount = 0;

        for (uint256 i = 0; i < sellerIds.length; i++) {
            address sellerAddress = sellerIds[i];
            uint256 sellerBalance = SafeMath.sub(balances[sellerAddress], amount);

            if (sellerBalance >= amount) {
                balances[sellerAddress] = sellerBalance;
                totalAmount = totalAmount.add(amount);
            } else {
                break;
            }
        }

        require(totalAmount == amount, ""Not enough balance"");
    }
}"
2617,Set current mtdAmount price in wei for one token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract MTDContract is Ownable {
    using SafeMath for uint256;

    uint256 public mtdAmount;

    function setMtdAmount(uint256 mtdAmountInWei) public onlyOwner {
        require(mtdAmountInWei > 0, ""MTD amount must be greater than zero"");
        require(mtdAmount != mtdAmountInWei, ""MTD amount has not changed"");
        mtdAmount = mtdAmountInWei;
        updatePrices();
    }

    function updatePrices() internal {
        // Implementation of the updatePrices function
    }
}","[{'function': 'setMtdAmount', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""setMtdAmountPrice"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_mtdAmount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": None, ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""_mtdAmount""}, ""memberName"": ""mul""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""**"", ""left"": {""type"": ""NumberLiteral"", ""number"": ""10"", ""subdenomination"": None}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""18"", ""subdenomination"": None}}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""view""}","[{'function': 'setMtdAmount', 'complexity': 2}, {'function': 'updatePrices', 'complexity': 0}]",3.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    function setMtdAmountPrice(uint256 _mtdAmount) public view returns (uint256) {
        return _mtdAmount.mul(10**18); // 1 token = 10^18 wei
    }
}",1.8992891311645508,setMtdAmountPrice,"[{'function': 'setMtdAmountPrice', 'complexity': 0}]",1.0,21.0,0.8431329327993485,0.0155483389184789,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""./Ownable.sol"";

contract Token is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function setMtdAmountPrice(uint256 _mtdAmount) public view returns (uint256) {
        require(_mtdAmount > 0, ""Invalid amount"");
        return _mtdAmount.mul(10**18); // 1 token = 10^18 wei
    }
}"
191,"Change period duration to ` @ transformTime ( _periodDuration ) ` , effective for next accounting period","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ISettings {
    function periodDuration() external view returns (uint64);
}

abstract contract MyContract is Ownable {
    using SafeMath for uint256;

    struct Settings {
        uint64 periodDuration;
    }

    Settings public settings;

    event ChangePeriodDuration(uint64 indexed periodDuration);

    error ERROR_SET_PERIOD_TOO_SHORT();

    function setPeriodDuration(uint64 _periodDuration) external authP(CHANGE_PERIOD_ROLE, arr(uint256(_periodDuration), uint256(settings.periodDuration))) transitionsPeriod {
        require(_periodDuration >= 1 days, ERROR_SET_PERIOD_TOO_SHORT);
        settings.periodDuration = _periodDuration;
        emit ChangePeriodDuration(_periodDuration);
    }
}","[{'function': 'periodDuration', 'complexity': 0}, {'function': 'setPeriodDuration', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transformTime"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_periodDuration"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid duration""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""Identifier"", ""name"": ""periodDuration""}, ""right"": {""type"": ""Identifier"", ""name"": ""_periodDuration""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'periodDuration', 'complexity': 0}, {'function': 'setPeriodDuration', 'complexity': 1}]",2.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract AccountingPeriod {
    using SafeMath for uint256;

    // State variables
    uint256 public periodDuration;

    constructor() public {
        periodDuration = 1 days;
    }

    function transformTime(uint256 _periodDuration) public {
        require(_periodDuration > 0, ""Invalid duration"");
        periodDuration = _periodDuration;
    }
}",4.001976251602173,transformTime,"[{'function': 'transformTime', 'complexity': 1}]",3.0,18.0,0.7279252144203614,0.0624701620034356,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AccountingPeriod is Ownable {
    using SafeMath for uint256;

    // State variables
    uint256 public periodDuration;

    constructor() Ownable(msg.sender) {
        periodDuration = 1 days;
    }

    function transformTime(uint256 _periodDuration) public {
        require(_periodDuration > 0, ""Invalid duration"");
        periodDuration = _periodDuration;
    }
}"
243,Allows resetting the entire bid decryption/appending process in case a mistake was made and it is not possible to continue appending further bids .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract YourContract is Ownable {
    using SafeMath for uint256;

    enum state { active, ended }

    struct Bid {
        bool is_decrypted;
        bool is_burned;
        bool will_compute;
    }

    mapping(uint => Bid) public bids;
    uint[] public bids_decrypted;
    uint public bids_reset_count;
    uint public bids_decrypted_count;
    uint public bids_sorted_count;
    uint public bids_ignored_count;
    uint public bids_burned_count;
    state public status;

    function resetAppendDecryptedBids(uint _count) public onlyOwner {
        require(status == state.ended);
        require(bids_decrypted_count > 0);
        require(_count > 0);

        if (bids_reset_count == 0) {
            bids_reset_count = bids_decrypted_count;
        }

        uint count = _count;
        if (bids_reset_count < count) {
            count = bids_reset_count;
        }

        do {
            bids_reset_count--;
            bids[bids_decrypted[bids_reset_count]].is_decrypted = false;
            bids[bids_decrypted[bids_reset_count]].is_burned = false;
            bids[bids_decrypted[bids_reset_count]].will_compute = false;
            count--;
        } while (count > 0);

        if (bids_reset_count == 0) {
            bids_sorted_count = 0;
            bids_ignored_count = 0;
            bids_decrypted_count = 0;
            bids_burned_count = 0;
        }
    }
}","[{'function': 'resetAppendDecryptedBids', 'complexity': 6}]",9.0,"{""type"": ""FunctionDefinition"", ""name"": ""appendBid"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""bidId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""encryptedBid"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""&&"", ""left"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""bidId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""<"", ""left"": {""type"": ""Identifier"", ""name"": ""bidId""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""1000"", ""subdenomination"": None}}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""encryptedBid""}, ""memberName"": ""length""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""32"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Bid""}, ""name"": ""currentBid"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""bidId""}}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentBid""}, ""memberName"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bytes32""}, ""name"": ""decryptedBid"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""keccak256""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""abi""}, ""memberName"": ""encodePacked""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""encryptedBid""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentBid""}, ""memberName"": ""encryptedBid""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""bidId""}}, ""memberName"": ""amount""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""SafeMath""}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""currentBid""}, ""memberName"": ""amount""}, {""type"": ""Identifier"", ""name"": ""encryptedBid""}], ""names"": []}}}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""bids""}, ""index"": {""type"": ""Identifier"", ""name"": ""bidId""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""Bid""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""encryptedBid""}, {""type"": ""Identifier"", ""name"": ""encryptedBid""}], ""names"": [""amount"", ""encryptedBid""]}}}]}}, {""type"": ""EmitStatement"", ""eventCall"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""BidAppended""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""bidId""}, {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'resetAppendDecryptedBids', 'complexity': 6}]",9.0,"pragma solidity ^0.8.0;

contract BidAppender {
    using SafeMath for uint256;

    event BidAppended(uint256 indexed bidId, address indexed sender);

    struct Bid {
        uint256 amount;
        bytes32 encryptedBid;
    }

    mapping(uint256 => Bid) public bids;

    function appendBid(uint256 bidId, bytes32 encryptedBid) external {
        require(bidId > 0 && bidId < 1000);
        require(encryptedBid.length == 32);

        Bid memory currentBid = bids[bidId];

        if (currentBid.amount > 0) {
            // Decrypt and append the new bid to the existing one
            bytes32 decryptedBid = keccak256(abi.encodePacked(encryptedBid, currentBid.encryptedBid));
            bids[bidId].amount = SafeMath.add(currentBid.amount, encryptedBid);
        } else {
            // Create a new bid if there is no existing one
            bids[bidId] = Bid({ amount: encryptedBid, encryptedBid: encryptedBid });
        }

        emit BidAppended(bidId, msg.sender);
    }
}",6.149796485900879,appendBid,"[{'function': 'appendBid', 'complexity': 4}]",5.0,60.0,0.625065819632928,0.0652142374636674,"pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract BidAppender is Ownable {
    using SafeMath for uint256;

    event BidAppended(uint256 indexed bidId, address indexed sender);

    struct Bid {
        uint256 amount;
        bytes32 encryptedBid;
    }

    mapping(uint256 => Bid) public bids;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            bids[i] = Bid({ amount: uint256(i), encryptedBid: bytes32('init') });
        }
    }

    function appendBid(uint256 bidId, bytes32 encryptedBid) external {
        require(bidId > 0 && bidId < 1000);
        require(encryptedBid.length == 32);

        Bid memory currentBid = bids[bidId];

        if (currentBid.amount > 0) {
            // Decrypt and append the new bid to the existing one
            bytes32 decryptedBid = keccak256(abi.encodePacked(encryptedBid, currentBid.encryptedBid));
            bids[bidId].amount = SafeMath.add(currentBid.amount, encryptedBid);
        } else {
            // Create a new bid if there is no existing one
            bids[bidId] = Bid({ amount: encryptedBid, encryptedBid: encryptedBid });
        }

        emit BidAppended(bidId, msg.sender);
    }
}"
6808,Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract PriceSetter is Ownable {
    using SafeMath for uint256;

    uint256 public buyPrice;
    uint256 public sellPrice;

    function setPrices(uint256 newBuyPrice, uint256 newSellPrice) public onlyOwner {
        buyPrice = newBuyPrice;
        sellPrice = newSellPrice;
    }
}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""buyTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": []}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""right"": {""type"": ""Identifier"", ""name"": ""newBuyPrice""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient ETH""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""value""}, ""memberName"": ""div""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""newBuyPrice""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""add""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}}]}, ""visibility"": ""external"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": ""payable""}","[{'function': 'setPrices', 'complexity': 0}]",1.0,"
pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    function buyTokens() external payable {
        require(msg.value >= newBuyPrice, ""Insufficient ETH"");
        uint256 amount = msg.value.div(newBuyPrice);
        balances[msg.sender] = balances[msg.sender].add(amount);
    }

    function sellTokens() external {
        require(balances[msg.sender] >= newSellPrice, ""Insufficient tokens"");
        uint256 amount = balances[msg.sender].div(newSellPrice);
        balances[msg.sender] = balances[msg.sender].sub(amount);
    }
}",5.771890878677368,buyTokens,"[{'function': 'buyTokens', 'complexity': 1}, {'function': 'sellTokens', 'complexity': 1}]",2.0,26.0,0.5475977434071657,0.0178633654568444,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract Token is Ownable {;
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 private newBuyPrice = 1 ether; // Placeholder value
    uint256 private newSellPrice = 1; // Placeholder value

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 100 * 1 ether; // Example initial balance
    }

    function buyTokens() external payable {
        require(msg.value >= newBuyPrice, ""Insufficient ETH"");
        uint256 amount = msg.value.div(newBuyPrice);
        balances[msg.sender] = balances[msg.sender].add(amount);
    }

    function sellTokens() external {
        require(balances[msg.sender] >= newSellPrice, ""Insufficient tokens"");
        uint256 amount = balances[msg.sender].div(newSellPrice);
        balances[msg.sender] = balances[msg.sender].sub(amount);
    }
}"
4005,Buy quantity of tokens depending on the amount of sent ethers .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IToken {
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenWrapper is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    event SoldToken(address indexed buyer, uint256 value, string note);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function BuyToken(address _buyer, uint256 _value, string memory note) public onlyOwner {
        require(balances[msg.sender] >= _value && balances[_buyer].add(_value) > balances[_buyer], ""Insufficient balance or overflow"");
        SoldToken(_buyer, _value, note);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_buyer] = balances[_buyer].add(_value);
        Transfer(msg.sender, _buyer, _value);
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'BuyToken', 'complexity': 2}]",3.0,{},"[{'function': 'transferFrom', 'complexity': 0}, {'function': 'BuyToken', 'complexity': 2}]",3.0,"
contract TokenSale {
    using SafeMath for uint256;

    // State variables
    address public owner;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function buyTokens(uint256 amount) external payable returns (bool) {
        // Check if the sender has enough Ether to purchase the tokens
        require(msg.value >= amount, ""Not enough Ether sent"");

        // Calculate the number of tokens to purchase based on the amount of Ether sent
        uint256 numTokens = amount.div(1 ether);

        // Transfer the tokens to the sender's address
        balances[msg.sender] = balances[msg.sender].add(numTokens);

        return true;
    }
}",3.757790327072144,buyTokens,"[{'function': 'buyTokens', 'complexity': 1}]",2.0,68.0,0.5975479680141579,0.0136449202087247,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract TokenSale is Ownable {
    using SafeMath for uint256;

    // State variables
    address public owner = msg.sender;
    mapping(address => uint256) public balances;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function buyTokens(uint256 amount) external payable returns (bool) {
        require(msg.value >= amount, ""Not enough Ether sent"");
        uint256 numTokens = amount.div(1 ether);
        balances[msg.sender] = balances[msg.sender].add(numTokens);
        return true;
    }
}"
5639,Transfers asset balance from the caller to specified receiver .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract WrappedFunction is Ownable {
    using SafeMath for uint256;

    function transfer(address _to, uint256 _value) public returns (bool) {
        if (_to != address(0)) {
            return _transferWithReference(_to, _value, """");
        }
    }
}","[{'function': 'transfer', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferAsset"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""receiver"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""memberName"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 1}]",2.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract AssetTransfer {
    using SafeMath for uint256;

    function transferAsset(uint256 amount, address receiver) public {
        // Check if the caller has enough balance to transfer
        require(msg.sender.balance >= amount);

        // Transfer asset from the caller to the receiver
        msg.sender.transfer(amount);
    }
}",2.133589744567871,transferAsset,"[{'function': 'transferAsset', 'complexity': 1}]",2.0,16.0,0.5926505563390695,0.0356795945722473,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract AssetTransfer is Ownable {
    using SafeMath for uint256;

    function transferAsset(uint256 amount, address receiver) public onlyOwner {
        // Check if the caller has enough balance to transfer
        require(msg.sender.balance >= amount);

        // Transfer asset from the caller to the receiver
        msg.sender.transfer(amount);
    }
}"
971,` msg.sender ` approves ` _spender ` to spend ` _value ` tokens on its behalf .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

abstract contract Token {
    using SafeMath for uint256;

    mapping(address => mapping(address => uint256)) public allowances;

    event Approval(address indexed owner, address indexed spender, uint256 value);

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}","[{'function': 'approve', 'complexity': 0}]",1.0,"{""type"": ""FunctionDefinition"", ""name"": ""approve"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Invalid spender""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid value""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""balances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""memberName"": ""sub""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""BinaryOperation"", ""operator"": ""="", ""left"": {""type"": ""IndexAccess"", ""base"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""allowances""}, ""index"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}}, ""index"": {""type"": ""Identifier"", ""name"": ""_spender""}}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 0}]",1.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract Token {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    function approve(address _spender, uint256 _value) public {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Invalid value"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        allowances[msg.sender][_spender] = _value;
    }
}",3.1182875633239746,approve,"[{'function': 'approve', 'complexity': 2}]",3.0,28.0,0.8908186498151077,0.2795551031082146,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol""; // Assuming this is how you import Ownable from OpenZeppelin

contract Token is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balances[msg.sender] = 1000; // Set initial balance to 1 (never 0)
        for (uint256 i = 1; i <= 3; i++) {
            address addr = address(uint160(i));
            balances[addr] = 1; // Set balances of addresses 0x1111111111111111111111111111111111111111 to 1
        }
    }

    function approve(address _spender, uint256 _value) public {
        require(_spender != address(0), ""Invalid spender"");
        require(_value > 0, ""Invalid value"");
        balances[msg.sender] = balances[msg.sender].sub(_value);
        allowances[msg.sender][_spender] = _value;
    }
}"
2396,"Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .","// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Interface {
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

abstract contract OfferWrapper is Ownable {
    using SafeMath for uint256;

    ERC20Interface public tokenContract;
    bool public enforceKyc = false;
    uint256 public sellFloor;
    uint256 public sellCeiling;

    struct TradeOrder {
        uint256 quantity;
        uint256 price;
        uint256 expiry;
    }

    mapping(address => TradeOrder) public orderBook;

    event TokensOffered(address indexed user, uint256 quantity, uint256 price, uint256 expiry);

    function offer(uint256 quantity, uint256 price, uint256 expiry) public {
        require(enforceKyc == false || isAllowedTrade(msg.sender), ""You are unknown and not allowed to trade."");
        require(quantity > 0, ""You must supply a quantity."");
        require(price > 0, ""The sale price cannot be zero."");
        require(expiry > block.timestamp, ""Cannot have an expiry date in the past."");
        require(price >= sellFloor, ""The ask is below the minimum allowed."");
        require(sellCeiling == 0 || price <= sellCeiling, ""The ask is above the maximum allowed."");

        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, address(this));
        require(allowed >= quantity, ""You must approve the transfer of tokens before offering them for sale."");

        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);
        require(balance >= quantity, ""Not enough tokens owned to complete the order."");

        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);
        emit TokensOffered(msg.sender, quantity, price, expiry);
    }

    function setTokenContract(address _tokenContract) public onlyOwner {
        tokenContract = ERC20Interface(_tokenContract);
    }

    function setEnforceKyc(bool _enforceKyc) public onlyOwner {
        enforceKyc = _enforceKyc;
    }

    function setSellFloor(uint256 _sellFloor) public onlyOwner {
        sellFloor = _sellFloor;
    }

    function setSellCeiling(uint256 _sellCeiling) public onlyOwner {
        sellCeiling = _sellCeiling;
    }

    function isAllowedTrade(address user) internal view returns (bool) {
        // Implement your KYC logic here
        return true; // Placeholder for actual implementation
    }
}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'offer', 'complexity': 10}, {'function': 'setTokenContract', 'complexity': 0}, {'function': 'setEnforceKyc', 'complexity': 0}, {'function': 'setSellFloor', 'complexity': 0}, {'function': 'setSellCeiling', 'complexity': 0}, {'function': 'isAllowedTrade', 'complexity': 0}]",14.0,"{""type"": ""FunctionDefinition"", ""name"": ""offerTokensForSale"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""erc20Address"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""ERC20""}, ""name"": ""erc20"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""ERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""erc20Address""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Invalid amount""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient allowance""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""erc20""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'balanceOf', 'complexity': 0}, {'function': 'offer', 'complexity': 10}, {'function': 'setTokenContract', 'complexity': 0}, {'function': 'setEnforceKyc', 'complexity': 0}, {'function': 'setSellFloor', 'complexity': 0}, {'function': 'setSellCeiling', 'complexity': 0}, {'function': 'isAllowedTrade', 'complexity': 0}]",14.0,"
pragma solidity ^0.8.0;

import ""./ERC20.sol"";
import ""./SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function offerTokensForSale(address erc20Address, uint256 amount) public {
        ERC20 erc20 = ERC20(erc20Address);
        require(amount > 0, ""Invalid amount"");
        require(erc20.allowance(msg.sender, address(this)) >= amount, ""Insufficient allowance"");
        erc20.transferFrom(msg.sender, address(this), amount);
    }
}",3.0738141536712646,offerTokensForSale,"[{'function': 'offerTokensForSale', 'complexity': 2}]",3.0,87.0,0.7103904849627187,0.0287333811107031,"pragma solidity ^0.8.0;

import ""./ERC20.sol"";
import ""openzeppelin/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;
    address public constant OWNER = 0x1111111111111111111111111111111111111111; // Replace with your owner's address
    bool public initialized = true;
    bytes32 public constant INIT_BYTES32 = bytes32('init');

    constructor() Ownable(OWNER) {}

    function offerTokensForSale(address erc20Address, uint256 amount) public {
        ERC20 erc20 = ERC20(erc20Address);
        require(amount > 0, ""Invalid amount"");
        require(erc20.allowance(msg.sender, address(this)) >= amount, ""Insufficient allowance"");
        erc20.transferFrom(msg.sender, address(this), amount);
    }
}"
2112,This method can be used by the controller to extract mistakenly sent tokens to this contract .,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

interface ERC20Token {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

abstract contract TokenClaimer is Ownable {
    using SafeMath for uint256;

    event ClaimedTokens(address indexed token, address indexed receiver, uint256 amount);

    function claimTokens(address _token) public onlyOwner {
        if (_token == address(0)) {
            payable(owner()).transfer(address(this).balance);
            return;
        }
        ERC20Token token = ERC20Token(_token);
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), ""Transfer failed"");
        emit ClaimedTokens(_token, owner(), balance);
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 2}]",3.0,"{""type"": ""FunctionDefinition"", ""name"": ""extractMistakenTokens"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""tokenAddress"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""tokenAddress""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token address must be provided""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""amount""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}, {""type"": ""stringLiteral"", ""value"": ""Amount must be greater than zero""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""tokenAddress""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balance""}, ""right"": {""type"": ""Identifier"", ""name"": ""amount""}}, {""type"": ""stringLiteral"", ""value"": ""Insufficient funds""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, {""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [{""type"": ""ModifierInvocation"", ""name"": ""onlyOwner"", ""arguments"": []}], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'claimTokens', 'complexity': 2}]",3.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function extractMistakenTokens(address tokenAddress, uint256 amount) public onlyOwner {
        require(tokenAddress != address(0), ""Token address must be provided"");
        require(amount > 0, ""Amount must be greater than zero"");

        IERC20 token = IERC20(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        require(balance >= amount, ""Insufficient funds"");

        token.transfer(msg.sender, amount);
    }
}",3.666321039199829,extractMistakenTokens,"[{'function': 'extractMistakenTokens', 'complexity': 3}]",4.0,21.0,0.6406716079957161,0.2943865816303566,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function extractMistakenTokens(address tokenAddress, uint256 amount) public onlyOwner {
        require(tokenAddress != address(0), ""Token address must be provided"");
        require(amount > 0, ""Amount must be greater than zero"");

        IERC20 token = IERC20(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        require(balance >= amount, ""Insufficient funds"");

        token.transfer(msg.sender, amount);
    }
}"
5098,send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

abstract contract ERC20Wrapper is Ownable, SafeMath {
    using SafeMath for uint256;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public withdrawalRequests;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        if (withdrawalRequests[_from] > 0) revert();
        if (withdrawalRequests[_to] > 0) revert();
        if (balanceOf[_from].sub(balanceOf[_from]) != balanceOf[_from]) revert();
        if (balanceOf[_to].add(_value) < balanceOf[_to]) revert();
        if (_value.add(allowance[_from][msg.sender]) != allowance[_from][msg.sender]) revert();
        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }
}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 0}]",6.0,"{""type"": ""FunctionDefinition"", ""name"": ""transferFrom"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_from"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_to"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_value"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">"", ""left"": {""type"": ""Identifier"", ""name"": ""_value""}, ""right"": {""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""||"", ""left"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_from""}}, ""right"": {""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""Identifier"", ""name"": ""_to""}}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""IERC20""}, ""name"": ""token"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""allowance""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balanceBeforeTransfer"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": "">="", ""left"": {""type"": ""Identifier"", ""name"": ""balanceBeforeTransfer""}, ""right"": {""type"": ""Identifier"", ""name"": ""_value""}}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""transferSuccessful"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""token""}, ""memberName"": ""transferFrom""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_from""}, {""type"": ""Identifier"", ""name"": ""_to""}, {""type"": ""Identifier"", ""name"": ""_value""}], ""names"": []}}, {""type"": ""IfStatement"", ""condition"": {""type"": ""Identifier"", ""name"": ""transferSuccessful""}, ""TrueBody"": {""type"": ""Block"", ""statements"": [{""type"": ""BooleanLiteral"", ""value"": True}]}, ""FalseBody"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""revert""}, ""arguments"": [{""type"": ""stringLiteral"", ""value"": ""Transfer failed""}], ""names"": []}}]}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transferFrom', 'complexity': 0}, {'function': 'transferFrom', 'complexity': 0}]",6.0,"
pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract MyContract {
    using SafeMath for uint256;

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value > 0);
        require(msg.sender == _from || msg.sender == _to);

        IERC20 token = IERC20(_from);
        require(token.allowance(_from, address(this)) >= _value);

        uint256 balanceBeforeTransfer = token.balanceOf(_from);
        require(balanceBeforeTransfer >= _value);

        bool transferSuccessful = token.transferFrom(_from, _to, _value);
        if (transferSuccessful) {
            return true;
        } else {
            revert(""Transfer failed"");
        }
    }
}",5.617564678192139,transferFrom,"[{'function': 'transferFrom', 'complexity': 6}]",9.0,75.0,0.9078246147198296,0.3013661505922306,"pragma solidity ^0.8.0;

import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol"";
import ""https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"";

contract MyContract is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value > 0);
        require(msg.sender == _from || msg.sender == _to);

        IERC20 token = IERC20(_from);
        require(token.allowance(_from, address(this)) >= _value);

        uint256 balanceBeforeTransfer = token.balanceOf(_from);
        require(balanceBeforeTransfer >= _value);

        bool transferSuccessful = token.transferFrom(_from, _to, _value);
        if (transferSuccessful) {
            return true;
        } else {
            revert(""Transfer failed"");
        }
    }
}"
3297,Used by a staker to withdraw their initial stake,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
}

abstract contract StakingContract is Ownable {
    using SafeMath for uint256;

    enum StakeStateEnum { staked, released }

    struct Stake {
        uint256 initialStake;
        StakeStateEnum state;
    }

    mapping(address => mapping(uint256 => Stake)) public stakes;
    uint256 public activeStakes;
    mapping(address => uint256) public internalRTCBalances;
    IERC20 public RTI;

    event InitialStakeWithdrawn(address indexed user, uint256 stakeNumber, uint256 amount);

    modifier validInitialStakeRelease(uint256 _stakeNumber) {
        require(stakes[msg.sender][_stakeNumber].state == StakeStateEnum.staked, ""Invalid stake state"");
        _;
    }

    function withdrawInitialStake(uint256 _stakeNumber) public validInitialStakeRelease(_stakeNumber) returns (bool) {
        uint256 initialStake = stakes[msg.sender][_stakeNumber].initialStake;
        stakes[msg.sender][_stakeNumber].state = StakeStateEnum.released;
        activeStakes = activeStakes.sub(1);
        internalRTCBalances[msg.sender] = internalRTCBalances[msg.sender].sub(initialStake);
        emit InitialStakeWithdrawn(msg.sender, _stakeNumber, initialStake);
        require(RTI.transfer(msg.sender, initialStake), ""Unable to transfer tokens likely due to incorrect balance"");
        return true;
    }
}","[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawInitialStake', 'complexity': 1}]",2.0,"{""type"": ""FunctionDefinition"", ""name"": ""withdrawStake"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""_stakeId"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": [], ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""<="", ""left"": {""type"": ""Identifier"", ""name"": ""_stakeId""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""memberName"": ""length""}}, {""type"": ""stringLiteral"", ""value"": ""Invalid stake ID""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""UserDefinedTypeName"", ""namePath"": ""Stake""}, ""name"": ""stake"", ""storageLocation"": ""memory""}], ""initialValue"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_stakeId""}}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""=="", ""left"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}, ""right"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stake""}, ""memberName"": ""owner""}}, {""type"": ""stringLiteral"", ""value"": ""Only the owner can withdraw their initial stake""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""amount"", ""storageLocation"": None}], ""initialValue"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""stake""}, ""memberName"": ""amount""}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""UnaryOperation"", ""operator"": ""delete"", ""subExpression"": {""type"": ""IndexAccess"", ""base"": {""type"": ""Identifier"", ""name"": ""stakes""}, ""index"": {""type"": ""Identifier"", ""name"": ""_stakeId""}}, ""isPrefix"": True}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""payable""}, ""arguments"": [{""type"": ""MemberAccess"", ""expression"": {""type"": ""Identifier"", ""name"": ""msg""}, ""memberName"": ""sender""}], ""names"": []}, ""memberName"": ""transfer""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""amount""}], ""names"": []}}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'transfer', 'complexity': 0}, {'function': 'withdrawInitialStake', 'complexity': 1}]",2.0,"
function withdrawStake(uint256 _stakeId) public {
    require(_stakeId <= stakes.length, ""Invalid stake ID"");
    Stake memory stake = stakes[_stakeId];
    require(msg.sender == stake.owner, ""Only the owner can withdraw their initial stake"");
    uint256 amount = stake.amount;
    delete stakes[_stakeId];
    payable(msg.sender).transfer(amount);
}",2.083484172821045,withdrawStake,"[{'function': 'withdrawStake', 'complexity': 2}]",3.0,50.0,0.7821161214566125,0.0171647359439065,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";
contract MyContract is Ownable {
    struct Stake {
        uint256 amount;
        address owner;
    }

    Stake[] public stakes;

    constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        // uint/uint256: Set to 1 (never 0)
        // address: Use fixed values in order: 0x1111111111111111111111111111111111111111, 0x2222222222222222222222222222222222222222, 0x3333333333333333333333333333333333333333
        // bool: Set to true
        // string: Set to 'initialized'
        // bytes32: Set to bytes32('init')
    }

    function withdrawStake(uint256 _stakeId) public {
        require(_stakeId <= stakes.length, ""Invalid stake ID"");
        Stake memory stake = stakes[_stakeId];
        require(msg.sender == stake.owner, ""Only the owner can withdraw their initial stake"");
        uint256 amount = stake.amount;
        delete stakes[_stakeId];
        payable(msg.sender).transfer(amount);
    }
}"
1877,A function which allows the caller to approve the max amount of any given token,"// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""openzeppelin/SafeMath.sol"";

interface ERC20 {
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

library SafeERC20 {
    using SafeMath for uint256;

    function safeApprove(address token, address spender, uint256 value) internal returns (bool) {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(ERC20.approve.selector, spender, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""SafeERC20: approve failed"");
        return true;
    }
}

abstract contract Wrapper is Ownable {
    using SafeMath for uint256;

    function approveAddress(address addressToApprove, address token) public onlyOwner {
        if (ERC20(token).allowance(address(this), addressToApprove) == 0) {
            require(SafeERC20.safeApprove(token, addressToApprove, uint256(-1)));
        }
    }
}","[{'function': 'approve', 'complexity': 0}, {'function': 'safeApprove', 'complexity': 3}, {'function': 'approveAddress', 'complexity': 2}]",4.0,"{""type"": ""FunctionDefinition"", ""name"": ""approveMax"", ""parameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_token"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}, {""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""name"": ""_spender"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""returnParameters"": {""type"": ""ParameterList"", ""parameters"": [{""type"": ""Parameter"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""bool""}, ""name"": ""success"", ""storageLocation"": None, ""isStateVar"": False, ""isIndexed"": False}]}, ""body"": {""type"": ""Block"", ""statements"": [{""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_token""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Token cannot be 0x0""}], ""names"": []}}, {""type"": ""ExpressionStatement"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""require""}, ""arguments"": [{""type"": ""BinaryOperation"", ""operator"": ""!="", ""left"": {""type"": ""Identifier"", ""name"": ""_spender""}, ""right"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""NumberLiteral"", ""number"": ""0"", ""subdenomination"": None}], ""names"": []}}, {""type"": ""stringLiteral"", ""value"": ""Spender cannot be 0x0""}], ""names"": []}}, {""type"": ""VariableDeclarationStatement"", ""variables"": [{""type"": ""VariableDeclaration"", ""typeName"": {""type"": ""ElementaryTypeName"", ""name"": ""uint256""}, ""name"": ""balance"", ""storageLocation"": None}], ""initialValue"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, ""memberName"": ""balanceOf""}, ""arguments"": [{""type"": ""FunctionCall"", ""expression"": {""type"": ""ElementaryTypeName"", ""name"": ""address""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""this""}], ""names"": []}], ""names"": []}}, {""type"": ""FunctionCall"", ""expression"": {""type"": ""MemberAccess"", ""expression"": {""type"": ""FunctionCall"", ""expression"": {""type"": ""Identifier"", ""name"": ""IERC20""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_token""}], ""names"": []}, ""memberName"": ""approve""}, ""arguments"": [{""type"": ""Identifier"", ""name"": ""_spender""}, {""type"": ""Identifier"", ""name"": ""balance""}], ""names"": []}]}, ""visibility"": ""public"", ""modifiers"": [], ""isConstructor"": False, ""isFallback"": False, ""isReceive"": False, ""stateMutability"": None}","[{'function': 'approve', 'complexity': 0}, {'function': 'safeApprove', 'complexity': 3}, {'function': 'approveAddress', 'complexity': 2}]",4.0,"pragma solidity ^0.8.0;

import ""./SafeMath.sol"";

contract TokenApprover {
    using SafeMath for uint256;

    function approveMax(address _token, address _spender) public returns (bool success) {
        require(_token != address(0), ""Token cannot be 0x0"");
        require(_spender != address(0), ""Spender cannot be 0x0"");

        uint256 balance = IERC20(_token).balanceOf(address(this));
        return IERC20(_token).approve(_spender, balance);
    }
}",2.901207208633423,approveMax,"[{'function': 'approveMax', 'complexity': 2}]",3.0,44.0,0.7523660212392957,0.1011085135028091,"pragma solidity ^0.8.0;

import ""openzeppelin/SafeMath.sol"";
import ""node_modules/@openzeppelin/contracts/access/Ownable.sol"";

contract TokenApprover is Ownable {
    using SafeMath for uint256;

    uint256 public totalSupply;

 mapping(address => uint256) public balanceOf;

 constructor() Ownable(msg.sender) {
        // Initialize state variables with safe, non-corner-case values
        balanceOf[msg.sender] = 1000; // Set to 1 (never 0)
        totalSupply = 1000000000000000000; // Set to 1 (never 0)
    }

    function approveMax(address _token, address _spender) public returns (bool success) {
        require(_token != address(0), ""Token cannot be 0x0"");
        require(_spender != address(0), ""Spender cannot be 0x0"");

        uint256 balance = IERC20(_token).balanceOf(address(this));
        return IERC20(_token).approve(_spender, balance);
    }
}"
